<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.14.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="一、链表BM1 反转链表 描述给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。  数据范围： 0≤n≤10000≤n≤1000 要求：空间复杂度 O(1)，时间复杂度 O(n)。  思路：迭代12345678910111213public class Solution &amp;#123;    public ListNode R">
<meta property="og:type" content="article">
<meta property="og:title" content="牛客必刷100题">
<meta property="og:url" content="http://example.com/2023/02/24/34-%E7%89%9B%E5%AE%A2%E5%BF%85%E5%88%B7100/index.html">
<meta property="og:site_name" content="Cloudyun">
<meta property="og:description" content="一、链表BM1 反转链表 描述给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。  数据范围： 0≤n≤10000≤n≤1000 要求：空间复杂度 O(1)，时间复杂度 O(n)。  思路：迭代12345678910111213public class Solution &amp;#123;    public ListNode R">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://picgooo.oss-cn-hangzhou.aliyuncs.com/img/D024AA6BA7A670402678A9ACAD54EB10.gif">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/files/20210621/908787715_1624289962297/36.gif">
<meta property="og:image" content="https://picgooo.oss-cn-hangzhou.aliyuncs.com/img/9EB9CD58B9EA5E04C890326B5C1F471F.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/1614274007-rtFHbG-Picture2.png">
<meta property="og:image" content="https://picgooo.oss-cn-hangzhou.aliyuncs.com/img/E1F1270919D292C9F48F51975FD07CE2.png">
<meta property="og:image" content="https://picgooo.oss-cn-hangzhou.aliyuncs.com/img/A22A794C036C06431E632F9D5E2E298F.png">
<meta property="og:image" content="https://picgooo.oss-cn-hangzhou.aliyuncs.com/img/63C9C80875EEB9DD09F51096A6752306.gif">
<meta property="og:image" content="https://picgooo.oss-cn-hangzhou.aliyuncs.com/img/4760A3E42ACB7E73D162BE2CD8C2E2C9.gif">
<meta property="og:image" content="https://pic.leetcode-cn.com/e231fde16304948251633cfc65d04396f117239ea2d13896b1d2678de9067b42-Picture1.png">
<meta property="og:image" content="https://picgooo.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2023-05-04%2020.44.46.png">
<meta property="article:published_time" content="2023-02-24T06:35:28.000Z">
<meta property="article:modified_time" content="2023-05-05T08:21:20.521Z">
<meta property="article:author" content="Yann Cheung">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="刷题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://picgooo.oss-cn-hangzhou.aliyuncs.com/img/D024AA6BA7A670402678A9ACAD54EB10.gif">


<link rel="canonical" href="http://example.com/2023/02/24/34-%E7%89%9B%E5%AE%A2%E5%BF%85%E5%88%B7100/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2023/02/24/34-%E7%89%9B%E5%AE%A2%E5%BF%85%E5%88%B7100/","path":"2023/02/24/34-牛客必刷100/","title":"牛客必刷100题"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>牛客必刷100题 | Cloudyun</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Cloudyun</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Yann Cheungの博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">19</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">5</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">37</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E9%93%BE%E8%A1%A8"><span class="nav-number">1.</span> <span class="nav-text">一、链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#BM1-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">1.1.</span> <span class="nav-text">BM1 反转链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%8F%E8%BF%B0"><span class="nav-number">1.2.</span> <span class="nav-text">描述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E8%BF%AD%E4%BB%A3"><span class="nav-number">1.2.1.</span> <span class="nav-text">思路：迭代</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM2-%E9%93%BE%E8%A1%A8%E5%86%85%E6%8C%87%E5%AE%9A%E5%8C%BA%E9%97%B4%E5%8F%8D%E8%BD%AC"><span class="nav-number">1.3.</span> <span class="nav-text">BM2 链表内指定区间反转</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E4%B8%80%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="nav-number">1.3.1.</span> <span class="nav-text">思路：一次遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM3-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%E6%AF%8Fk%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC"><span class="nav-number">1.4.</span> <span class="nav-text">BM3 链表中的节点每k个一组翻转</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E9%80%92%E5%BD%92"><span class="nav-number">1.4.1.</span> <span class="nav-text">思路：递归</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM4-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8"><span class="nav-number">1.5.</span> <span class="nav-text">BM4 合并两个排序的链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E9%80%92%E5%BD%92-1"><span class="nav-number">1.5.1.</span> <span class="nav-text">思路：递归</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM6-%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E4%B8%AD%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF"><span class="nav-number">1.6.</span> <span class="nav-text">BM6 判断链表中是否有环</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88"><span class="nav-number">1.6.1.</span> <span class="nav-text">思路：快慢指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM7-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9"><span class="nav-number">1.7.</span> <span class="nav-text">BM7 链表中环的入口结点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88-1"><span class="nav-number">1.7.1.</span> <span class="nav-text">思路：快慢指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM8-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E6%9C%80%E5%90%8Ek%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="nav-number">1.8.</span> <span class="nav-text">BM8 链表中倒数最后k个结点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88-2"><span class="nav-number">1.8.1.</span> <span class="nav-text">思路：快慢指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM9-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="nav-number">1.9.</span> <span class="nav-text">BM9 删除链表的倒数第n个节点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88-3"><span class="nav-number">1.9.1.</span> <span class="nav-text">思路：快慢指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM10-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9"><span class="nav-number">1.10.</span> <span class="nav-text">BM10 两个链表的第一个公共结点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-number">1.10.1.</span> <span class="nav-text">思路：双指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM11-%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%8A%A0-%E4%BA%8C"><span class="nav-number">1.11.</span> <span class="nav-text">BM11 链表相加(二)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E7%9B%B4%E6%8E%A5%E6%A8%A1%E6%8B%9F"><span class="nav-number">1.11.1.</span> <span class="nav-text">思路：直接模拟</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM12-%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8E%92%E5%BA%8F"><span class="nav-number">1.12.</span> <span class="nav-text">BM12 单链表的排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F"><span class="nav-number">1.12.1.</span> <span class="nav-text">思路：转化为数组排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM13-%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E4%B8%BA%E5%9B%9E%E6%96%87%E7%BB%93%E6%9E%84"><span class="nav-number">1.13.</span> <span class="nav-text">BM13 判断一个链表是否为回文结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E9%80%90%E4%B8%80%E5%88%A4%E6%96%AD"><span class="nav-number">1.13.1.</span> <span class="nav-text">思路：反转链表逐一判断</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM14-%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A5%87%E5%81%B6%E9%87%8D%E6%8E%92"><span class="nav-number">1.14.</span> <span class="nav-text">BM14 链表的奇偶重排</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%8F%E8%BF%B0-1"><span class="nav-number">1.15.</span> <span class="nav-text">描述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%8F%8C%E6%8C%87%E9%92%88-1"><span class="nav-number">1.15.1.</span> <span class="nav-text">思路：双指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM15-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E5%85%83%E7%B4%A0-I"><span class="nav-number">1.16.</span> <span class="nav-text">BM15 删除有序链表中重复的元素-I</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E9%81%8D%E5%8E%86"><span class="nav-number">1.16.1.</span> <span class="nav-text">思路：遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM16-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E5%85%83%E7%B4%A0-II"><span class="nav-number">1.17.</span> <span class="nav-text">BM16 删除有序链表中重复的元素-II</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E9%81%8D%E5%8E%86-1"><span class="nav-number">1.17.1.</span> <span class="nav-text">思路：遍历</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-number">2.</span> <span class="nav-text">二、二分查找</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#BM17-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-I"><span class="nav-number">2.1.</span> <span class="nav-text">BM17 二分查找-I</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM18-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="nav-number">2.2.</span> <span class="nav-text">BM18 二维数组中的查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-number">2.2.1.</span> <span class="nav-text">思路：二分查找</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM19-%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC"><span class="nav-number">2.3.</span> <span class="nav-text">BM19 寻找峰值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-1"><span class="nav-number">2.3.1.</span> <span class="nav-text">思路：二分查找</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM20-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9"><span class="nav-number">2.4.</span> <span class="nav-text">BM20 数组中的逆序对</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">2.4.1.</span> <span class="nav-text">思路：归并排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM21-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97"><span class="nav-number">2.5.</span> <span class="nav-text">BM21 旋转数组的最小数字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-2"><span class="nav-number">2.5.1.</span> <span class="nav-text">思路：二分查找</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM22-%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7"><span class="nav-number">2.6.</span> <span class="nav-text">BM22 比较版本号</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%8F%8C%E6%8C%87%E9%92%88-2"><span class="nav-number">2.6.1.</span> <span class="nav-text">思路：双指针</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">3.</span> <span class="nav-text">三、二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#BM23-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">3.1.</span> <span class="nav-text">BM23 二叉树的前序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E9%80%92%E5%BD%92-2"><span class="nav-number">3.1.1.</span> <span class="nav-text">思路：递归</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM24-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">3.2.</span> <span class="nav-text">BM24 二叉树的中序遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM25-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">3.3.</span> <span class="nav-text">BM25 二叉树的后序遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM26-%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">3.4.</span> <span class="nav-text">BM26 求二叉树的层序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9ABFS%EF%BC%88%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%89"><span class="nav-number">3.4.1.</span> <span class="nav-text">思路：BFS（广度优先搜索）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM27-%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">3.5.</span> <span class="nav-text">BM27 按之字形顺序打印二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9ABFS"><span class="nav-number">3.6.</span> <span class="nav-text">思路：BFS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM28-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="nav-number">3.7.</span> <span class="nav-text">BM28 二叉树的最大深度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E9%80%92%E5%BD%92-3"><span class="nav-number">3.7.1.</span> <span class="nav-text">思路：递归</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM29-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84-%E4%B8%80"><span class="nav-number">3.8.</span> <span class="nav-text">BM29 二叉树中和为某一值的路径(一)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E9%80%92%E5%BD%92-4"><span class="nav-number">3.8.1.</span> <span class="nav-text">思路：递归</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM30-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="nav-number">3.9.</span> <span class="nav-text">BM30 二叉搜索树与双向链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%88%A9%E7%94%A8%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%89%B9%E5%BE%81%E8%BF%9B%E8%A1%8C%E9%80%92%E5%BD%92"><span class="nav-number">3.9.1.</span> <span class="nav-text">思路：利用二叉搜索树的特征进行递归</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM31-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">3.10.</span> <span class="nav-text">BM31 对称的二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E9%80%92%E5%BD%92-5"><span class="nav-number">3.10.1.</span> <span class="nav-text">思路：递归</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM32-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">3.11.</span> <span class="nav-text">BM32 合并二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E9%80%92%E5%BD%92-6"><span class="nav-number">3.11.1.</span> <span class="nav-text">思路：递归</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM33-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F"><span class="nav-number">3.12.</span> <span class="nav-text">BM33 二叉树的镜像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM34-%E5%88%A4%E6%96%AD%E6%98%AF%E4%B8%8D%E6%98%AF%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">3.13.</span> <span class="nav-text">BM34 判断是不是二叉搜索树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM35-%E5%88%A4%E6%96%AD%E6%98%AF%E4%B8%8D%E6%98%AF%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">3.14.</span> <span class="nav-text">BM35 判断是不是完全二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86BFS"><span class="nav-number">3.14.1.</span> <span class="nav-text">思路：层序遍历BFS</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM36-%E5%88%A4%E6%96%AD%E6%98%AF%E4%B8%8D%E6%98%AF%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">3.15.</span> <span class="nav-text">BM36 判断是不是平衡二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E4%BB%8E%E5%BA%95%E8%87%B3%E9%A1%B6"><span class="nav-number">3.15.1.</span> <span class="nav-text">思路：从底至顶</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM37-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">3.16.</span> <span class="nav-text">BM37 二叉搜索树的最近公共祖先</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E9%81%8D%E5%8E%86-2"><span class="nav-number">3.16.1.</span> <span class="nav-text">思路：遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM38-%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%BE%E5%88%B0%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">3.17.</span> <span class="nav-text">BM38 在二叉树中找到两个节点的最近公共祖先</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%9B%9E%E6%BA%AF-DFS"><span class="nav-number">3.17.1.</span> <span class="nav-text">思路：回溯+DFS</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM40-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">3.18.</span> <span class="nav-text">BM40 重建二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM41-%E8%BE%93%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE"><span class="nav-number">3.19.</span> <span class="nav-text">BM41 输出二叉树的右视图</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E5%A0%86-x2F-%E6%A0%88-x2F-%E9%98%9F%E5%88%97"><span class="nav-number">4.</span> <span class="nav-text">四、堆&#x2F;栈&#x2F;队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#BM42-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="nav-number">4.1.</span> <span class="nav-text">BM42 用两个栈实现队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E6%A0%88"><span class="nav-number">4.1.1.</span> <span class="nav-text">思路：栈</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM43-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88"><span class="nav-number">4.2.</span> <span class="nav-text">BM43 包含min函数的栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A"><span class="nav-number">4.2.1.</span> <span class="nav-text">思路：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM44-%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97"><span class="nav-number">4.3.</span> <span class="nav-text">BM44 有效括号序列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E6%A8%A1%E6%8B%9F%E6%A0%88"><span class="nav-number">4.3.1.</span> <span class="nav-text">思路：模拟栈</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM45-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="nav-number">4.4.</span> <span class="nav-text">BM45 滑动窗口的最大值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97"><span class="nav-number">4.4.1.</span> <span class="nav-text">思路：单调队列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM46-%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0"><span class="nav-number">4.5.</span> <span class="nav-text">BM46 最小的K个数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF1%EF%BC%9Asort%E5%BF%AB%E6%8E%92"><span class="nav-number">4.5.1.</span> <span class="nav-text">思路1：sort快排</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF2%EF%BC%9A%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="nav-number">4.6.</span> <span class="nav-text">思路2：堆排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM47-%E5%AF%BB%E6%89%BE%E7%AC%ACK%E5%A4%A7"><span class="nav-number">4.7.</span> <span class="nav-text">BM47 寻找第K大</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF1%EF%BC%9A%E9%9A%8F%E6%9C%BA%E9%80%89%E6%8B%A9"><span class="nav-number">4.7.1.</span> <span class="nav-text">思路1：随机选择</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF2%EF%BC%9A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95"><span class="nav-number">4.8.</span> <span class="nav-text">思路2：内置方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM48-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="nav-number">4.9.</span> <span class="nav-text">BM48 数据流中的中位数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97"><span class="nav-number">4.9.1.</span> <span class="nav-text">思路：优先级队列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM49-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="nav-number">4.10.</span> <span class="nav-text">BM49 表达式求值</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E5%93%88%E5%B8%8C"><span class="nav-number">5.</span> <span class="nav-text">五、哈希</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#BM50-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">5.1.</span> <span class="nav-text">BM50 两数之和</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%93%88%E5%B8%8C"><span class="nav-number">5.1.1.</span> <span class="nav-text">思路：哈希</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM51-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number">5.2.</span> <span class="nav-text">BM51 数组中出现次数超过一半的数字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%93%88%E5%B8%8C-1"><span class="nav-number">5.2.1.</span> <span class="nav-text">思路：哈希</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM52-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97"><span class="nav-number">5.3.</span> <span class="nav-text">BM52 数组中只出现一次的两个数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM53-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B4%E6%95%B0"><span class="nav-number">5.4.</span> <span class="nav-text">BM53 缺失的第一个正整数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM-54-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">5.5.</span> <span class="nav-text">BM 54 三数之和</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E6%8E%92%E5%BA%8F-%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-number">5.5.1.</span> <span class="nav-text">思路：排序+双指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM55-%E6%B2%A1%E6%9C%89%E9%87%8D%E5%A4%8D%E9%A1%B9%E6%95%B0%E5%AD%97%E7%9A%84%E5%85%A8%E6%8E%92%E5%88%97"><span class="nav-number">5.6.</span> <span class="nav-text">BM55 没有重复项数字的全排列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%9B%9E%E6%BA%AF"><span class="nav-number">5.6.1.</span> <span class="nav-text">思路：回溯</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM56-%E6%9C%89%E9%87%8D%E5%A4%8D%E9%A1%B9%E6%95%B0%E5%AD%97%E7%9A%84%E5%85%A8%E6%8E%92%E5%88%97"><span class="nav-number">5.7.</span> <span class="nav-text">BM56 有重复项数字的全排列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%9B%9E%E6%BA%AF-1"><span class="nav-number">5.7.1.</span> <span class="nav-text">思路：回溯</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM57-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F"><span class="nav-number">5.8.</span> <span class="nav-text">BM57 岛屿数量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9Adfs"><span class="nav-number">5.8.1.</span> <span class="nav-text">思路：dfs</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM58-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97"><span class="nav-number">5.9.</span> <span class="nav-text">BM58 字符串的排列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%9B%9E%E6%BA%AF-2"><span class="nav-number">5.9.1.</span> <span class="nav-text">思路：回溯</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM60-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90"><span class="nav-number">5.10.</span> <span class="nav-text">BM60 括号生成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM61-%E7%9F%A9%E9%98%B5%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84"><span class="nav-number">5.11.</span> <span class="nav-text">BM61 矩阵最长递增路径</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E8%AE%B0%E5%BF%86%E6%90%9C%E7%B4%A2"><span class="nav-number">5.11.1.</span> <span class="nav-text">思路：记忆搜索</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">6.</span> <span class="nav-text">七、动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#BM62-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="nav-number">6.1.</span> <span class="nav-text">BM62 斐波那契数列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM63-%E8%B7%B3%E5%8F%B0%E9%98%B6"><span class="nav-number">6.2.</span> <span class="nav-text">BM63 跳台阶</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM64-%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="nav-number">6.3.</span> <span class="nav-text">BM64 最小花费爬楼梯</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM65-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97-%E4%BA%8C"><span class="nav-number">6.4.</span> <span class="nav-text">BM65 最长公共子序列(二)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">6.4.1.</span> <span class="nav-text">思路：动态规划</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM66-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2"><span class="nav-number">6.5.</span> <span class="nav-text">BM66 最长公共子串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-1"><span class="nav-number">6.5.1.</span> <span class="nav-text">思路：动态规划</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM67-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%E7%9A%84%E6%95%B0%E7%9B%AE-%E4%B8%80"><span class="nav-number">6.6.</span> <span class="nav-text">BM67 不同路径的数目(一)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM68-%E7%9F%A9%E9%98%B5%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="nav-number">6.7.</span> <span class="nav-text">BM68 矩阵的最小路径和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM69-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">6.8.</span> <span class="nav-text">BM69 把数字翻译成字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM70-%E5%85%91%E6%8D%A2%E9%9B%B6%E9%92%B1-%E4%B8%80"><span class="nav-number">6.9.</span> <span class="nav-text">BM70 兑换零钱(一)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">6.9.1.</span> <span class="nav-text">思路：完全背包问题——动态规划</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM71-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97-%E4%B8%80"><span class="nav-number">6.10.</span> <span class="nav-text">BM71 最长上升子序列(一)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-2"><span class="nav-number">6.10.1.</span> <span class="nav-text">思路：动态规划</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM72-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C"><span class="nav-number">6.11.</span> <span class="nav-text">BM72 连续子数组的最大和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM73-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="nav-number">6.12.</span> <span class="nav-text">BM73 最长回文子串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E4%B8%AD%E5%BF%83%E6%89%A9%E5%B1%95"><span class="nav-number">6.12.1.</span> <span class="nav-text">思路：中心扩展</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM74-%E6%95%B0%E5%AD%97%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E5%8C%96%E6%88%90IP%E5%9C%B0%E5%9D%80"><span class="nav-number">6.13.</span> <span class="nav-text">BM74 数字字符串转化成IP地址</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AB%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">7.</span> <span class="nav-text">八、字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#BM83-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%98%E5%BD%A2"><span class="nav-number">7.1.</span> <span class="nav-text">BM83 字符串变形</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%8F%8C%E5%8F%8D%E8%BD%AC"><span class="nav-number">7.1.1.</span> <span class="nav-text">思路：双反转</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM84-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80"><span class="nav-number">7.2.</span> <span class="nav-text">BM84 最长公共前缀</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E9%81%8D%E5%8E%86-3"><span class="nav-number">7.2.1.</span> <span class="nav-text">思路：遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM85-%E9%AA%8C%E8%AF%81IP%E5%9C%B0%E5%9D%80"><span class="nav-number">7.3.</span> <span class="nav-text">BM85 验证IP地址</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">7.3.1.</span> <span class="nav-text">思路：正则表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Ipv4%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E9%87%8A"><span class="nav-number">7.3.2.</span> <span class="nav-text">Ipv4正则表达式解释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IPv6%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E9%87%8A%EF%BC%9A"><span class="nav-number">7.3.3.</span> <span class="nav-text">IPv6正则表达式解释：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM86-%E5%A4%A7%E6%95%B0%E5%8A%A0%E6%B3%95"><span class="nav-number">7.4.</span> <span class="nav-text">BM86 大数加法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E6%A8%A1%E6%8B%9F%E6%B3%95"><span class="nav-number">7.4.1.</span> <span class="nav-text">思路：模拟法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E6%A8%A1%E6%8B%9F"><span class="nav-number">8.</span> <span class="nav-text">十一、模拟</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#BM97-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="nav-number">8.1.</span> <span class="nav-text">BM97 旋转数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E6%A8%A1%E6%8B%9F"><span class="nav-number">8.1.1.</span> <span class="nav-text">思路：模拟</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM98-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5"><span class="nav-number">8.2.</span> <span class="nav-text">BM98 螺旋矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E7%9B%B4%E6%8E%A5%E6%A8%A1%E6%8B%9F-1"><span class="nav-number">8.2.1.</span> <span class="nav-text">思路：直接模拟</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM99-%E9%A1%BA%E6%97%B6%E9%92%88%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5"><span class="nav-number">8.3.</span> <span class="nav-text">BM99 顺时针旋转矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E7%9F%A9%E9%98%B5%E8%BD%AC%E7%BD%AE-%E7%9F%A9%E9%98%B5%E5%8F%8D%E8%BD%AC"><span class="nav-number">8.3.1.</span> <span class="nav-text">思路：矩阵转置+矩阵反转</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yann Cheung"
      src="/images/avatar.JPG">
  <p class="site-author-name" itemprop="name">Yann Cheung</p>
  <div class="site-description" itemprop="description">忆我少年游，一梦到华胥</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">37</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Cloudyunn" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Cloudyunn" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="Back to top">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/24/34-%E7%89%9B%E5%AE%A2%E5%BF%85%E5%88%B7100/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.JPG">
      <meta itemprop="name" content="Yann Cheung">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cloudyun">
      <meta itemprop="description" content="忆我少年游，一梦到华胥">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="牛客必刷100题 | Cloudyun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          牛客必刷100题
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-02-24 14:35:28" itemprop="dateCreated datePublished" datetime="2023-02-24T14:35:28+08:00">2023-02-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-05 16:21:20" itemprop="dateModified" datetime="2023-05-05T16:21:20+08:00">2023-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>80k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>1:13</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="一、链表"><a href="#一、链表" class="headerlink" title="一、链表"></a>一、链表</h1><h2 id="BM1-反转链表"><a href="#BM1-反转链表" class="headerlink" title="BM1 反转链表"></a><strong>BM1</strong> <strong>反转链表</strong></h2><blockquote>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。 </p>
<p>数据范围： 0≤n≤10000≤<em>n</em>≤1000</p>
<p>要求：空间复杂度 O(1)，时间复杂度 O(n)。</p>
</blockquote>
<h3 id="思路：迭代"><a href="#思路：迭代" class="headerlink" title="思路：迭代"></a>思路：迭代</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">ReverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> curr.next;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="BM2-链表内指定区间反转"><a href="#BM2-链表内指定区间反转" class="headerlink" title="BM2 链表内指定区间反转"></a><strong>BM2</strong> <strong>链表内指定区间反转</strong></h2><blockquote>
<p>将一个节点数为 size 链表 m 位置到 n 位置之间的区间反转，要求时间复杂度 O(n)<em>O</em>(<em>n</em>)，空间复杂度 O(1)<em>O</em>(1)。<br>例如：<br>给出的链表为 1→2→3→4→5→NULL1→2→3→4→5→<em>N<strong>U</strong>L**L</em>, m&#x3D;2,n&#x3D;4<em>m</em>&#x3D;2,<em>n</em>&#x3D;4,<br>返回 1→4→3→2→5→NULL1→4→3→2→5→<em>N<strong>U</strong>L**L</em>.</p>
</blockquote>
<h3 id="思路：一次遍历"><a href="#思路：一次遍历" class="headerlink" title="思路：一次遍历"></a>思路：一次遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span> <span class="params">(ListNode head, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        dummyNode.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummyNode;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; m-<span class="number">1</span> ; i++)&#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> pre.next;</span><br><span class="line">        ListNode cur_next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n-m;i++)&#123;</span><br><span class="line">            cur_next = cur.next;</span><br><span class="line">            cur.next = cur_next.next;</span><br><span class="line">            cur_next.next = pre.next;</span><br><span class="line">            pre.next = cur_next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM3-链表中的节点每k个一组翻转"><a href="#BM3-链表中的节点每k个一组翻转" class="headerlink" title="BM3 链表中的节点每k个一组翻转"></a><strong>BM3</strong> <strong>链表中的节点每k个一组翻转</strong></h2><blockquote>
<p>将给出的链表中的节点每 k 个一组翻转，返回翻转后的链表<br>如果链表中的节点数不是 k 的倍数，将最后剩下的节点保持原样<br>你不能更改节点中的值，只能更改节点本身。 </p>
<p>数据范围： 0≤n≤2000 0≤<em>n</em>≤2000 ， 1≤k≤20001≤<em>k</em>≤2000 ，链表中每个元素都满足 0≤val≤10000≤<em>v<strong>a</strong>l</em>≤1000<br>要求空间复杂度 O(1)<em>O</em>(1)，时间复杂度 O(n)<em>O</em>(<em>n</em>)</p>
<p>例如： </p>
<p>给定的链表是 1→2→3→4→5</p>
<p>对于 k&#x3D;2, 你应该返回 2→1→4→3→5</p>
<p>对于 k&#x3D;3 , 你应该返回 3→2→1→4→5</p>
</blockquote>
<h3 id="思路：递归"><a href="#思路：递归" class="headerlink" title="思路：递归"></a>思路：递归</h3><p><img src="https://picgooo.oss-cn-hangzhou.aliyuncs.com/img/D024AA6BA7A670402678A9ACAD54EB10.gif"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span> <span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; k ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tail == <span class="literal">null</span>)    <span class="keyword">return</span> head;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(cur != tail)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next  = pre;</span><br><span class="line">            pre =cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        head.next = reverseKGroup(tail,k);</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM4-合并两个排序的链表"><a href="#BM4-合并两个排序的链表" class="headerlink" title="BM4 合并两个排序的链表"></a><strong>BM4</strong> <strong>合并两个排序的链表</strong></h2><blockquote>
<p>输入两个递增的链表，单个链表的长度为n，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>
<p>数据范围： 0≤n≤10000≤<em>n</em>≤1000，−1000≤节点值≤1000−1000≤节点值≤1000<br>要求：空间复杂度 O(1，时间复杂度 O(n)</p>
</blockquote>
<h3 id="思路：递归-1"><a href="#思路：递归-1" class="headerlink" title="思路：递归"></a>思路：递归</h3><p>这个题递归最容易理解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> &#123;</span><br><span class="line">        <span class="comment">// list1 list2为空的情况</span></span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="literal">null</span> || list2 == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list1 != <span class="literal">null</span> ? list1 : list2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 两个链表元素依次对比</span></span><br><span class="line">        <span class="keyword">if</span>(list1.val &lt;= list2.val)&#123;</span><br><span class="line">            <span class="comment">// 递归计算 list1.next, list2</span></span><br><span class="line">            list1.next = Merge(list1.next, list2);</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 递归计算 list1, list2.next</span></span><br><span class="line">            list2.next = Merge(list1, list2.next);</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM6-判断链表中是否有环"><a href="#BM6-判断链表中是否有环" class="headerlink" title="BM6 判断链表中是否有环"></a><strong>BM6</strong> <strong>判断链表中是否有环</strong></h2><blockquote>
<p>判断给定的链表中是否有环。如果有环则返回true，否则返回false。</p>
<p>数据范围：链表长度 0≤n≤10000，链表中任意节点的值满足 ∣val∣&lt;&#x3D;100000</p>
</blockquote>
<h3 id="思路：快慢指针"><a href="#思路：快慢指针" class="headerlink" title="思路：快慢指针"></a>思路：快慢指针</h3><p>如果有回环，快慢指针肯定会相遇</p>
<p>时间复杂度：O（N）</p>
<p>空间复杂度：O（1）</p>
<p>还有一种思路：使用HashSet来存节点，看是否用重复的就行，但这种方法的空间复杂度是O（N）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//先判断链表为空的情况</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//快慢双指针</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head; </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//如果没环快指针会先到链表尾</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>)&#123; </span><br><span class="line">            <span class="comment">//快指针移动两步</span></span><br><span class="line">            fast = fast.next.next; </span><br><span class="line">            <span class="comment">//慢指针移动一步</span></span><br><span class="line">            slow = slow.next; </span><br><span class="line">            <span class="comment">//相遇则有环</span></span><br><span class="line">            <span class="keyword">if</span>(fast == slow) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//到末尾则没有环</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM7-链表中环的入口结点"><a href="#BM7-链表中环的入口结点" class="headerlink" title="BM7 链表中环的入口结点"></a><strong>BM7</strong> <strong>链表中环的入口结点</strong></h2><blockquote>
<p>给一个长度为n链表，若其中包含环，请找出该链表的环的入口结点，否则，返回null。 </p>
<p>数据范围： n≤10000，1&lt;&#x3D;结点值&lt;&#x3D;10000</p>
<p>要求：空间复杂度 O(1)，时间复杂度 O(n)</p>
</blockquote>
<h3 id="思路：快慢指针-1"><a href="#思路：快慢指针-1" class="headerlink" title="思路：快慢指针"></a>思路：快慢指针</h3><p>经典题目，主要在于数学推导部分。</p>
<p>可以直接背一下～</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head,fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span>(fast.next != <span class="literal">null</span>)&#123;</span><br><span class="line">                fast = fast.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow )&#123;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">ptr</span> <span class="operator">=</span> head;</span><br><span class="line">                <span class="keyword">while</span>(ptr != slow)&#123;</span><br><span class="line">                    ptr = ptr.next;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM8-链表中倒数最后k个结点"><a href="#BM8-链表中倒数最后k个结点" class="headerlink" title="BM8 链表中倒数最后k个结点"></a><strong>BM8</strong> <strong>链表中倒数最后k个结点</strong></h2><blockquote>
<p>输入一个长度为 n 的链表，设链表中的元素的值为 ai ，返回该链表中倒数第k个节点。 </p>
<p>如果该链表长度小于k，请返回一个长度为 0 的链表。 </p>
<p>要求：空间复杂度 O(n)，时间复杂度 O(n)</p>
<p>进阶：空间复杂度 O(1)，时间复杂度 O(n)</p>
</blockquote>
<h3 id="思路：快慢指针-2"><a href="#思路：快慢指针-2" class="headerlink" title="思路：快慢指针"></a>思路：快慢指针</h3><p>要得到倒数第k个，就可以声明两个指针</p>
<p>第一个指针先走k步，然后两个指针再一起走，等到第一个指针为null的时候，第二个指针即为倒数第k个节点</p>
<p>时间复杂度：O（N）</p>
<p>空间复杂度：O（1）</p>
<p>第二种空间复杂度为O（N）的思路就是使用栈就行～</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">FindKthToTail</span> <span class="params">(ListNode pHead, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> pHead;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> pHead;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; k ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span>)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM9-删除链表的倒数第n个节点"><a href="#BM9-删除链表的倒数第n个节点" class="headerlink" title="BM9 删除链表的倒数第n个节点"></a><strong>BM9</strong> <strong>删除链表的倒数第n个节点</strong></h2><blockquote>
<p>给定一个链表，删除链表的倒数第 n 个节点并返回链表的头指针</p>
<p>例如， </p>
<p>给出的链表为: 1→2→3→4→5, n&#x3D;2<br>删除了链表的倒数第 n个节点之后,链表变为1→2→3→5</p>
<p>数据范围： 链表长度 0≤n≤1000，链表中任意节点的值满足 0≤val≤100</p>
<p>要求：空间复杂度 O(1)，时间复杂度 O(n)</p>
<p>备注： </p>
<p>题目保证 n 一定是有效的</p>
</blockquote>
<h3 id="思路：快慢指针-3"><a href="#思路：快慢指针-3" class="headerlink" title="思路：快慢指针"></a>思路：快慢指针</h3><p>要求空间复杂度为O（1）。因此和上题一样的思路，但是和上题找到倒数第k个节点不同的是，这里需要删除，所以应该找到倒数k+1个节点，然后将它的next指向到倒数第k-1个节点。</p>
<p>所以很简单的思路就是把slow指向head的前面一个哑节点，也俗称dummyHead，这样的话不会造成越界～</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span> <span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span>dummyHead;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            fast = fast.next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span>)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow.next = slow.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM10-两个链表的第一个公共结点"><a href="#BM10-两个链表的第一个公共结点" class="headerlink" title="BM10 两个链表的第一个公共结点"></a><strong>BM10</strong> <strong>两个链表的第一个公共结点</strong></h2><blockquote>
<p>输入两个无环的单向链表，找出它们的第一个公共结点，如果没有公共节点则返回空。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的） </p>
<p>数据范围： n≤100<br>要求：空间复杂度 O(1)，时间复杂度 O(n)</p>
</blockquote>
<h3 id="思路：双指针"><a href="#思路：双指针" class="headerlink" title="思路：双指针"></a>思路：双指针</h3><p>很经典的一个题，很好理解。注意这里为什么判断条件是l1和l2是否相等，因为两个指针要么找到公共节点的时候相等，要么就是同时为null。</p>
<p><img src="https://uploadfiles.nowcoder.com/files/20210621/908787715_1624289962297/36.gif"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">l1</span> <span class="operator">=</span> pHead1, l2 = pHead2;</span><br><span class="line">        <span class="keyword">while</span>(l1 != l2)&#123;</span><br><span class="line">            l1 = (l1==<span class="literal">null</span>)?pHead2:l1.next;</span><br><span class="line">            l2 = (l2==<span class="literal">null</span>)?pHead1:l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM11-链表相加-二"><a href="#BM11-链表相加-二" class="headerlink" title="BM11 链表相加(二)"></a><strong>BM11</strong> <strong>链表相加(二)</strong></h2><blockquote>
<p>假设链表中每一个节点的值都在 0 - 9 之间，那么链表整体就可以代表一个整数。 </p>
<p>给定两个这种链表，请生成代表两个整数相加值的结果链表。 </p>
<p>数据范围：0≤n,m≤1000000，链表任意值 0≤val≤9<br>要求：空间复杂度 O(n))，时间复杂度 O(n)</p>
<p>例如：链表 1 为 9-&gt;3-&gt;7，链表 2 为 6-&gt;3，最后生成新的结果链表为 1-&gt;0-&gt;0-&gt;0。</p>
</blockquote>
<h3 id="思路：直接模拟"><a href="#思路：直接模拟" class="headerlink" title="思路：直接模拟"></a>思路：直接模拟</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">addInList</span> <span class="params">(ListNode head1, ListNode head2)</span> &#123;</span><br><span class="line">        <span class="comment">// 进行判空处理</span></span><br><span class="line">        <span class="keyword">if</span>(head1 == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head2;</span><br><span class="line">        <span class="keyword">if</span>(head2 == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 反转h1链表</span></span><br><span class="line">        head1 = reverse(head1);</span><br><span class="line">        <span class="comment">// 反转h2链表</span></span><br><span class="line">        head2 = reverse(head2);</span><br><span class="line">        <span class="comment">// 创建新的链表头节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">nHead</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">// 记录进位的数值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head1 != <span class="literal">null</span> || head2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// val用来累加此时的数值（加数+加数+上一位的进位=当前总的数值）</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> tmp;</span><br><span class="line">            <span class="comment">// 当节点不为空的时候，则需要加上当前节点的值</span></span><br><span class="line">            <span class="keyword">if</span> (head1 != <span class="literal">null</span>) &#123;</span><br><span class="line">                val += head1.val;</span><br><span class="line">                head1 = head1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当节点不为空的时候，则需要加上当前节点的值</span></span><br><span class="line">            <span class="keyword">if</span> (head2 != <span class="literal">null</span>) &#123;</span><br><span class="line">                val += head2.val;</span><br><span class="line">                head2 = head2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 求出进位</span></span><br><span class="line">            tmp = val/<span class="number">10</span>;</span><br><span class="line">            <span class="comment">// 进位后剩下的数值即为当前节点的数值</span></span><br><span class="line">            nHead.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(val%<span class="number">10</span>);</span><br><span class="line">            <span class="comment">// 下一个节点</span></span><br><span class="line">            nHead = nHead.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后当两条链表都加完的时候，进位不为0的时候，则需要再加上这个进位</span></span><br><span class="line">        <span class="keyword">if</span>(tmp &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            nHead.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重新反转回来返回</span></span><br><span class="line">        <span class="keyword">return</span> reverse(head.next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反转链表</span></span><br><span class="line">    ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = node;</span><br><span class="line">            node = cur;</span><br><span class="line">            cur = tail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O（N）</li>
<li>空间复杂度：O（1）</li>
</ul>
<h2 id="BM12-单链表的排序"><a href="#BM12-单链表的排序" class="headerlink" title="BM12 单链表的排序"></a><strong>BM12</strong> <strong>单链表的排序</strong></h2><blockquote>
<p>给定一个节点数为n的无序单链表，对其按升序排序。</p>
<p>数据范围：0&lt;n≤100000，保证节点权值在[−109,109][−109,109]之内。</p>
<p>要求：空间复杂度 O(n)，时间复杂度 O(nlogn)</p>
</blockquote>
<h3 id="思路：转化为数组排序"><a href="#思路：转化为数组排序" class="headerlink" title="思路：转化为数组排序"></a>思路：转化为数组排序</h3><p>链表不能按照下表进行访问，因此可以借用数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortInList</span> <span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; nums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>(); </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//遍历链表，将节点值加入数组</span></span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">null</span>)&#123; </span><br><span class="line">            nums.add(p.val);</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = head;</span><br><span class="line">        <span class="comment">//对数组元素排序</span></span><br><span class="line">        Collections.sort(nums); </span><br><span class="line">        <span class="comment">//遍历数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.size(); i++)&#123; </span><br><span class="line">            <span class="comment">//将数组元素依次加入链表</span></span><br><span class="line">            p.val = nums.get(i); </span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(nlog2n)，sort函数一般为优化后的快速排序，复杂度为O(nlog2n)</li>
<li>空间复杂度：O(n)，存储链表元素值的辅助数组长度n</li>
</ul>
<h2 id="BM13-判断一个链表是否为回文结构"><a href="#BM13-判断一个链表是否为回文结构" class="headerlink" title="BM13 判断一个链表是否为回文结构"></a><strong>BM13</strong> <strong>判断一个链表是否为回文结构</strong></h2><blockquote>
<p>给定一个链表，请判断该链表是否为回文结构。</p>
<p>回文是指该字符串正序逆序完全一致。 </p>
<p>数据范围： 链表节点数 0≤n≤1050≤<em>n</em>≤105，链表中每个节点的值满足 ∣val∣≤107∣<em>v<strong>a</strong>l</em>∣≤107</p>
</blockquote>
<h3 id="思路：反转链表逐一判断"><a href="#思路：反转链表逐一判断" class="headerlink" title="思路：反转链表逐一判断"></a>思路：反转链表逐一判断</h3><p>思路很清晰，找到中点，反转后逐一判断，需要注意的是奇数情况要考虑一下～</p>
<ul>
<li>时间复杂度：O（N），遍历链表</li>
<li>空间复杂度：O（1）</li>
</ul>
<p>还有一种更好理解的方法：将链表转化为list来做（只存数据大小），不过这种想法的空间复杂度为O（N）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* public class ListNode &#123;</span></span><br><span class="line"><span class="comment">*   int val;</span></span><br><span class="line"><span class="comment">*   ListNode next = null;</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> head ListNode类 the head</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPail</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">  ListNode q= head, p= head;</span><br><span class="line">  <span class="comment">//通过快慢指针找到中点</span></span><br><span class="line">  <span class="keyword">while</span> (q != <span class="literal">null</span> &amp;&amp; q.next != <span class="literal">null</span>) &#123;</span><br><span class="line">      q = q.next.next;</span><br><span class="line">      p = p.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果q不为空，说明链表的长度是奇数个</span></span><br><span class="line">  <span class="keyword">if</span> (q != <span class="literal">null</span>) &#123;</span><br><span class="line">      p = p.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//反转后半部分链表</span></span><br><span class="line">  p = reverse(p);</span><br><span class="line"></span><br><span class="line">  q = head;</span><br><span class="line">  <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//然后比较，判断节点值是否相等</span></span><br><span class="line">      <span class="keyword">if</span> (q.val != p.val)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      q = q.next;</span><br><span class="line">      p = p.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//反转链表</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">  <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> head.next;</span><br><span class="line">      head.next = prev;</span><br><span class="line">      prev = head;</span><br><span class="line">      head = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM14-链表的奇偶重排"><a href="#BM14-链表的奇偶重排" class="headerlink" title="BM14 链表的奇偶重排"></a><strong>BM14</strong> <strong>链表的奇偶重排</strong></h2><blockquote>
<h2 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h2><p>给定一个单链表，请设定一个函数，将链表的奇数位节点和偶数位节点分别放在一起，重排后输出。 </p>
<p>注意是节点的编号而非节点的数值。 </p>
<p>数据范围：节点数量满足 0≤n≤105，节点中的值都满足 0≤val≤1000</p>
<p>要求：空间复杂度 O(n)，时间复杂度 O(n)</p>
</blockquote>
<h3 id="思路：双指针-1"><a href="#思路：双指针-1" class="headerlink" title="思路：双指针"></a>思路：双指针</h3><p>定义一个双指针，一个指向奇数节点，一个指向偶数节点，遍历操作就好了～</p>
<ul>
<li>时间复杂度：O（N）</li>
<li>空间复杂度：O（1）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">oddEvenList</span> <span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//如果链表为空，不用重排</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) </span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">//even开头指向第二个节点，可能为空</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">even</span> <span class="operator">=</span> head.next; </span><br><span class="line">        <span class="comment">//odd开头指向第一个节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">odd</span> <span class="operator">=</span> head; </span><br><span class="line">        <span class="comment">//指向even开头</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">evenhead</span> <span class="operator">=</span> even; </span><br><span class="line">        <span class="keyword">while</span>(even != <span class="literal">null</span> &amp;&amp; even.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//odd连接even的后一个，即奇数位</span></span><br><span class="line">            odd.next = even.next; </span><br><span class="line">            <span class="comment">//odd进入后一个奇数位</span></span><br><span class="line">            odd = odd.next; </span><br><span class="line">            <span class="comment">//even连接后一个奇数的后一位，即偶数位</span></span><br><span class="line">            even.next = odd.next; </span><br><span class="line">            <span class="comment">//even进入后一个偶数位</span></span><br><span class="line">            even = even.next; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//even整体接在odd后面</span></span><br><span class="line">        odd.next = evenhead; </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM15-删除有序链表中重复的元素-I"><a href="#BM15-删除有序链表中重复的元素-I" class="headerlink" title="BM15 删除有序链表中重复的元素-I"></a><strong>BM15</strong> <strong>删除有序链表中重复的元素-I</strong></h2><blockquote>
<p>删除给出链表中的重复元素（链表中元素从小到大有序），使链表中的所有元素都只出现一次<br>例如：<br>给出的链表为1→1→2,返回1→2.<br>给出的链表为1→1→2→3→3,返回1→2→3 </p>
<p>数据范围：链表长度满足 0≤n≤100，链表中任意节点的值满足 ∣val∣≤100</p>
</blockquote>
<h3 id="思路：遍历"><a href="#思路：遍历" class="headerlink" title="思路：遍历"></a>思路：遍历</h3><p>很容易想到的一个思路，遇到相同的数据，保留第一个遇到的即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span> <span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//空链表</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//遍历指针</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head; </span><br><span class="line">        <span class="comment">//指针当前和下一位不为空</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span> &amp;&amp; cur.next != <span class="literal">null</span>)&#123; </span><br><span class="line">            <span class="comment">//如果当前与下一位相等则忽略下一位</span></span><br><span class="line">            <span class="keyword">if</span>(cur.val == cur.next.val) </span><br><span class="line">                cur.next = cur.next.next;</span><br><span class="line">            <span class="comment">//否则指针正常遍历</span></span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O（N）</li>
<li>空间复杂度：O（1）</li>
</ul>
<h2 id="BM16-删除有序链表中重复的元素-II"><a href="#BM16-删除有序链表中重复的元素-II" class="headerlink" title="BM16 删除有序链表中重复的元素-II"></a><strong>BM16</strong> <strong>删除有序链表中重复的元素-II</strong></h2><blockquote>
<p>给出一个升序排序的链表，删除链表中的<strong>所有</strong>重复出现的元素，只保留原链表中只出现一次的元素。<br>例如：<br>给出的链表为1→2→3→3→4→4→5, 返回1→2→5.<br>给出的链表为1→1→1→2→3, 返回2→3. </p>
<p>数据范围：链表长度 0≤n≤100000≤<em>n</em>≤10000，链表中的值满足 ∣val∣≤1000∣<em>v<strong>a</strong>l</em>∣≤1000</p>
<p>要求：空间复杂度 O(n)，时间复杂度 O(n)</p>
<p>进阶：空间复杂度 O(1)，时间复杂度 O(n)</p>
</blockquote>
<h3 id="思路：遍历-1"><a href="#思路：遍历-1" class="headerlink" title="思路：遍历"></a>思路：遍历</h3><p>注意，这个题和前面一题的不同之处在于：删除<span style='color:red'>所有的</span>相同元素</p>
<p>大部分逻辑和前面一个题一样～</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span> <span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//空链表</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//在链表前加一个表头</span></span><br><span class="line">        res.next = head; </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> res;</span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="literal">null</span> &amp;&amp; cur.next.next != <span class="literal">null</span>)&#123; </span><br><span class="line">            <span class="comment">//遇到相邻两个节点值相同</span></span><br><span class="line">            <span class="keyword">if</span>(cur.next.val == cur.next.next.val)&#123; </span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next.val;</span><br><span class="line">                <span class="comment">//将所有相同的都跳过</span></span><br><span class="line">                <span class="keyword">while</span> (cur.next != <span class="literal">null</span> &amp;&amp; cur.next.val == temp) </span><br><span class="line">                    cur.next = cur.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回时去掉表头</span></span><br><span class="line">        <span class="keyword">return</span> res.next; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O（N）</li>
<li>空间复杂度：O（1）</li>
</ul>
<h1 id="二、二分查找"><a href="#二、二分查找" class="headerlink" title="二、二分查找"></a>二、二分查找</h1><h2 id="BM17-二分查找-I"><a href="#BM17-二分查找-I" class="headerlink" title="BM17 二分查找-I"></a><strong>BM17</strong> <strong>二分查找-I</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span> <span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span> , right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM18-二维数组中的查找"><a href="#BM18-二维数组中的查找" class="headerlink" title="BM18 二维数组中的查找"></a><strong>BM18</strong> <strong>二维数组中的查找</strong></h2><blockquote>
<p>在一个二维数组array中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 </p>
<p>[ </p>
<p>[1,2,8,9],<br>[2,4,9,12],<br>[4,7,10,13],<br>[6,8,11,15]</p>
<p>] </p>
<p>给定 target &#x3D; 7，返回 true。 </p>
<p>给定 target &#x3D; 3，返回 false。 </p>
<p>数据范围：矩阵的长宽满足 0≤n,m≤500 ， 矩阵中的值满足 0≤val≤109<br>进阶：空间复杂度 O(1) ，时间复杂度 O(n+m)</p>
</blockquote>
<h3 id="思路：二分查找"><a href="#思路：二分查找" class="headerlink" title="思路：二分查找"></a>思路：二分查找</h3><p>首先看四个角，左上与右下必定为最小值与最大值，而左下与右上就有规律了：<strong>左下元素大于它上方的元素，小于它右方的元素，右上元素与之相反</strong>。既然左下角元素有这么一种规律，相当于将要查找的部分分成了一个大区间和小区间，每次与左下角元素比较，我们就知道目标值应该在哪部分中，于是可以利用分治思维来做。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">Find</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span> [][] array)</span> &#123;</span><br><span class="line">        <span class="comment">//优先判断特殊</span></span><br><span class="line">        <span class="keyword">if</span>(array.length == <span class="number">0</span>)  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> array.length;</span><br><span class="line">        <span class="keyword">if</span>(array[<span class="number">0</span>].length == <span class="number">0</span>)  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> array[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">//从最左下角的元素开始往左或往上</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>, j = <span class="number">0</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; m; )&#123; </span><br><span class="line">            <span class="comment">//元素较大，往上走</span></span><br><span class="line">            <span class="keyword">if</span>(array[i][j] &gt; target)   </span><br><span class="line">                i--;</span><br><span class="line">            <span class="comment">//元素较小，往右走</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(array[i][j] &lt; target) </span><br><span class="line">                j++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(m+n)，遍历矩阵的时候，最多经过矩阵的一行一列</li>
<li>空间复杂度：O(1)，常数级变量，无额外辅助空间</li>
</ul>
<h2 id="BM19-寻找峰值"><a href="#BM19-寻找峰值" class="headerlink" title="BM19 寻找峰值"></a><strong>BM19</strong> <strong>寻找峰值</strong></h2><blockquote>
<p>给定一个长度为n的数组nums，请你找到峰值并返回其索引。数组可能包含多个峰值，在这种情况下，返回任何一个所在位置即可。 </p>
<p>1.峰值元素是指其值严格大于左右相邻值的元素。严格大于即不能有等于</p>
<p>2.假设 nums[-1] &#x3D; nums[n] &#x3D; −∞−∞</p>
<p>3.对于所有有效的 i 都有 nums[i] !&#x3D; nums[i + 1] </p>
<p>4.你可以使用O(logN)的时间复杂度实现此问题吗？</p>
</blockquote>
<p><img src="https://picgooo.oss-cn-hangzhou.aliyuncs.com/img/9EB9CD58B9EA5E04C890326B5C1F471F.png"></p>
<h3 id="思路：二分查找-1"><a href="#思路：二分查找-1" class="headerlink" title="思路：二分查找"></a>思路：二分查找</h3><ul>
<li>nums[mid] &lt; nums[mid + 1]说明在“上坡”，则可以使left &#x3D; mid + 1（因为mid肯定不是峰值），向“峰”处压缩</li>
<li>nums[mid] &gt; nums[mid + 1]说明在“下坡”，则应该使right &#x3D; mid（mid可能是峰值），往“峰”处压缩</li>
</ul>
<p>虽然开始left和right之间可能有多个峰值，但是随着left和right不断逼近，最后两者之间一定会压缩到一个峰值上，因为两者都是向“峰”不断靠近的，但是不会超过<code>最终</code>的“峰”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findPeakElement</span> <span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//二分法</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123; </span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//右边是往上，一定有坡峰</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[mid + <span class="number">1</span>])</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//左边是往上，一定能找到波峰</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//其中一个波峰</span></span><br><span class="line">        <span class="keyword">return</span> right; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM20-数组中的逆序对"><a href="#BM20-数组中的逆序对" class="headerlink" title="BM20 数组中的逆序对"></a><strong>BM20</strong> <strong>数组中的逆序对</strong></h2><blockquote>
<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P mod 1000000007</p>
<p>要求：空间复杂度 O(n)，时间复杂度 O(nlogn)</p>
</blockquote>
<h3 id="思路：归并排序"><a href="#思路：归并排序" class="headerlink" title="思路：归并排序"></a>思路：归并排序</h3><p>归并排序」与「逆序对」是息息相关的。归并排序体现了 “分而治之” 的算法思想，具体为：</p>
<ul>
<li>分： 不断将数组从中点位置划分开（即二分法），将整个数组的排序问题转化为子数组的排序问题；</li>
<li>治： 划分到子数组长度为 1 时，开始向上合并，不断将 较短排序数组 合并为 较长排序数组，直至合并至原数组时完成排序；</li>
</ul>
<p><img src="https://pic.leetcode-cn.com/1614274007-rtFHbG-Picture2.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">InversePairs</span><span class="params">(<span class="type">int</span> [] array)</span> &#123;</span><br><span class="line">        <span class="comment">// 长度小于2则无逆序对</span></span><br><span class="line">        <span class="keyword">if</span>(array.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 进入归并</span></span><br><span class="line">        mergeSort(array,<span class="number">0</span>,array.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] array,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="comment">// 找分割点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="comment">// 左子数组</span></span><br><span class="line">            mergeSort(array,left,mid);</span><br><span class="line">            <span class="comment">// 右子数组</span></span><br><span class="line">            mergeSort(array,mid+<span class="number">1</span>,right);</span><br><span class="line">            <span class="comment">// 并</span></span><br><span class="line">            merge(array,left,mid,right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] array,<span class="type">int</span> left,<span class="type">int</span> mid,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="comment">// 创建临时数组，长度为此时两个子数组加起来的长度</span></span><br><span class="line">        <span class="type">int</span>[] arr =  <span class="keyword">new</span> <span class="title class_">int</span>[right-left+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 临时数组的下标起点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 保存在原数组的起点下标值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="comment">// 左子数组的起始指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="comment">// 右子数组的起始指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= mid &amp;&amp; r &lt;= right )&#123;</span><br><span class="line">            <span class="comment">// 当左子数组的当前元素小的时候，跳过，无逆序对</span></span><br><span class="line">            <span class="keyword">if</span>(array[l] &lt;= array[r])&#123;</span><br><span class="line">                <span class="comment">// 放入临时数组</span></span><br><span class="line">                arr[c] = array[l];</span><br><span class="line">                <span class="comment">// 临时数组下标+1</span></span><br><span class="line">                c++;</span><br><span class="line">                <span class="comment">// 左子数组指针右移</span></span><br><span class="line">                l++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">// 否则，此时存在逆序对</span></span><br><span class="line">                <span class="comment">// 放入临时数组</span></span><br><span class="line">                arr[c] = array[r];</span><br><span class="line">                <span class="comment">// 逆序对的个数为    左子数组的终点- 当前左子数组的当前指针</span></span><br><span class="line">                count += mid+<span class="number">1</span>-l;</span><br><span class="line">                count %= <span class="number">1000000007</span>;</span><br><span class="line">                <span class="comment">// 临时数组+1</span></span><br><span class="line">                c++;</span><br><span class="line">                <span class="comment">// 右子数组的指针右移</span></span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左子数组还有元素时，全部放入临时数组</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt;= mid)</span><br><span class="line">            arr[c++] = array[l++];</span><br><span class="line">        <span class="comment">// 右子数组还有元素时，全部放入临时数组</span></span><br><span class="line">        <span class="keyword">while</span>(r &lt;= right)</span><br><span class="line">            arr[c++] = array[r++];</span><br><span class="line">        <span class="comment">// 将临时数组中的元素放入到原数组的指定位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:arr)&#123;</span><br><span class="line">            array[s++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(NlogN)。归并排序的时间复杂度</li>
<li>空间复杂度：O(N)。临时数组的空间。</li>
</ul>
<h2 id="BM21-旋转数组的最小数字"><a href="#BM21-旋转数组的最小数字" class="headerlink" title="BM21 旋转数组的最小数字"></a><strong>BM21</strong> <strong>旋转数组的最小数字</strong></h2><blockquote>
<p>有一个长度为 n 的非降序数组，比如[1,2,3,4,5]，将它进行旋转，即把一个数组最开始的若干个元素搬到数组的末尾，变成一个旋转数组，比如变成了[3,4,5,1,2]，或者[4,5,1,2,3]这样的。请问，给定这样一个旋转数组，求数组中的最小值。</p>
<p>数据范围：1≤n≤10000，数组中任意元素的值: 0≤val≤10000</p>
<p>要求：空间复杂度：O(1) ，时间复杂度：O(logn)</p>
</blockquote>
<h3 id="思路：二分查找-2"><a href="#思路：二分查找-2" class="headerlink" title="思路：二分查找"></a>思路：二分查找</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minNumberInRotateArray</span><span class="params">(<span class="type">int</span> [] array)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//最小的数字在mid右边</span></span><br><span class="line">            <span class="keyword">if</span>(array[mid] &gt; array[right]) </span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//无法判断，一个一个试</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(array[mid] == array[right]) </span><br><span class="line">                right--;</span><br><span class="line">            <span class="comment">//最小数字要么是mid要么在mid左边</span></span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM22-比较版本号"><a href="#BM22-比较版本号" class="headerlink" title="BM22 比较版本号"></a><strong>BM22</strong> <strong>比较版本号</strong></h2><blockquote>
<p>牛客项目发布项目版本时会有版本号，比如1.02.11，2.14.4等等 </p>
<p>现在给你2个版本号version1和version2，请你比较他们的大小</p>
<p>版本号是由修订号组成，修订号与修订号之间由一个”.”连接。1个修订号可能有多位数字组成，修订号可能包含前导0，且是合法的。例如，1.02.11，0.1，0.2都是合法的版本号</p>
<p>每个版本号至少包含1个修订号。 </p>
<p>修订号从左到右编号，下标从0开始，最左边的修订号下标为0，下一个修订号下标为1，以此类推。 </p>
<p>比较规则： </p>
<p>一. 比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较忽略任何前导零后的整数值。比如”0.1”和”0.01”的版本号是相等的 </p>
<p>二. 如果版本号没有指定某个下标处的修订号，则该修订号视为0。例如，”1.1”的版本号小于”1.1.1”。因为”1.1”的版本号相当于”1.1.0”，第3位修订号的下标为0，小于1 </p>
<p>三. version1 &gt; version2 返回1，如果 version1 &lt; version2 返回-1，不然返回0.</p>
</blockquote>
<h3 id="思路：双指针-2"><a href="#思路：双指针-2" class="headerlink" title="思路：双指针"></a>思路：双指针</h3><ul>
<li>step 1：利用两个指针表示字符串的下标，分别遍历两个字符串。</li>
<li>step 2：每次截取点之前的数字字符组成数字，即在遇到一个点之前，直接取数字，加在前面数字乘10的后面。（因为int会溢出，这里采用long记录数字）</li>
<li>step 3：然后比较两个数字大小，根据大小关系返回1或者-1，如果全部比较完都无法比较出大小关系，则返回0.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span> <span class="params">(String version1, String version2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> version1.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> version2.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//直到某个字符串结束</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; n1 || j &lt; n2)&#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//从下一个点前截取数字</span></span><br><span class="line">            <span class="keyword">while</span>(i &lt; n1 &amp;&amp; version1.charAt(i) != <span class="string">&#x27;.&#x27;</span>)&#123; </span><br><span class="line">                num1 = num1 * <span class="number">10</span> + (version1.charAt(i) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//跳过点</span></span><br><span class="line">            i++; </span><br><span class="line">            <span class="type">long</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//从下一个点前截取数字</span></span><br><span class="line">            <span class="keyword">while</span>(j &lt; n2 &amp;&amp; version2.charAt(j) != <span class="string">&#x27;.&#x27;</span>)&#123; </span><br><span class="line">                num2 = num2 * <span class="number">10</span> + (version2.charAt(j) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//跳过点</span></span><br><span class="line">            j++; </span><br><span class="line">            <span class="comment">//比较数字大小</span></span><br><span class="line">            <span class="keyword">if</span>(num1 &gt; num2) </span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(num1 &lt; num2)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//版本号相同</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(max(n,m))，其中m和n分别为两个字符串的长度，遍历两个字符串，复杂度选取较高值</li>
<li>空间复杂度：O(1)，常数级变量，无额外辅助空间</li>
</ul>
<h1 id="三、二叉树"><a href="#三、二叉树" class="headerlink" title="三、二叉树"></a>三、二叉树</h1><h2 id="BM23-二叉树的前序遍历"><a href="#BM23-二叉树的前序遍历" class="headerlink" title="BM23 二叉树的前序遍历"></a><strong>BM23</strong> <strong>二叉树的前序遍历</strong></h2><blockquote>
<p>给你二叉树的根节点 root ，返回它节点值的 前序 遍历。</p>
<p>数据范围：二叉树的节点数量满足 1≤n≤100 1≤<em>n</em>≤100 ，二叉树节点的值满足 1≤val≤100 1≤<em>v<strong>a</strong>l</em>≤100 ，树的各节点的值各不相同</p>
</blockquote>
<h3 id="思路：递归-2"><a href="#思路：递归-2" class="headerlink" title="思路：递归"></a>思路：递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        preorder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        preorder(root.left, res);</span><br><span class="line">        preorder(root.right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM24-二叉树的中序遍历"><a href="#BM24-二叉树的中序遍历" class="headerlink" title="BM24 二叉树的中序遍历"></a><strong>BM24</strong> <strong>二叉树的中序遍历</strong></h2><h2 id="BM25-二叉树的后序遍历"><a href="#BM25-二叉树的后序遍历" class="headerlink" title="BM25 二叉树的后序遍历"></a><strong>BM25</strong> <strong>二叉树的后序遍历</strong></h2><p>这几个题就不记录了，套板子就行～</p>
<h2 id="BM26-求二叉树的层序遍历"><a href="#BM26-求二叉树的层序遍历" class="headerlink" title="BM26 求二叉树的层序遍历"></a><strong>BM26</strong> <strong>求二叉树的层序遍历</strong></h2><h3 id="思路：BFS（广度优先搜索）"><a href="#思路：BFS（广度优先搜索）" class="headerlink" title="思路：BFS（广度优先搜索）"></a>思路：BFS（广度优先搜索）</h3><blockquote>
<p>DFS（深度优先搜索）和 BFS（广度优先搜索）就像孪生兄弟，提到一个总是想起另一个。然而在实际使用中，我们用 DFS 的时候远远多于 BFS。那么，是不是 BFS 就没有什么用呢？</p>
<p>如果我们使用 DFS&#x2F;BFS 只是为了遍历一棵树、一张图上的所有结点的话，那么 DFS 和 BFS 的能力没什么差别，我们当然更倾向于更方便写、空间复杂度更低的 DFS 遍历。不过，某些使用场景是 DFS 做不到的，只能使用 BFS 遍历。这就是本文要介绍的两个场景：「层序遍历」、「最短路径」</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">currentLevelSize</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= currentLevelSize; ++i) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                level.add(node.val);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ret.add(level);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：每个点进队出队各一次，故渐进时间复杂度为 O(n)。</li>
<li>空间复杂度：队列中元素的个数不超过 n 个，故渐进空间复杂度为 O(n)。</li>
</ul>
<p>可以适当记一下这个模版～理解起来就比较好记了，<span style='color:orange'>核心是利用队列的思想。</span></p>
<h2 id="BM27-按之字形顺序打印二叉树"><a href="#BM27-按之字形顺序打印二叉树" class="headerlink" title="BM27 按之字形顺序打印二叉树"></a><strong>BM27</strong> <strong>按之字形顺序打印二叉树</strong></h2><blockquote>
<p>给定一个二叉树，返回该二叉树的之字形层序遍历，（第一层从左向右，下一层从右向左，一直这样交替） </p>
<p>数据范围：0≤n≤1500,树上每个节点的val满足 ∣val∣&lt;&#x3D;1500<br>要求：空间复杂度：O(n)，时间复杂度：O(n)</p>
</blockquote>
<h2 id="思路：BFS"><a href="#思路：BFS" class="headerlink" title="思路：BFS"></a>思路：BFS</h2><p>和前面层序遍历一样，只不过需要加一个flag来判断是否当前层该逆序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">head</span> <span class="operator">=</span> pRoot;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt; &gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">//如果是空，则直接返回空list</span></span><br><span class="line">            <span class="keyword">return</span> res; </span><br><span class="line">        <span class="comment">//队列存储，进行层次遍历</span></span><br><span class="line">        Queue&lt;TreeNode&gt; temp = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;(); </span><br><span class="line">        temp.offer(head);</span><br><span class="line">        TreeNode p;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!temp.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//记录二叉树的某一行</span></span><br><span class="line">            ArrayList&lt;Integer&gt; row = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();  </span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> temp.size();</span><br><span class="line">            <span class="comment">//奇数行反转，偶数行不反转</span></span><br><span class="line">            flag = !flag; </span><br><span class="line">            <span class="comment">//因先进入的是根节点，故每层节点多少，队列大小就是多少</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                p = temp.poll();</span><br><span class="line">                row.add(p.val);</span><br><span class="line">                <span class="comment">//若是左右孩子存在，则存入左右孩子作为下一个层次</span></span><br><span class="line">                <span class="keyword">if</span>(p.left != <span class="literal">null</span>)</span><br><span class="line">                    temp.offer(p.left);</span><br><span class="line">                <span class="keyword">if</span>(p.right != <span class="literal">null</span>)</span><br><span class="line">                    temp.offer(p.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//奇数行反转，偶数行不反转</span></span><br><span class="line">            <span class="keyword">if</span>(flag)  </span><br><span class="line">                Collections.reverse(row);</span><br><span class="line">            res.add(row);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，每个节点访问一次，因为reverse的时间复杂度为O(n)，按每层元素reverse也相当于O(n)</li>
<li>空间复杂度：O(n)，队列的空间最长为O(n)</li>
</ul>
<h2 id="BM28-二叉树的最大深度"><a href="#BM28-二叉树的最大深度" class="headerlink" title="BM28 二叉树的最大深度"></a><strong>BM28</strong> <strong>二叉树的最大深度</strong></h2><h3 id="思路：递归-3"><a href="#思路：递归-3" class="headerlink" title="思路：递归"></a>思路：递归</h3><p>思路很简单，直接递归就好～</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span> <span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//空节点没有深度</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//返回子树深度+1</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="BM29-二叉树中和为某一值的路径-一"><a href="#BM29-二叉树中和为某一值的路径-一" class="headerlink" title="BM29 二叉树中和为某一值的路径(一)"></a><strong>BM29</strong> <strong>二叉树中和为某一值的路径(一)</strong></h2><blockquote>
<p>给定一个二叉树root和一个值 sum ，判断是否有从根节点到叶子节点的节点值之和等于 sum 的路径。</p>
<p>1.该题路径定义为从树的根结点开始往下一直到叶子结点所经过的结点</p>
<p>2.叶子节点是指没有子节点的节点</p>
<p>3.路径只能从父节点到子节点，不能从子节点到父节点</p>
<p>4.总节点数目为n</p>
</blockquote>
<h3 id="思路：递归-4"><a href="#思路：递归-4" class="headerlink" title="思路：递归"></a>思路：递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span> <span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="comment">//空节点找不到路径</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//叶子节点，且路径和为sum</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span> &amp;&amp; sum - root.val == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//递归进入子节点</span></span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM30-二叉搜索树与双向链表"><a href="#BM30-二叉搜索树与双向链表" class="headerlink" title="BM30 二叉搜索树与双向链表"></a><strong>BM30</strong> <strong>二叉搜索树与双向链表</strong></h2><blockquote>
<p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。如下图所示</p>
</blockquote>
<p><img src="https://picgooo.oss-cn-hangzhou.aliyuncs.com/img/E1F1270919D292C9F48F51975FD07CE2.png"></p>
<h3 id="思路：利用二叉搜索树的特征进行递归"><a href="#思路：利用二叉搜索树的特征进行递归" class="headerlink" title="思路：利用二叉搜索树的特征进行递归"></a>思路：利用二叉搜索树的特征进行递归</h3><p>核心：二叉搜索树最左端的元素一定最小，最右端的元素一定最大，符合“左中右”的特性，因此二叉搜索树的中序遍历就是一个递增序列，我们只要对它中序遍历就可以组装称为递增双向链表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//返回的第一个指针，即为最小值，先定为null</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">TreeNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">    <span class="comment">//中序遍历当前值的上一位，初值为最小值，先定为null</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;   </span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">Convert</span><span class="params">(TreeNode pRootOfTree)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">//中序递归，叶子为空则返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;     </span><br><span class="line">        <span class="comment">//首先递归到最左最小值  </span></span><br><span class="line">        Convert(pRootOfTree.left); </span><br><span class="line">        <span class="comment">//找到最小值，初始化head与pre</span></span><br><span class="line">        <span class="keyword">if</span>(pre == <span class="literal">null</span>)&#123;       </span><br><span class="line">            head = pRootOfTree;</span><br><span class="line">            pre = pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前节点与上一节点建立连接，将pre设置为当前值</span></span><br><span class="line">        <span class="keyword">else</span>&#123;       </span><br><span class="line">            pre.right = pRootOfTree;</span><br><span class="line">            pRootOfTree.left = pre;</span><br><span class="line">            pre = pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        Convert(pRootOfTree.right);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，其中n<em>n</em>为二叉树节点数，中序遍历所有节点</li>
<li>空间复杂度：O(n)，递归栈所需要的最大空间</li>
</ul>
<h2 id="BM31-对称的二叉树"><a href="#BM31-对称的二叉树" class="headerlink" title="BM31 对称的二叉树"></a><strong>BM31</strong> <strong>对称的二叉树</strong></h2><blockquote>
<p>给定一棵二叉树，判断其是否是自身的镜像（即：是否对称）<br>例如：                 下面这棵二叉树是对称的</p>
</blockquote>
<p><img src="https://picgooo.oss-cn-hangzhou.aliyuncs.com/img/A22A794C036C06431E632F9D5E2E298F.png"></p>
<h3 id="思路：递归-5"><a href="#思路：递归-5" class="headerlink" title="思路：递归"></a>思路：递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isSymmetrical</span><span class="params">(TreeNode pRoot)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> compare(pRoot.left,pRoot.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(TreeNode left, TreeNode right)</span>&#123;</span><br><span class="line">      <span class="comment">//可以两个都为空</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>)   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       <span class="comment">//只有一个为空或者节点值不同，必定不对称</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span> || right == <span class="literal">null</span> || left.val != right.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="comment">//每层对应的节点进入递归比较</span></span><br><span class="line">        <span class="keyword">return</span> compare(left.left,right.right)&amp;&amp;compare(left.right,right.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，其中n<em>n</em>为二叉树的节点数，相当于遍历整个二叉树两次</li>
<li>空间复杂度：O(n)，最坏情况二叉树退化为链表，递归栈深度为n<em>n</em></li>
</ul>
<h2 id="BM32-合并二叉树"><a href="#BM32-合并二叉树" class="headerlink" title="BM32 合并二叉树"></a><strong>BM32</strong> <strong>合并二叉树</strong></h2><blockquote>
<p>已知两颗二叉树，将它们合并成一颗二叉树。合并规则是：都存在的结点，就将结点值加起来，否则空的位置就由另一个树的结点来代替。例如：</p>
</blockquote>
<h3 id="思路：递归-6"><a href="#思路：递归-6" class="headerlink" title="思路：递归"></a>思路：递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span> <span class="params">(TreeNode t1, TreeNode t2)</span> &#123;</span><br><span class="line">        <span class="comment">//若只有一个节点返回另一个，两个都为null自然返回null</span></span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">null</span>) </span><br><span class="line">            <span class="keyword">return</span> t2;</span><br><span class="line">        <span class="keyword">if</span> (t2 == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> t1;</span><br><span class="line">        <span class="comment">//根左右的方式递归</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(t1.val + t2.val);</span><br><span class="line">        head.left = mergeTrees(t1.left, t2.left);</span><br><span class="line">        head.right = mergeTrees(t1.right, t2.right);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="BM33-二叉树的镜像"><a href="#BM33-二叉树的镜像" class="headerlink" title="BM33 二叉树的镜像"></a><strong>BM33</strong> <strong>二叉树的镜像</strong></h2><blockquote>
<p>操作给定的二叉树，将其变换为源二叉树的镜像。 </p>
<p>数据范围：二叉树的节点数 0≤n≤1000， 二叉树每个节点的值 0≤val≤1000</p>
<p>要求： 空间复杂度 O(n)。本题也有原地操作，即空间复杂度 O(1)的解法，时间复杂度 O(n)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">Mirror</span> <span class="params">(TreeNode pRoot)</span> &#123;</span><br><span class="line">        <span class="comment">//空树返回</span></span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//先递归子树</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> Mirror(pRoot.left);  </span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> Mirror(pRoot.right);</span><br><span class="line">        <span class="comment">//交换</span></span><br><span class="line">        pRoot.left = right; </span><br><span class="line">        pRoot.right = left;</span><br><span class="line">        <span class="keyword">return</span> pRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM34-判断是不是二叉搜索树"><a href="#BM34-判断是不是二叉搜索树" class="headerlink" title="BM34 判断是不是二叉搜索树"></a><strong>BM34</strong> <strong>判断是不是二叉搜索树</strong></h2><blockquote>
<p>给定一个二叉树根节点，请你判断这棵树是不是二叉搜索树。 </p>
<p>二叉搜索树满足每个节点的左子树上的所有节点均小于当前节点且右子树上的所有节点均大于当前节点。 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span> <span class="params">(TreeNode root)</span> &#123; </span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//先进入左子树</span></span><br><span class="line">        <span class="keyword">if</span>(!isValidBST(root.left)) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; pre)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//更新最值</span></span><br><span class="line">        pre = root.val;</span><br><span class="line">        <span class="comment">//再进入右子树</span></span><br><span class="line">        <span class="keyword">return</span> isValidBST(root.right); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM35-判断是不是完全二叉树"><a href="#BM35-判断是不是完全二叉树" class="headerlink" title="BM35 判断是不是完全二叉树"></a><strong>BM35</strong> <strong>判断是不是完全二叉树</strong></h2><blockquote>
<p>给定一个二叉树，确定他是否是一个完全二叉树。 </p>
<p>完全二叉树的定义：若二叉树的深度为 h，除第 h 层外，其它各层的结点数都达到最大个数，第 h 层所有的叶子结点都连续集中在最左边，这就是完全二叉树。（第 h 层可能包含 [1~2h] 个节点）</p>
</blockquote>
<h3 id="思路：层序遍历BFS"><a href="#思路：层序遍历BFS" class="headerlink" title="思路：层序遍历BFS"></a>思路：层序遍历BFS</h3><p>对完全二叉树最重要的定义就是叶子节点只能出现在最下层和次下层，所以我们想到可以使用队列辅助进行层次遍历——从上到下遍历所有层，每层从左到右，只有次下层和最下层才有叶子节点，其他层出现叶子节点就意味着不是完全二叉树。</p>
<ul>
<li>step 1：先判断空树一定是完全二叉树。</li>
<li>step 2：初始化一个队列辅助层次遍历，将根节点加入。</li>
<li>step 3：逐渐从队列中弹出元素访问节点，如果遇到某个节点为空，进行标记，代表到了完全二叉树的最下层，若是后续还有访问，则说明提前出现了叶子节点，不符合完全二叉树的性质。</li>
<li>step 4：否则，继续加入左右子节点进入队列排队，等待访问。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCompleteTree</span> <span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//空树一定是完全二叉树</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//辅助队列</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(); </span><br><span class="line">        queue.offer(root);</span><br><span class="line">        TreeNode cur;</span><br><span class="line">        <span class="comment">//定义一个首次出现的标记位</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">notComplete</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            cur = queue.poll();</span><br><span class="line">            <span class="comment">//标记第一次遇到空节点</span></span><br><span class="line">            <span class="keyword">if</span>(cur == <span class="literal">null</span>)&#123; </span><br><span class="line">                notComplete = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//后续访问已经遇到空节点了，说明经过了叶子</span></span><br><span class="line">            <span class="keyword">if</span>(notComplete) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            queue.offer(cur.left);</span><br><span class="line">            queue.offer(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，其中n<em>n</em>为二叉树节点数，层次遍历最坏情况下遍历每一个节点</li>
<li>空间复杂度：O(n)，最坏情况下，层次队列的最大空间为O(n)</li>
</ul>
<h2 id="BM36-判断是不是平衡二叉树"><a href="#BM36-判断是不是平衡二叉树" class="headerlink" title="BM36 判断是不是平衡二叉树"></a><strong>BM36</strong> <strong>判断是不是平衡二叉树</strong></h2><blockquote>
<p>输入一棵节点数为 n 二叉树，判断该二叉树是否是平衡二叉树。 </p>
<p>在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树 </p>
<p><strong>平衡二叉树</strong>（Balanced Binary Tree），具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p>
</blockquote>
<h3 id="思路：从底至顶"><a href="#思路：从底至顶" class="headerlink" title="思路：从底至顶"></a>思路：从底至顶</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> recur(root) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">recur</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> recur(root.left);</span><br><span class="line">        <span class="keyword">if</span>(left == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> recur(root.right);</span><br><span class="line">        <span class="keyword">if</span>(right == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(left - right) &lt; <span class="number">2</span> ? Math.max(left, right) + <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM37-二叉搜索树的最近公共祖先"><a href="#BM37-二叉搜索树的最近公共祖先" class="headerlink" title="BM37 二叉搜索树的最近公共祖先"></a><strong>BM37</strong> <strong>二叉搜索树的最近公共祖先</strong></h2><blockquote>
<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>1.对于该题的最近的公共祖先定义:对于有根树T的两个节点p、q，最近公共祖先LCA(T,p,q)表示一个节点x，满足x是p和q的祖先且x的深度尽可能大。在这里，一个节点也可以是它自己的祖先.</p>
<p>2.二叉搜索树是若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值</p>
<p>3.所有节点的值都是唯一的。</p>
<p>4.p、q 为不同节点且均存在于给定的二叉搜索树中。</p>
</blockquote>
<h3 id="思路：遍历-2"><a href="#思路：遍历-2" class="headerlink" title="思路：遍历"></a>思路：遍历</h3><ul>
<li>step 1：根据二叉搜索树的性质，从根节点开始查找目标节点，当前节点比目标小则进入右子树，当前节点比目标大则进入左子树，直到找到目标节点。这个过程成用数组记录遇到的元素。</li>
<li>step 2：分别在搜索二叉树中找到p和q两个点，并记录各自的路径为数组。</li>
<li>step 3：同时遍历两个数组，比较元素值，最后一个相等的元素就是最近的公共祖先。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//求得根节点到目标节点的路径</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title function_">getPath</span><span class="params">(TreeNode root, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="comment">//节点值都不同，可以直接用值比较</span></span><br><span class="line">        <span class="keyword">while</span>(node.val != target)&#123; </span><br><span class="line">            path.add(node.val);</span><br><span class="line">            <span class="comment">//小的在左子树</span></span><br><span class="line">            <span class="keyword">if</span>(target &lt; node.val) </span><br><span class="line">                node = node.left;</span><br><span class="line">            <span class="comment">//大的在右子树</span></span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        path.add(node.val);</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lowestCommonAncestor</span> <span class="params">(TreeNode root, <span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">        <span class="comment">//求根节点到两个节点的路径</span></span><br><span class="line">        ArrayList&lt;Integer&gt; path_p = getPath(root, p); </span><br><span class="line">        ArrayList&lt;Integer&gt; path_q = getPath(root, q);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//比较两个路径，找到第一个不同的点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; path_p.size() &amp;&amp; i &lt; path_q.size(); i++)&#123; </span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> path_p.get(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> path_q.get(i);</span><br><span class="line">            <span class="comment">//最后一个相同的节点就是最近公共祖先</span></span><br><span class="line">            <span class="keyword">if</span>(x == y) </span><br><span class="line">                res = path_p.get(i);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，设二叉树共有n<em>n</em>个节点，因此最坏情况二叉搜索树变成链表，搜索到目标节点需要O(n)<em>O</em>(<em>n</em>)，比较路径前半段的相同也需要O(n)</li>
<li>空间复杂度：O(n)，记录路径的数组最长为n</li>
</ul>
<h2 id="BM38-在二叉树中找到两个节点的最近公共祖先"><a href="#BM38-在二叉树中找到两个节点的最近公共祖先" class="headerlink" title="BM38 在二叉树中找到两个节点的最近公共祖先"></a><span style='color:orange'><strong>BM38</strong> <strong>在二叉树中找到两个节点的最近公共祖先</strong></span></h2><blockquote>
<p>给定一棵二叉树(保证非空)以及这棵树上的两个节点对应的val值 o1 和 o2，请找到 o1 和 o2 的最近公共祖先节点。 </p>
<p>数据范围：树上节点数满足 1≤n≤105 , 节点值val满足区间 [0,n)</p>
<p>要求：时间复杂度 O(n)</p>
</blockquote>
<h3 id="思路：回溯-DFS"><a href="#思路：回溯-DFS" class="headerlink" title="思路：回溯+DFS"></a>思路：回溯+DFS</h3><ul>
<li>step 1：利用dfs求得根节点到两个目标节点的路径：每次选择二叉树的一棵子树往下找，同时路径数组增加这个遍历的节点值。</li>
<li>step 2：一旦遍历到了叶子节点也没有，则回溯到父节点，寻找其他路径，回溯时要去掉数组中刚刚加入的元素。</li>
<li>step 3：然后遍历两条路径数组，依次比较元素值。</li>
<li>step 4：找到两条路径第一个不相同的节点即是最近公共祖先。</li>
</ul>
<p><img src="https://picgooo.oss-cn-hangzhou.aliyuncs.com/img/63C9C80875EEB9DD09F51096A6752306.gif"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//记录是否找到到o的路径</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>; </span><br><span class="line">    <span class="comment">//求得根节点到目标节点的路径</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; path, <span class="type">int</span> o)</span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(flag || root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        path.add(root.val);</span><br><span class="line">        <span class="comment">//节点值都不同，可以直接用值比较</span></span><br><span class="line">        <span class="keyword">if</span>(root.val == o)&#123; </span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//dfs遍历查找</span></span><br><span class="line">        dfs(root.left, path, o); </span><br><span class="line">        dfs(root.right, path, o);</span><br><span class="line">        <span class="comment">//找到</span></span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//回溯</span></span><br><span class="line">        path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lowestCommonAncestor</span> <span class="params">(TreeNode root, <span class="type">int</span> o1, <span class="type">int</span> o2)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; path1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(); </span><br><span class="line">        ArrayList&lt;Integer&gt; path2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(); </span><br><span class="line">        <span class="comment">//求根节点到两个节点的路径</span></span><br><span class="line">        dfs(root, path1, o1); </span><br><span class="line">        <span class="comment">//重置flag，查找下一个</span></span><br><span class="line">        flag = <span class="literal">false</span>; </span><br><span class="line">        dfs(root, path2, o2);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">        <span class="comment">//比较两个路径，找到第一个不同的点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; path1.size() &amp;&amp; i &lt; path2.size(); i++)&#123; </span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> path1.get(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> path2.get(i);</span><br><span class="line">            <span class="keyword">if</span>(x == y) </span><br><span class="line">                <span class="comment">//最后一个相同的节点就是最近公共祖先</span></span><br><span class="line">                res = x; </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，其中n<em>n</em>为二叉树节点数，递归遍历二叉树每一个节点求路径，后续又遍历路径</li>
<li>空间复杂度：O(n)，最坏情况二叉树化为链表，深度为n<em>n</em>，递归栈深度和路径数组为n</li>
</ul>
<p>这个回溯值得看一下</p>
<h2 id="BM40-重建二叉树"><a href="#BM40-重建二叉树" class="headerlink" title="BM40 重建二叉树"></a><strong>BM40</strong> <strong>重建二叉树</strong></h2><blockquote>
<p>给定节点数为 n 的二叉树的前序遍历和中序遍历结果，请重建出该二叉树并返回它的头结点。</p>
<p>例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建出如下图所示。</p>
</blockquote>
<ul>
<li>step 1：先根据前序遍历第一个点建立根节点。</li>
<li>step 2：然后遍历中序遍历找到根节点在数组中的位置。</li>
<li>step 3：再按照子树的节点数将两个遍历的序列分割成子数组，将子数组送入函数建立子树。</li>
<li>step 4：直到子树的序列长度为0，结束递归。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">reConstructBinaryTree</span><span class="params">(<span class="type">int</span> [] pre,<span class="type">int</span> [] vin)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> pre.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> vin.length;</span><br><span class="line">        <span class="comment">//每个遍历都不能为0</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || m == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//构建根节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(pre[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vin.length; i++)&#123;</span><br><span class="line">            <span class="comment">//找到中序遍历中的前序第一个元素</span></span><br><span class="line">            <span class="keyword">if</span>(pre[<span class="number">0</span>] == vin[i])&#123; </span><br><span class="line">                <span class="comment">//构建左子树</span></span><br><span class="line">                root.left = reConstructBinaryTree(Arrays.copyOfRange(pre, <span class="number">1</span>, i + <span class="number">1</span>), Arrays.copyOfRange(vin, <span class="number">0</span>, i)); </span><br><span class="line">                <span class="comment">//构建右子树</span></span><br><span class="line">                root.right = reConstructBinaryTree(Arrays.copyOfRange(pre, i + <span class="number">1</span>, pre.length), Arrays.copyOfRange(vin, i + <span class="number">1</span>, vin.length));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，其中n为数组长度，即二叉树的节点数，构建每个节点进一次递归，递归中所有的循环加起来一共n次</li>
<li>空间复杂度：O(n)，递归栈最大深度不超过n，辅助数组长度也不超过n，重建的二叉树空间属于必要空间，不属于辅助空间</li>
</ul>
<h2 id="BM41-输出二叉树的右视图"><a href="#BM41-输出二叉树的右视图" class="headerlink" title="BM41 输出二叉树的右视图"></a><strong>BM41</strong> <strong>输出二叉树的右视图</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="四、堆-x2F-栈-x2F-队列"><a href="#四、堆-x2F-栈-x2F-队列" class="headerlink" title="四、堆&#x2F;栈&#x2F;队列"></a>四、<strong>堆&#x2F;栈&#x2F;队列</strong></h1><h2 id="BM42-用两个栈实现队列"><a href="#BM42-用两个栈实现队列" class="headerlink" title="BM42 用两个栈实现队列"></a><strong>BM42</strong> <strong>用两个栈实现队列</strong></h2><blockquote>
<p>用两个栈来实现一个队列，使用n个元素来完成 n 次在队列尾部插入整数(push)和n次在队列头部删除整数(pop)的功能。 队列中的元素为int类型。保证操作合法，即保证pop操作时队列内已有元素。</p>
</blockquote>
<h3 id="思路：栈"><a href="#思路：栈" class="headerlink" title="思路：栈"></a>思路：栈</h3><p>直接模拟就好</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">  <span class="comment">//这里最好还是用Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;();来声明栈</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> node)</span> &#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//将第一个栈中内容弹出放入第二个栈中</span></span><br><span class="line">        <span class="keyword">while</span>(!stack1.isEmpty()) </span><br><span class="line">            stack2.push(stack1.pop()); </span><br><span class="line">        <span class="comment">//第二个栈栈顶就是最先进来的元素，即队首</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> stack2.pop(); </span><br><span class="line">        <span class="comment">//再将第二个栈的元素放回第一个栈</span></span><br><span class="line">        <span class="keyword">while</span>(!stack2.isEmpty()) </span><br><span class="line">            stack1.push(stack2.pop());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM43-包含min函数的栈"><a href="#BM43-包含min函数的栈" class="headerlink" title="BM43 包含min函数的栈"></a><strong>BM43</strong> <strong>包含min函数的栈</strong></h2><blockquote>
<p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的 min 函数，输入操作时保证 pop、top 和 min 函数操作时，栈中一定有元素。</p>
</blockquote>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//用于栈的push 与 pop</span></span><br><span class="line">    Stack&lt;Integer&gt; s1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;(); </span><br><span class="line">    <span class="comment">//用于存储最小min</span></span><br><span class="line">    Stack&lt;Integer&gt; s2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;(); </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//这里最好还是用Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;();来声明栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> node)</span> &#123;</span><br><span class="line">        s1.push(node);  </span><br><span class="line">        <span class="comment">//空或者新元素较小，则入栈</span></span><br><span class="line">        <span class="keyword">if</span>(s2.isEmpty() || s2.peek() &gt; node)  </span><br><span class="line">            s2.push(node);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//重复加入栈顶</span></span><br><span class="line">            s2.push(s2.peek());  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        s1.pop();</span><br><span class="line">        s2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s1.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM44-有效括号序列"><a href="#BM44-有效括号序列" class="headerlink" title="BM44 有效括号序列"></a><strong>BM44</strong> <strong>有效括号序列</strong></h2><blockquote>
<p>给出一个仅包含字符’(‘,’)’,’{‘,’}’,’[‘和’]’,的字符串，判断给出的字符串是否是合法的括号序列<br>括号必须以正确的顺序关闭，”()”和”()[]{}”都是合法的括号序列，但”(]”和”([)]”不合法。</p>
<p>数据范围：字符串长度 0≤n≤10000</p>
<p>要求：空间复杂度 O(n)，时间复杂度 O(n)</p>
</blockquote>
<h3 id="思路：模拟栈"><a href="#思路：模拟栈" class="headerlink" title="思路：模拟栈"></a>思路：模拟栈</h3><ul>
<li>step 1：创建辅助栈，遍历字符串。</li>
<li>step 2：每次遇到小括号的左括号、中括号的左括号、大括号的左括号，就将其对应的呦括号加入栈中，期待在后续遇到。</li>
<li>step 3：如果没有遇到左括号但是栈为空，说明直接遇到了右括号，不合法。</li>
<li>step 4：其他情况下，如果遇到右括号，刚好会与栈顶元素相同，弹出栈顶元素继续遍历。</li>
<li>step 5：理论上，只要括号是匹配的，栈中元素最后是为空的，因此检查栈是否为空即可最后判断是否合法。</li>
</ul>
<p><img src="https://picgooo.oss-cn-hangzhou.aliyuncs.com/img/4760A3E42ACB7E73D162BE2CD8C2E2C9.gif"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span> <span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">//辅助栈</span></span><br><span class="line">        Stack&lt;Character&gt; st = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Character&gt;();</span><br><span class="line">        <span class="comment">//遍历字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//遇到左小括号</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                <span class="comment">//期待遇到右小括号</span></span><br><span class="line">                st.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            <span class="comment">//遇到左中括号</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                <span class="comment">//期待遇到右中括号</span></span><br><span class="line">                st.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            <span class="comment">//遇到左打括号</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                <span class="comment">//期待遇到右打括号</span></span><br><span class="line">                st.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            <span class="comment">//必须有左括号的情况下才能遇到右括号</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (st.isEmpty() || st.pop() != s.charAt(i))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//栈中是否还有元素</span></span><br><span class="line">        <span class="keyword">return</span> st.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM45-滑动窗口的最大值"><a href="#BM45-滑动窗口的最大值" class="headerlink" title="BM45 滑动窗口的最大值"></a><strong>BM45</strong> <strong>滑动窗口的最大值</strong></h2><blockquote>
<p>给定一个数组 <code>nums</code> 和滑动窗口的大小 <code>k</code>，请找出所有滑动窗口里的最大值。</p>
<p>输入: nums &#x3D; [1,3,-1,-3,5,3,6,7], 和 k &#x3D; 3<br>输出: [3,3,5,5,6,7]<br>解释: </p>
<p>  滑动窗口的位置                最大值</p>
<hr>
<p> [1  3  -1] -3  5  3  6  7       3<br>         1 [3  -1  -3] 5  3  6  7       3<br>         1  3 [-1  -3  5] 3  6  7       5<br>         1  3  -1 [-3  5  3] 6  7       5<br>         1  3  -1  -3 [5  3  6] 7       6<br>         1  3  -1  -3  5 [3  6  7]      7</p>
</blockquote>
<h3 id="思路：单调队列"><a href="#思路：单调队列" class="headerlink" title="思路：单调队列"></a>思路：单调队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title function_">maxInWindows</span><span class="params">(<span class="type">int</span> [] num, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (num.length == <span class="number">0</span> || k == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>, i = <span class="number">1</span> - k ; j &lt; num.length; i++, j++) &#123;</span><br><span class="line">          <span class="comment">// 删除 deque 中对应的 nums[i-1]</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; deque.peekFirst() == num[i - <span class="number">1</span>])</span><br><span class="line">                deque.removeFirst();</span><br><span class="line">          <span class="comment">// 保持 deque 递减</span></span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; num[j])</span><br><span class="line">                deque.removeLast();</span><br><span class="line">            deque.addLast(num[j]);</span><br><span class="line">            <span class="comment">// 记录窗口最大值</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">0</span>)</span><br><span class="line">                res.add(deque.peekFirst());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM46-最小的K个数"><a href="#BM46-最小的K个数" class="headerlink" title="BM46 最小的K个数"></a><strong>BM46</strong> <strong>最小的K个数</strong></h2><blockquote>
<p>给定一个长度为 n 的可能有重复值的数组，找出其中不去重的最小的 k 个数。例如数组元素是4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4(任意顺序皆可)。</p>
<p>数据范围：0≤k,n≤10000，数组中每个数的大小0≤val≤1000</p>
<p>要求：空间复杂度 O(n) ，时间复杂度 O(nlogk)</p>
</blockquote>
<h3 id="思路1：sort快排"><a href="#思路1：sort快排" class="headerlink" title="思路1：sort快排"></a>思路1：sort快排</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title function_">GetLeastNumbers_Solution</span><span class="params">(<span class="type">int</span> [] input, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//排除特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span> || input.length == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        Arrays.sort(input); </span><br><span class="line">        <span class="comment">//因为k&lt;=input.length,取前k小</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++)&#123; </span><br><span class="line">            res.add(input[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(nlog2n)，sort函数属于优化后的快速排序，复杂度为O(nlog2n)<em>O</em>(<em>n<strong>l</strong>o**g</em>2<em>n</em>)</li>
<li>空间复杂度：O(1)，无额外辅助空间使用</li>
</ul>
<h2 id="思路2：堆排序"><a href="#思路2：堆排序" class="headerlink" title="思路2：堆排序"></a>思路2：堆排序</h2><p>优先队列即PriorityQueue，是一种内置的机遇堆排序的容器，分为大顶堆与小顶堆，大顶堆的堆顶为最大元素，其余更小的元素在堆下方，小顶堆与其刚好相反。且因为容器内部的次序基于堆排序，因此每次插入元素时间复杂度都是O(log2n)，而每次取出堆顶元素都是直接取出。</p>
<ul>
<li>step 1：利用input数组中前k个元素，构建一个大小为k的大顶堆，堆顶为这k个元素的最大值。</li>
<li>step 2：对于后续的元素，依次比较其与堆顶的大小，若是比堆顶小，则堆顶弹出，再将新数加入堆中，直至数组结束，保证堆中的k个最小。</li>
<li>step 3：最后将堆顶依次弹出即是最小的k个数。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title function_">GetLeastNumbers_Solution</span><span class="params">(<span class="type">int</span> [] input, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//排除特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span> || input.length == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">//大根堆 </span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((o1, o2)-&gt;o2.compareTo(o1));</span><br><span class="line">        <span class="comment">//构建一个k个大小的堆  </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">            q.offer(input[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k; i &lt; input.length; i++)&#123;</span><br><span class="line">            <span class="comment">//较小元素入堆</span></span><br><span class="line">            <span class="keyword">if</span>(q.peek() &gt; input[i])&#123;  </span><br><span class="line">                q.poll();</span><br><span class="line">                q.offer(input[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//堆中元素取出入数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) </span><br><span class="line">            res.add(q.poll());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(nlog2k)，构建和维护大小为k<em>k</em>的堆，需要log2k<em>l<strong>o</strong>g</em>2<em>k</em>，加上遍历整个数组</li>
<li>空间复杂度：O(k)，堆空间为k个元素</li>
</ul>
<h2 id="BM47-寻找第K大"><a href="#BM47-寻找第K大" class="headerlink" title="BM47 寻找第K大"></a><strong>BM47</strong> <strong>寻找第K大</strong></h2><blockquote>
<p>有一个整数数组，请你根据快速排序的思路，找出数组中第 k 大的数。 </p>
<p>给定一个整数数组 a ,同时给定它的大小n和要找的 k ，请返回第 k 大的数(包括重复的元素，不用去重)，保证答案存在。 </p>
<p>要求：时间复杂度 O(nlogn)，空间复杂度 O(1)</p>
<p>数据范围：0≤n≤1000， 1≤K≤n，数组中每个元素满足 0≤val≤10000000</p>
</blockquote>
<h3 id="思路1：随机选择"><a href="#思路1：随机选择" class="headerlink" title="思路1：随机选择"></a>思路1：随机选择</h3><p>速排序的思想–随机选择法，时间复杂度 O(n) 需要理解两个思想，快排的分治，二分查找的剪枝 分治法，每个分支“都要”递归，例如：快速排序，O(n*lg(n)) 减治法，“只要”递归一个分支，例如：二分查找O(lg(n))，随机选择O(n) TopK的另一个解法：随机选择 + partition。</p>
<p>其实要找第k大，前面的排序再取值已经知道了第K大的数，下标是len - k。那么partition能直接定位到len - k 的位置就找到了结果。如何找呢，就用到了二分查找的思想，不断接近len-k的位置，最终返回结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKth</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> n, <span class="type">int</span> K)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> quickSort(a, <span class="number">0</span>, a.length - <span class="number">1</span>, K);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition(arr, left, right);</span><br><span class="line">        <span class="comment">// 改进后，很特殊的是，p是全局下标，只要p对上topK坐标就可以返回</span></span><br><span class="line">        <span class="keyword">if</span> (p == arr.length - k) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr[p];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (p &lt; arr.length - k) &#123;</span><br><span class="line">            <span class="comment">// 如果基准在左边，这在右边找</span></span><br><span class="line">            <span class="keyword">return</span> quickSort(arr, p + <span class="number">1</span>, right,k);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> quickSort(arr, left, p - <span class="number">1</span>,k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">// 可优化成随机，或中位数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> arr[left];</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt;= key) right--;</span><br><span class="line">            arr[left] = arr[right];</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= key) left++;</span><br><span class="line">            arr[right] = arr[left];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[left] = key;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="思路2：内置方法"><a href="#思路2：内置方法" class="headerlink" title="思路2：内置方法"></a>思路2：内置方法</h2><p>全局排序，时间复杂度取决于排序算法，一般是 O(n*lgn)。 相信大多数朋友看到这题的思路就是排序，返回第k大的值，甚至还有小机灵鬼直接调用内置方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKth</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> n, <span class="type">int</span> K)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        Arrays.sort(a);</span><br><span class="line">        <span class="keyword">return</span> a[n-K];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM48-数据流中的中位数"><a href="#BM48-数据流中的中位数" class="headerlink" title="BM48 数据流中的中位数"></a><strong>BM48</strong> <strong>数据流中的中位数</strong></h2><blockquote>
<p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p>
</blockquote>
<h3 id="思路：优先级队列"><a href="#思路：优先级队列" class="headerlink" title="思路：优先级队列"></a>思路：优先级队列</h3><p>困难题目，详解参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/solution/mian-shi-ti-41-shu-ju-liu-zhong-de-zhong-wei-shu-y/">k神</a>。讲的很到位</p>
<p>有一点需要注意：</p>
<ul>
<li>A（小顶堆，存储较大的一半）</li>
<li>B（大顶堆，存储较小的一半）</li>
</ul>
<p><span style='color:orange'>假设插入数字 num 遇到情况 m&#x3D;n的时候，也即数据为偶数的时候 。由于 num 可能属于 “较小的一半” （即属于 B ），因此不能将 nums 直接插入至 A（小顶堆，存储较大的一半） 。而应先将 num 插入至 B ，再将 B 堆顶元素插入至 A 。这样就可以始终保持 A 保存较大一半、 B 保存较小一半。</span></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt; A,B;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Solution</span><span class="params">()</span>&#123;</span><br><span class="line">        A = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">        B = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Comparator.reverseOrder());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Insert</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(A.size() != B.size())&#123;</span><br><span class="line">            A.add(num);</span><br><span class="line">            B.add(A.poll());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            B.add(num);</span><br><span class="line">            A.add(B.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Double <span class="title function_">GetMedian</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (Double)(A.size() != B.size() ? A.peek() : (A.peek() + B.peek()) / <span class="number">2.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM49-表达式求值"><a href="#BM49-表达式求值" class="headerlink" title="BM49 表达式求值"></a><strong>BM49</strong> <strong>表达式求值</strong></h2><blockquote>
<p>请写一个整数计算器，支持加减乘三种运算和括号。 </p>
<p>数据范围：0≤∣s∣≤100，保证计算结果始终在整型范围内</p>
<p>要求：空间复杂度： O(n)，时间复杂度 O(n)</p>
</blockquote>
<h1 id="五、哈希"><a href="#五、哈希" class="headerlink" title="五、哈希"></a>五、哈希</h1><h2 id="BM50-两数之和"><a href="#BM50-两数之和" class="headerlink" title="BM50 两数之和"></a><strong>BM50</strong> <strong>两数之和</strong></h2><blockquote>
<p>给出一个整型数组 numbers 和一个目标值 target，请在数组中找出两个加起来等于目标值的数的下标，返回的下标按升序排列。 </p>
<p>（注：<strong>返回</strong>的数组下标从1开始算起，保证target一定可以由数组里面2个数字相加得到） </p>
</blockquote>
<h3 id="思路：哈希"><a href="#思路：哈希" class="headerlink" title="思路：哈希"></a>思路：哈希</h3><p>很简单～不记录了</p>
<p>主要是要记得：map.containsKey（）、return new int[]{}这两个语法</p>
<h2 id="BM51-数组中出现次数超过一半的数字"><a href="#BM51-数组中出现次数超过一半的数字" class="headerlink" title="BM51 数组中出现次数超过一半的数字"></a><strong>BM51</strong> <strong>数组中出现次数超过一半的数字</strong></h2><blockquote>
<p>给一个长度为 n 的数组，数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。 </p>
<p>例如输入一个长度为9的数组[1,2,3,2,2,2,5,4,2]。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。 </p>
<p>数据范围：n≤5000，数组中元素的值 0≤val≤10000</p>
<p>要求：空间复杂度：O(1)，时间复杂度 O(n)</p>
</blockquote>
<h3 id="思路：哈希-1"><a href="#思路：哈希-1" class="headerlink" title="思路：哈希"></a>思路：哈希</h3><p>一样很简答的一题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">MoreThanHalfNum_Solution</span><span class="params">(<span class="type">int</span> [] array)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> array.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; len ; i++)&#123;</span><br><span class="line">            map.put(array[i],map.getOrDefault(array[i],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(map.get(array[i]) &gt; len/<span class="number">2</span>)&#123;</span><br><span class="line">                res = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM52-数组中只出现一次的两个数字"><a href="#BM52-数组中只出现一次的两个数字" class="headerlink" title="BM52 数组中只出现一次的两个数字"></a><strong>BM52</strong> <strong>数组中只出现一次的两个数字</strong></h2><blockquote>
<p>一个整型数组里除了两个数字只出现一次，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] FindNumsAppearOnce (<span class="type">int</span>[] array) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; array.length ;i++)&#123;</span><br><span class="line">            map.put(array[i],map.getOrDefault(array[i],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; array.length ; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(array[i]) == <span class="number">1</span>)&#123;</span><br><span class="line">                res.add(array[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.get(<span class="number">0</span>) &lt; res.get(<span class="number">1</span>)?<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;res.get(<span class="number">0</span>),res.get(<span class="number">1</span>)&#125;:<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;res.get(<span class="number">1</span>),res.get(<span class="number">0</span>)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM53-缺失的第一个正整数"><a href="#BM53-缺失的第一个正整数" class="headerlink" title="BM53 缺失的第一个正整数"></a><strong>BM53</strong> <strong>缺失的第一个正整数</strong></h2><blockquote>
<p>给定一个无重复元素的整数数组nums，请你找出其中没有出现的最小的正整数</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minNumberDisappeared</span> <span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; mp = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;(); </span><br><span class="line">        <span class="comment">//哈希表记录数组中出现的每个数字</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">            mp.put(nums[i], <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//从1开始找到哈希表中第一个没有出现的正整数</span></span><br><span class="line">        <span class="keyword">while</span>(mp.containsKey(res)) </span><br><span class="line">            res++;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM-54-三数之和"><a href="#BM-54-三数之和" class="headerlink" title="BM 54 三数之和"></a>BM 54 三数之和</h2><h3 id="思路：排序-双指针"><a href="#思路：排序-双指针" class="headerlink" title="思路：排序+双指针"></a>思路：排序+双指针</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; nums.length - <span class="number">2</span>; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[k] &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k + <span class="number">1</span>, j = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[k] + nums[i] + nums[j];</span><br><span class="line">                <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] == nums[++i]);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] == nums[--j]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(Arrays.asList(nums[k], nums[i], nums[j])));</span><br><span class="line">                    <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] == nums[++i]);</span><br><span class="line">                    <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] == nums[--j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM55-没有重复项数字的全排列"><a href="#BM55-没有重复项数字的全排列" class="headerlink" title="BM55 没有重复项数字的全排列"></a><span style='color:red'><strong>BM55</strong> <strong>没有重复项数字的全排列</strong></span></h2><blockquote>
<p>给出一组数字，返回该组数字的所有排列 </p>
<p>例如： </p>
<p>[1,2,3]的所有排列如下<br>[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2], [3,2,1].<br>（以数字在数组中的位置靠前为优先级，按字典序排列输出。） </p>
<p>数据范围：数字个数 0&lt;n≤6</p>
<p>要求：空间复杂度 O(n!) ，时间复杂度 O(n!）</p>
</blockquote>
<h3 id="思路：回溯"><a href="#思路：回溯" class="headerlink" title="思路：回溯"></a>思路：回溯</h3><p>这个理解有点难，可以适当记一下～</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] num)</span> &#123;</span><br><span class="line">      res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">      <span class="comment">// 存一种排列</span></span><br><span class="line">        LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">      <span class="comment">// 递归进行</span></span><br><span class="line">        backTrack(num,list);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(<span class="type">int</span>[] num , LinkedList&lt;Integer&gt; list)</span>&#123;</span><br><span class="line">      <span class="comment">// 当list中的长度等于数组的长度，则证明此时已经找到一种排列了</span></span><br><span class="line">        <span class="keyword">if</span>(list.size() == num.length)&#123;</span><br><span class="line">          <span class="comment">// add进返回结果集中</span></span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(list));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 遍历num数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; num.length ; i++)&#123;</span><br><span class="line">          <span class="comment">// 若当前位置中的数已经添加过了则跳过</span></span><br><span class="line">            <span class="keyword">if</span>(list.contains(num[i]))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">          <span class="comment">// 选择该数</span></span><br><span class="line">            list.add(num[i]);</span><br><span class="line">          <span class="comment">// 继续寻找</span></span><br><span class="line">            backTrack(num,list);</span><br><span class="line">          <span class="comment">// 撤销最后一个</span></span><br><span class="line">            list.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更快的写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; output = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            output.add(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        backtrack(n, output, res, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> n, List&lt;Integer&gt; output, List&lt;List&lt;Integer&gt;&gt; res, <span class="type">int</span> first)</span> &#123;</span><br><span class="line">        <span class="comment">// 所有数都填完了</span></span><br><span class="line">        <span class="keyword">if</span> (first == n) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(output));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> first; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 动态维护数组</span></span><br><span class="line">            Collections.swap(output, first, i);</span><br><span class="line">            <span class="comment">// 继续递归填下一个数</span></span><br><span class="line">            backtrack(n, output, res, first + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 撤销操作</span></span><br><span class="line">            Collections.swap(output, first, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<p>其实这种写法和第一种写法本质上一样～</p>
<p><span style='color:orange'>最好背下面这个！</span></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list ;</span><br><span class="line">    <span class="type">boolean</span>[] visit;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">       list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       visit = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">       List&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       permute(nums,<span class="number">0</span>,tmp);</span><br><span class="line">       <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> dp,List&lt;Integer&gt; tmp)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp == nums.length)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(tmp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visit[i])&#123;</span><br><span class="line">                tmp.add(nums[i]);</span><br><span class="line">                visit[i] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                permute(nums,dp+<span class="number">1</span>,tmp);</span><br><span class="line"></span><br><span class="line">                tmp.remove(tmp.size()-<span class="number">1</span>);</span><br><span class="line">                visit[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM56-有重复项数字的全排列"><a href="#BM56-有重复项数字的全排列" class="headerlink" title="BM56 有重复项数字的全排列"></a><strong>BM56</strong> <strong>有重复项数字的全排列</strong></h2><blockquote>
<p>给出一组可能包含重复项的数字，返回该组数字的所有排列。结果以字典序升序排列。</p>
</blockquote>
<h3 id="思路：回溯-1"><a href="#思路：回溯-1" class="headerlink" title="思路：回溯"></a>思路：回溯</h3><p>和上个题目一样，区别是要加一个判断条件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">    <span class="type">boolean</span>[] visit;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        visit = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backTrack(nums, <span class="number">0</span> , temp);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(<span class="type">int</span>[] nums , <span class="type">int</span> dp , ArrayList&lt;Integer&gt; temp )</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp.size() == nums.length)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(temp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; nums.length ; i++)&#123;</span><br><span class="line">          <span class="comment">//关键在于这里：如果当前数已经被访问过了，或者当前数和前面一个数一样而且前面一个数没有访问过</span></span><br><span class="line">          <span class="comment">//就直接跳过本次循环，</span></span><br><span class="line">            <span class="keyword">if</span>(visit[i] || (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !visit[i - <span class="number">1</span>]))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp.add(nums[i]);</span><br><span class="line">            visit[i] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            backTrack(nums,dp+<span class="number">1</span> ,temp);</span><br><span class="line"></span><br><span class="line">            temp.remove(temp.size()-<span class="number">1</span>);</span><br><span class="line">            visit[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM57-岛屿数量"><a href="#BM57-岛屿数量" class="headerlink" title="BM57 岛屿数量"></a><strong>BM57</strong> <strong>岛屿数量</strong></h2><blockquote>
<p>给一个01矩阵，1代表是陆地，0代表海洋， 如果两个1相邻，那么这两个1属于同一个岛。我们只考虑上下左右为相邻。</p>
<p>岛屿: 相邻陆地可以组成一个岛屿（相邻:上下左右） 判断岛屿个数。</p>
</blockquote>
<h3 id="思路：dfs"><a href="#思路：dfs" class="headerlink" title="思路：dfs"></a>思路：dfs</h3><p>比较简单的想法就是：找到一个1，就把离这个1最近的1全部变为0～</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; grid.length ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; grid[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    dfs(grid,i,j);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] grid,<span class="type">int</span> i , <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= grid.length || j &gt;= grid[<span class="number">0</span>].length || grid[i][j] == <span class="string">&#x27;0&#x27;</span> )   <span class="keyword">return</span>;</span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        dfs(grid,i-<span class="number">1</span>,j);</span><br><span class="line">        dfs(grid,i+<span class="number">1</span>,j);</span><br><span class="line">        dfs(grid,i,j-<span class="number">1</span>);</span><br><span class="line">        dfs(grid,i,j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM58-字符串的排列"><a href="#BM58-字符串的排列" class="headerlink" title="BM58 字符串的排列"></a><strong>BM58</strong> <strong>字符串的排列</strong></h2><blockquote>
<p>输入一个长度为 n 字符串，打印出该字符串中字符的所有排列，你可以以任意顺序返回这个字符串数组。</p>
<p>例如输入字符串ABC,则输出由字符A,B,C所能排列出来的所有字符串ABC,ACB,BAC,BCA,CBA和CAB。</p>
</blockquote>
<h3 id="思路：回溯-2"><a href="#思路：回溯-2" class="headerlink" title="思路：回溯"></a>思路：回溯</h3><p>和前面的回溯一样，可以套模版</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    ArrayList&lt;String&gt; res;</span><br><span class="line">    <span class="type">boolean</span>[] visit;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title function_">Permutation</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        visit = <span class="keyword">new</span> <span class="title class_">boolean</span>[str.length()];</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] chars = str.toCharArray();</span><br><span class="line">        Arrays.sort(chars);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str_new</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        backTrack(str_new , <span class="number">0</span> ,temp );</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(String str , <span class="type">int</span> dp , StringBuilder temp)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp == str.length())&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">String</span>(temp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; str.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visit[i] || (i&gt;<span class="number">0</span> &amp;&amp; str.charAt(i) == str.charAt(i-<span class="number">1</span>) &amp;&amp; !visit[i-<span class="number">1</span>]))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp.append(str.charAt(i));</span><br><span class="line">            visit[i] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            backTrack(str,dp+<span class="number">1</span>,temp);</span><br><span class="line">            temp.deleteCharAt(temp.length()-<span class="number">1</span>);</span><br><span class="line">            visit[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM60-括号生成"><a href="#BM60-括号生成" class="headerlink" title="BM60 括号生成"></a><strong>BM60</strong> <strong>括号生成</strong></h2><blockquote>
<p>给出n对括号，请编写一个函数来生成所有的由n对括号组成的合法组合。</p>
<p>例如，给出n&#x3D;3，解集为：</p>
<p>“((()))”, “(()())”, “(())()”, “()()()”, “()(())”</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串ArrayList</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title function_">generateParenthesis</span> <span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        ArrayList&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="string">&quot;&quot;</span> , n , n ,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(String str , <span class="type">int</span> left ,<span class="type">int</span> right , ArrayList&lt;String&gt; res)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>)&#123;</span><br><span class="line">            res.add(str);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            dfs(str+<span class="string">&quot;(&quot;</span> , left-<span class="number">1</span> , right , res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            dfs(str+<span class="string">&quot;)&quot;</span> , left , right-<span class="number">1</span> ,res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="BM61-矩阵最长递增路径"><a href="#BM61-矩阵最长递增路径" class="headerlink" title="BM61 矩阵最长递增路径"></a><strong>BM61</strong> <strong>矩阵最长递增路径</strong></h2><blockquote>
<p>给定一个 n 行 m 列矩阵 matrix ，矩阵内所有数均为非负整数。 你需要在矩阵中找到一条最长路径，使这条路径上的元素是递增的。并输出这条最长路径的长度。 </p>
<p>这个路径必须满足以下条件：</p>
<p>\1. 对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外。</p>
<p>\2. 你不能走重复的单元格。即每个格子最多只能走一次。</p>
</blockquote>
<h3 id="思路：记忆搜索"><a href="#思路：记忆搜索" class="headerlink" title="思路：记忆搜索"></a>思路：记忆搜索</h3><p>结合了dfs的想法～</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上下左右四个方向</span></span><br><span class="line">    <span class="type">int</span>[][] dirs = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestIncreasingPath</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="comment">// 从每一个点出发，往下深搜，看它最远能到哪</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记忆化</span></span><br><span class="line">        <span class="type">int</span>[][] memo = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 每个点都要作为起始点遍历一下</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="comment">// 已经遍历过的就不用遍历了</span></span><br><span class="line">                <span class="keyword">if</span> (memo[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    ans = Math.max(ans, dfs(matrix, m, n, i, j, memo));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 这里为什么不用再比较一次 ans 和 memo[i][j]呢？</span></span><br><span class="line">                <span class="comment">// 因为遍历前面节点的时候已经把后面的节点遍历了</span></span><br><span class="line">                <span class="comment">// 说明后面的节点肯定比前面的节点的最长路径短</span></span><br><span class="line">                <span class="comment">// 所以，不用多判断一次了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span>[][] memo)</span> &#123;</span><br><span class="line">        <span class="comment">// 已经遍历过，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (memo[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i][j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 否则，看四个方向是否有满足条件的节点去扩散</span></span><br><span class="line">        <span class="comment">// 每个节点的初始路径为1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] dir : dirs) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextI</span> <span class="operator">=</span> i + dir[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextJ</span> <span class="operator">=</span> j + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (nextI &gt;= <span class="number">0</span> &amp;&amp; nextJ &gt;= <span class="number">0</span> &amp;&amp; nextI &lt; m &amp;&amp; nextJ &lt;n &amp;&amp; matrix[nextI][nextJ] &gt; matrix[i][j]) &#123;</span><br><span class="line">                ans = Math.max(ans, dfs(matrix, m, n, nextI, nextJ, memo) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录到缓存中</span></span><br><span class="line">        memo[i][j] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="七、动态规划"><a href="#七、动态规划" class="headerlink" title="七、动态规划"></a>七、动态规划</h1><h2 id="BM62-斐波那契数列"><a href="#BM62-斐波那契数列" class="headerlink" title="BM62 斐波那契数列"></a><strong>BM62</strong> <strong>斐波那契数列</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Fibonacci</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span> ; i &lt;= n ;i++)&#123;</span><br><span class="line">            dp[i] = dp[i-<span class="number">2</span>]+dp[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="BM63-跳台阶"><a href="#BM63-跳台阶" class="headerlink" title="BM63 跳台阶"></a><strong>BM63</strong> <strong>跳台阶</strong></h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
<p>数据范围：1≤�≤401≤<em>n</em>≤40</p>
<p>要求：时间复杂度：�(�)<em>O</em>(<em>n</em>) ，空间复杂度： �(1)<em>O</em>(1)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int jumpFloor(int target) &#123;</span><br><span class="line">        int[] dp = new int[target+1];</span><br><span class="line">        dp[0] = 1;</span><br><span class="line">        dp[1] = 1;</span><br><span class="line">        for(int i = 2 ; i &lt;= target ;i++)&#123;</span><br><span class="line">            dp[i] = dp[i-1]+dp[i-2];</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="BM64-最小花费爬楼梯"><a href="#BM64-最小花费爬楼梯" class="headerlink" title="BM64 最小花费爬楼梯"></a><strong>BM64</strong> <strong>最小花费爬楼梯</strong></h2><p>给定一个整数数组 ���� <em>c<strong>o</strong>s**t</em> ，其中 ����[�] <em>c<strong>o</strong>s**t</em>[<em>i</em>] 是从楼梯第� <em>i</em> 个台阶向上爬需要支付的费用，下标从0开始。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p>
<p>你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。</p>
<p>请你计算并返回达到楼梯顶部的最低花费。</p>
<p>数据范围：数组长度满足 1≤�≤105 1≤<em>n</em>≤105 ，数组中的值满足 1≤�����≤104 1≤<em>c<strong>o</strong>s<strong>t</strong>i</em>≤104 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cost int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostClimbingStairs</span> <span class="params">(<span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> cost.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span> ; i &lt; len+<span class="number">1</span> ; i++)&#123;</span><br><span class="line">            dp[i] = Math.min((dp[i-<span class="number">1</span>]+cost[i-<span class="number">1</span>]),(dp[i-<span class="number">2</span>]+cost[i-<span class="number">2</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM65-最长公共子序列-二"><a href="#BM65-最长公共子序列-二" class="headerlink" title="BM65 最长公共子序列(二)"></a><strong>BM65</strong> <strong>最长公共子序列(二)</strong></h2><p>给定两个字符串str1和str2，输出两个字符串的最长公共子序列。如果最长公共子序列为空，则返回”-1”。目前给出的数据，仅仅会存在一个最长的公共子序列</p>
<h3 id="思路：动态规划"><a href="#思路：动态规划" class="headerlink" title="思路：动态规划"></a>思路：动态规划</h3><p>和leetcode的题目很类似：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/qJnOS7/">剑指 Offer II 095. 最长公共子序列</a></p>
<p>只不过leetcode只用返回长度，本题需要返回公共子序列</p>
<p>但是想法还是一样的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * longest common subsequence</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s1 string字符串 the string</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s2 string字符串 the string</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">LCS</span> <span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s1.length(),m = s2.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">char1</span> <span class="operator">=</span> s1.charAt(i-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span> ; j &lt;= m;j++)&#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">char2</span> <span class="operator">=</span> s2.charAt(j-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(char1 == char2)&#123;</span><br><span class="line">                    dp[i][j] = <span class="number">1</span>+dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//return dp[n][m]; 这上面即为leecode题目的代码</span></span><br><span class="line">      <span class="comment">//下面部分即为根据长度来反向收集字符</span></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span>(dp[n][m] == <span class="number">0</span> ) <span class="keyword">return</span> <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">0</span> &amp;&amp; m&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1.charAt(n-<span class="number">1</span>) == s2.charAt(m-<span class="number">1</span>))&#123;</span><br><span class="line">                res.append(s1.charAt(n-<span class="number">1</span>));</span><br><span class="line">                n--;m--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[n-<span class="number">1</span>][m] &gt; dp[n][m-<span class="number">1</span>])&#123;</span><br><span class="line">                    n--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    m--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="BM66-最长公共子串"><a href="#BM66-最长公共子串" class="headerlink" title="BM66 最长公共子串"></a><strong>BM66</strong> <strong>最长公共子串</strong></h2><p>给定两个字符串str1和str2,输出两个字符串的最长公共子串</p>
<p>题目保证str1和str2的最长公共子串存在且唯一。 </p>
<h3 id="思路：动态规划-1"><a href="#思路：动态规划-1" class="headerlink" title="思路：动态规划"></a>思路：动态规划</h3><p>本题和前面一题的区别在于：需要连续才能认定为子串</p>
<ul>
<li>step 1：我们可以用dp{i}{j}表示在str1中以第i个字符结尾在str2中以第j个字符结尾时的公共子串长度，</li>
<li>step 2：遍历两个字符串填充dp数组，转移方程为：如果遍历到的该位两个字符相等，则此时长度等于两个前一位长度+1，dp{i}{j} &#x3D; dp{i-1}{j-1}+1，如果遍历到该位时两个字符不相等，则置为0，因为这是子串，必须连续相等，断开要重新开始。</li>
<li>step 3：每次更新dp{i}{j}后，我们维护最大值，并更新该子串结束位置。</li>
<li>step 4：最后根据最大值结束位置即可截取出子串。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * longest common substring</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str1 string字符串 the string</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str2 string字符串 the string</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">LCS</span> <span class="params">(String str1, String str2)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> str1.length() , m = str2.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span> , end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt;= n ;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span> ; j &lt;= m ; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(str1.charAt(i-<span class="number">1</span>) == str2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j] = <span class="number">1</span>+ dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                  <span class="comment">//如果遍历到该位时两个字符不相等，则置为0，因为这是子串，必须连续相等，断开要重新开始。</span></span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] &gt; max)&#123;</span><br><span class="line">                  <span class="comment">//如果出现新的最长，则更新字符串结束为止和max</span></span><br><span class="line">                    max = dp[i][j];</span><br><span class="line">                    end = i-<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str1.substring(end - max +<span class="number">1</span>,end+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM67-不同路径的数目-一"><a href="#BM67-不同路径的数目-一" class="headerlink" title="BM67 不同路径的数目(一)"></a><strong>BM67</strong> <strong>不同路径的数目(一)</strong></h2><p>一个机器人在m×n大小的地图的左上角（起点）。</p>
<p>机器人每次可以向下或向右移动。机器人要到达地图的右下角（终点）。</p>
<p>可以有多少种不同的路径从起点走到终点？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span> <span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; m ; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt; m ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span> ; j &lt; n ;j++)&#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM68-矩阵的最小路径和"><a href="#BM68-矩阵的最小路径和" class="headerlink" title="BM68 矩阵的最小路径和"></a><strong>BM68</strong> <strong>矩阵的最小路径和</strong></h2><p>给定一个 n * m 的矩阵 a，从左上角开始每次只能向右或者向下走，最后到达右下角的位置，路径上所有的数字累加起来就是路径和，输出所有的路径中最小的路径和。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> matrix int整型二维数组 the matrix</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPathSum</span> <span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> matrix.length , col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[row][col];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt; row ; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = matrix[i][<span class="number">0</span>] + dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span> ; j &lt; col ; j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = matrix[<span class="number">0</span>][j] + dp[<span class="number">0</span>][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt; row ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span> ; j &lt; col ; j++)&#123;</span><br><span class="line">                dp[i][j] = matrix[i][j] + (dp[i - <span class="number">1</span>][j] &gt; dp[i][j - <span class="number">1</span>] ? dp[i][j - <span class="number">1</span>] : dp[i - <span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[row-<span class="number">1</span>][col-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM69-把数字翻译成字符串"><a href="#BM69-把数字翻译成字符串" class="headerlink" title="BM69 把数字翻译成字符串"></a><strong>BM69</strong> <strong>把数字翻译成字符串</strong></h2><p>有一种将字母编码成数字的方式：’a’-&gt;1, ‘b-&gt;2’, … , ‘z-&gt;26’。</p>
<p>现在给一串数字，返回有多少种可能的译码结果</p>
<p><img src="https://pic.leetcode-cn.com/e231fde16304948251633cfc65d04396f117239ea2d13896b1d2678de9067b42-Picture1.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">solve</span> <span class="params">(String nums)</span> &#123;</span><br><span class="line">        <span class="comment">//排除0</span></span><br><span class="line">        <span class="keyword">if</span>(nums.equals(<span class="string">&quot;0&quot;</span>))  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//排除只有一种可能的10 和 20</span></span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="string">&quot;10&quot;</span> || nums == <span class="string">&quot;20&quot;</span>)  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//当0的前面不是1或2时，无法译码，0种</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length(); i++)&#123;  </span><br><span class="line">            <span class="keyword">if</span>(nums.charAt(i) == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span>(nums.charAt(i - <span class="number">1</span>) != <span class="string">&#x27;1&#x27;</span> &amp;&amp; nums.charAt(i - <span class="number">1</span>) != <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//辅助数组初始化为1</span></span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);  </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= nums.length(); i++)&#123;</span><br><span class="line">            <span class="comment">//在11-19，21-26之间的情况</span></span><br><span class="line">            <span class="keyword">if</span>((nums.charAt(i - <span class="number">2</span>) == <span class="string">&#x27;1&#x27;</span> &amp;&amp; nums.charAt(i - <span class="number">1</span>) != <span class="string">&#x27;0&#x27;</span>) || (nums.charAt(i - <span class="number">2</span>) == <span class="string">&#x27;2&#x27;</span> &amp;&amp; nums.charAt(i - <span class="number">1</span>) &gt; <span class="string">&#x27;0&#x27;</span> &amp;&amp; nums.charAt(i - <span class="number">1</span>) &lt; <span class="string">&#x27;7&#x27;</span>))</span><br><span class="line">               dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="BM70-兑换零钱-一"><a href="#BM70-兑换零钱-一" class="headerlink" title="BM70 兑换零钱(一)"></a><strong>BM70</strong> <strong>兑换零钱(一)</strong></h2><p>给定数组arr，arr中所有的值都为正整数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个aim，代表要找的钱数，求组成aim的最少货币数。</p>
<p>如果无解，请返回-1.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[5,2,3],20</span><br><span class="line">返回值：4</span><br></pre></td></tr></table></figure>

<h3 id="思路：完全背包问题——动态规划"><a href="#思路：完全背包问题——动态规划" class="headerlink" title="思路：完全背包问题——动态规划"></a>思路：完全背包问题——动态规划</h3><p>先遍历物品，再遍历背包——<strong>求组合数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化dp数组为最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; dp.length; j++) &#123;</span><br><span class="line">            dp[j] = max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当金额为0时需要的硬币数目为0</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; coins.length; i++) &#123;</span><br><span class="line">            <span class="comment">//正序遍历：完全背包每个硬币可以选择多次</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> coins[i]; j &lt;= amount; j++) &#123;</span><br><span class="line">                <span class="comment">//只有dp[j-coins[i]]不是初始最大值时，该位才有选择的必要</span></span><br><span class="line">                <span class="keyword">if</span> (dp[j - coins[i]] != max) &#123;</span><br><span class="line">                    <span class="comment">//选择硬币数目最小的情况</span></span><br><span class="line">                    dp[j] = Math.min(dp[j], dp[j - coins[i]] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] == max ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>先遍历背包，再遍历物品——<strong>求排列数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minMoney</span> <span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> aim)</span> &#123;</span><br><span class="line">        <span class="comment">//小于1的都返回0</span></span><br><span class="line">        <span class="keyword">if</span>(aim &lt; <span class="number">1</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[aim + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//dp[i]表示凑齐i元最少需要多少货币数</span></span><br><span class="line">        Arrays.fill(dp, aim + <span class="number">1</span>); </span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>; </span><br><span class="line">        <span class="comment">//遍历1-aim元</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= aim; i++)&#123; </span><br><span class="line">            <span class="comment">//每种面值的货币都要枚举</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length; j++)&#123; </span><br><span class="line">                <span class="comment">//如果面值不超过要凑的钱才能用</span></span><br><span class="line">                <span class="keyword">if</span>(arr[j] &lt;= i) </span><br><span class="line">                    <span class="comment">//维护最小值</span></span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[i - arr[j]] + <span class="number">1</span>); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果最终答案大于aim代表无解</span></span><br><span class="line">        <span class="keyword">return</span> dp[aim] &gt; aim ? -<span class="number">1</span> : dp[aim]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="BM71-最长上升子序列-一"><a href="#BM71-最长上升子序列-一" class="headerlink" title="BM71 最长上升子序列(一)"></a><strong>BM71</strong> <strong>最长上升子序列(一)</strong></h2><p>给定一个长度为 n 的数组 arr，求它的最长严格上升子序列的长度。</p>
<p>所谓子序列，指一个数组删掉一些数（也可以不删）之后，形成的新数组。例如 [1,5,3,7,3] 数组，其子序列有：[1,3,3]、[7] 等。但 [1,6]、[1,3,5] 则不是它的子序列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[6,3,1,5,2,3,7]</span><br><span class="line">返回：4</span><br><span class="line">说明：该数组最长上升子序列为 [1,2,3,7] ，长度为4</span><br></pre></td></tr></table></figure>

<h3 id="思路：动态规划-2"><a href="#思路：动态规划-2" class="headerlink" title="思路：动态规划"></a>思路：动态规划</h3><ul>
<li>1、状态方程的含义</li>
</ul>
<p>本题，状态方程的含义：<strong>dp[i]表示i之前包括i的以nums[i]结尾的最长递增子序列的长度</strong></p>
<ul>
<li>2、状态转移方程</li>
</ul>
<p>位置i的最长升序子序列等于j从0到i-1各个位置的最长升序子序列 + 1 的最大值。</p>
<p>所以：if (nums[i] &gt; nums[j]) dp[i] &#x3D; max(dp[i], dp[j] + 1);</p>
<p><strong>注意这里不是要dp[i] 与 dp[j] + 1进行比较，而是我们要取dp[j] + 1的最大值</strong>。</p>
<ul>
<li>3、确定遍历顺序</li>
</ul>
<p>dp[i] 是有0到i-1各个位置的最长递增子序列 推导而来，那么遍历i一定是从前向后遍历。</p>
<p>j其实就是遍历0到i-1，那么是从前到后，还是从后到前遍历都无所谓，只要吧 0 到 i-1 的元素都遍历了就行了。 所以默认习惯 从前向后遍历。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 给定数组的最长严格上升子序列的长度。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr int整型一维数组 给定的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">LIS</span> <span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">        Arrays.fill(dp,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; dp.length ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; i ; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i] &gt; arr[j])&#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; dp.length ;i++)&#123;</span><br><span class="line">            res = Math.max(res,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="BM72-连续子数组的最大和"><a href="#BM72-连续子数组的最大和" class="headerlink" title="BM72 连续子数组的最大和"></a><strong>BM72</strong> <strong>连续子数组的最大和</strong></h2><p>输入一个长度为n的整型数组array，数组中的一个或连续多个整数组成一个子数组，子数组最小长度为1。求所有子数组的和的最大值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i] += Math.max(nums[i - <span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">            res = Math.max(res, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">FindGreatestSumOfSubArray</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[array.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        Arrays.fill(dp,min);</span><br><span class="line">        dp[<span class="number">0</span>] = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt; array.length ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i-<span class="number">1</span>] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                dp[i] = array[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i] = Math.max(dp[i],dp[i-<span class="number">1</span>]+array[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MIN_VALUE ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; dp.length ; i++)&#123;</span><br><span class="line">            res = Math.max(res,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="BM73-最长回文子串"><a href="#BM73-最长回文子串" class="headerlink" title="BM73 最长回文子串"></a><strong>BM73</strong> <strong>最长回文子串</strong></h2><p>对于长度为n的一个字符串A（仅包含数字，大小写英文字母），请设计一个高效算法，计算其中最长回文子串的长度。</p>
<h3 id="思路：中心扩展"><a href="#思路：中心扩展" class="headerlink" title="思路：中心扩展"></a>思路：中心扩展</h3><ul>
<li>step 1：遍历字符串每个字符。</li>
<li>step 2：以每次遍历到的字符为中心（分奇数长度和偶数长度两种情况），不断向两边扩展。</li>
<li>step 3：如果两边都是相同的就是回文，不断扩大到最大长度即是以这个字符（或偶数两个）为中心的最长回文子串。</li>
<li>step 4：我们比较完每个字符为中心的最长回文子串，取最大值即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fun</span><span class="params">(String s, <span class="type">int</span> begin, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="comment">//每个中心点开始扩展</span></span><br><span class="line">        <span class="keyword">while</span>(begin &gt;= <span class="number">0</span> &amp;&amp; end &lt; s.length() &amp;&amp; s.charAt(begin) == s.charAt(end))&#123; </span><br><span class="line">            begin--;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回长度</span></span><br><span class="line">        <span class="keyword">return</span> end - begin - <span class="number">1</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLongestPalindrome</span> <span class="params">(String A)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxlen</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//以每个点为中心</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; A.length() - <span class="number">1</span>; i++) </span><br><span class="line">            <span class="comment">//分奇数长度和偶数长度向两边扩展</span></span><br><span class="line">            maxlen = Math.max(maxlen, Math.max(fun(A, i, i), fun(A, i, i + <span class="number">1</span>))); </span><br><span class="line">        <span class="keyword">return</span> maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="BM74-数字字符串转化成IP地址"><a href="#BM74-数字字符串转化成IP地址" class="headerlink" title="BM74 数字字符串转化成IP地址"></a><strong>BM74</strong> <strong>数字字符串转化成IP地址</strong></h2><p>现在有一个只包含数字的字符串，将该字符串转化成IP地址的形式，返回所有可能的情况。</p>
<p>例如：</p>
<p>给出的字符串为”25525522135”,</p>
<p>返回[“255.255.22.135”, “255.255.221.35”]. (顺序没有关系)</p>
<h1 id="八、字符串"><a href="#八、字符串" class="headerlink" title="八、字符串"></a>八、字符串</h1><h2 id="BM83-字符串变形"><a href="#BM83-字符串变形" class="headerlink" title="BM83 字符串变形"></a><strong>BM83</strong> <strong>字符串变形</strong></h2><p>对于一个长度为 n 字符串，我们需要对它做一些变形。</p>
<p>首先这个字符串中包含着一些空格，就像”Hello World”一样，然后我们要做的是把这个字符串中由空格隔开的单词反序，同时反转每个字符的大小写。</p>
<p>比如”Hello World”变形后就变成了”wORLD hELLO”。</p>
<p>数据范围: 1≤�≤1061≤<em>n</em>≤106 , 字符串中包括大写英文字母、小写英文字母、空格。</p>
<p>进阶：空间复杂度 �(�)<em>O</em>(<em>n</em>) ， 时间复杂度 �(�)<em>O</em>(<em>n</em>)</p>
<h3 id="思路：双反转"><a href="#思路：双反转" class="headerlink" title="思路：双反转"></a>思路：双反转</h3><ul>
<li>step 1：遍历字符串，遇到小写字母，转换成大写，遇到大写字母，转换成小写，遇到空格正常不变。</li>
<li>step 2：第一次反转整个字符串，这样基本的单词逆序就有了，但是每个单词的字符也是逆的。</li>
<li>step 3：再次遍历字符串，以每个空间为界，将每个单词反转回正常。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">trans</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        StringBuffer res=<span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="comment">//大小写转换</span></span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) &lt;= <span class="string">&#x27;Z&#x27;</span> &amp;&amp; s.charAt(i) &gt;= <span class="string">&#x27;A&#x27;</span>)   </span><br><span class="line">                res.append((<span class="type">char</span>)(s.charAt(i) - <span class="string">&#x27;A&#x27;</span> + <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; s.charAt(i) &lt;= <span class="string">&#x27;z&#x27;</span>) </span><br><span class="line">                res.append((<span class="type">char</span>)(s.charAt(i) - <span class="string">&#x27;a&#x27;</span> + <span class="string">&#x27;A&#x27;</span>));</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="comment">//空格直接复制</span></span><br><span class="line">                res.append(s.charAt(i));  </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//翻转整个字符串</span></span><br><span class="line">        res = res.reverse();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="comment">//以空格为界，二次翻转</span></span><br><span class="line">            <span class="keyword">while</span>(j &lt; n &amp;&amp; res.charAt(j) != <span class="string">&#x27; &#x27;</span>)  </span><br><span class="line">                j++;</span><br><span class="line">            <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> res.substring(i,j);</span><br><span class="line">            <span class="type">StringBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(temp);</span><br><span class="line">            temp = buffer.reverse().toString();</span><br><span class="line">            res.replace(i,j,temp);</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="BM84-最长公共前缀"><a href="#BM84-最长公共前缀" class="headerlink" title="BM84 最长公共前缀"></a><strong>BM84</strong> <strong>最长公共前缀</strong></h2><p>给你一个大小为 n 的字符串数组 strs ，其中包含n个字符串 , 编写一个函数来查找字符串数组中的最长公共前缀，返回这个公共前缀。</p>
<p>数据范围： 0≤�≤50000≤<em>n</em>≤5000， 0≤���(�����)≤50000≤<em>l<strong>e</strong>n</em>(<em>s<strong>t</strong>r<strong>s</strong>i</em>)≤5000</p>
<p>进阶：空间复杂度 �(1)<em>O</em>(1)，时间复杂度 �(�∗���)<em>O</em>(<em>n</em>∗<em>l<strong>e</strong>n</em>)</p>
<h3 id="思路：遍历-3"><a href="#思路：遍历-3" class="headerlink" title="思路：遍历"></a>思路：遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestCommonPrefix</span> <span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> strs.length;</span><br><span class="line">        <span class="comment">//空字符串数组</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//遍历第一个字符串的长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strs[<span class="number">0</span>].length(); i++)&#123; </span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> strs[<span class="number">0</span>].charAt(i); </span><br><span class="line">            <span class="comment">//遍历后续的字符串</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) </span><br><span class="line">                <span class="comment">//比较每个字符串该位置是否和第一个相同</span></span><br><span class="line">                <span class="keyword">if</span>(i == strs[j].length() || strs[j].charAt(i) != temp) </span><br><span class="line">                    <span class="comment">//不相同则结束</span></span><br><span class="line">                    <span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>, i); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//后续字符串有整个字一个字符串的前缀</span></span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="BM85-验证IP地址"><a href="#BM85-验证IP地址" class="headerlink" title="BM85 验证IP地址"></a><strong>BM85</strong> <strong>验证IP地址</strong></h2><p>验证一个ip地址是否非法，合法的话到底是IPv4还是IPv6</p>
<h3 id="思路：正则表达式"><a href="#思路：正则表达式" class="headerlink" title="思路：正则表达式"></a>思路：正则表达式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IPv4：(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.)&#123;3&#125;([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])</span><br><span class="line"></span><br><span class="line">IPv6：([0-9a-fA-F]&#123;1,4&#125;\\:)&#123;7&#125;[0-9a-fA-F]&#123;1,4&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Ipv4正则表达式解释"><a href="#Ipv4正则表达式解释" class="headerlink" title="Ipv4正则表达式解释"></a>Ipv4正则表达式解释</h3><blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.)&#123;3&#125;([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])</span><br></pre></td></tr></table></figure>

<p>该正则表达式用于匹配IPv4地址，其具体含义如下：</p>
<ul>
<li><code>([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])</code>：匹配0-255之间的数字。</li>
<li><code>\\.</code>：匹配<code>.</code>字符。</li>
<li><code>(…)&#123;3&#125;</code>：匹配前面的表达式3次。</li>
<li><code>([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])</code>：匹配0-255之间的数字。</li>
</ul>
<p>因此，该正则表达式匹配的字符串是由四个数字组成，每个数字之间用<code>.</code>分隔，其中每个数字的取值范围是0-255。</p>
<p>正则表达式<code>([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])</code>是用来匹配IPv4地址中每个数字的取值范围的。IPv4地址中每个数字的取值范围是0-255，因此该正则表达式用来匹配这个范围内的数字。</p>
<p>该正则表达式中，每个<code>|</code>符号分隔的部分都表示一个数字的取值范围，具体解释如下：</p>
<ul>
<li><code>[0-9]</code>：匹配0-9之间的单个数字。</li>
<li><code>[1-9][0-9]</code>：匹配10-99之间的数字。</li>
<li><code>1[0-9][0-9]</code>：匹配100-199之间的数字。</li>
<li><code>2[0-4][0-9]</code>：匹配200-249之间的数字。</li>
<li><code>25[0-5]</code>：匹配250-255之间的数字。</li>
</ul>
<p>因此，这些部分组合在一起，就能够匹配0-255之间的数字。例如，<code>23</code>、<code>128</code>、<code>199</code>、<code>245</code>、<code>255</code>都是符合该正则表达式的数字。</p>
</blockquote>
<h3 id="IPv6正则表达式解释："><a href="#IPv6正则表达式解释：" class="headerlink" title="IPv6正则表达式解释："></a>IPv6正则表达式解释：</h3><blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">([0-9a-fA-F]&#123;1,4&#125;\\:)&#123;7&#125;[0-9a-fA-F]&#123;1,4&#125;</span><br></pre></td></tr></table></figure>

<p>该正则表达式用于匹配IPv6地址，其具体含义如下：</p>
<ul>
<li><code>([0-9a-fA-F]&#123;1,4&#125;\\:)&#123;7&#125;</code>：匹配由7组数字和冒号组成的字符串，每组数字的长度为1-4个字符，中间用<code>:</code>分隔。</li>
<li><code>[0-9a-fA-F]&#123;1,4&#125;</code>：匹配长度为1-4个字符的数字和字母。</li>
</ul>
<p>因此，该正则表达式匹配的字符串是由8组数字和冒号组成，其中每组数字的长度为1-4个字符，中间用<code>:</code>分隔。每组数字的取值范围是0-9和a-f（大小写不区分）。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证IP地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> IP string字符串 一个IP地址字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">solve</span> <span class="params">(String IP)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">ipv4</span> <span class="operator">=</span> <span class="string">&quot;(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.)&#123;3&#125;([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])&quot;</span>;</span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">ipv4_pattern</span> <span class="operator">=</span> Pattern.compile(ipv4);</span><br><span class="line">        <span class="type">String</span> <span class="variable">ipv6</span> <span class="operator">=</span> <span class="string">&quot;([0-9a-fA-F]&#123;1,4&#125;\\:)&#123;7&#125;[0-9a-fA-F]&#123;1,4&#125;&quot;</span>;</span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">ipv6_pattern</span> <span class="operator">=</span> Pattern.compile(ipv6);</span><br><span class="line">        <span class="keyword">if</span>(ipv4_pattern.matcher(IP).matches())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;IPv4&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ipv6_pattern.matcher(IP).matches())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;IPv6&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Neither&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O*(<em>n</em>)，regex_match函数默认O*(<em>n</em>)</li>
<li>空间复杂度：<em>O</em>(1)，没有使用额外空间</li>
</ul>
<h2 id="BM86-大数加法"><a href="#BM86-大数加法" class="headerlink" title="BM86 大数加法"></a><strong>BM86</strong> <strong>大数加法</strong></h2><p>以字符串的形式读入两个数字，编写一个函数计算它们的和，以字符串形式返回。</p>
<p>数据范围：�.�����ℎ,�.�����ℎ≤100000<em>s</em>.<em>l<strong>e</strong>n<strong>g</strong>t**h</em>,<em>t</em>.<em>l<strong>e</strong>n<strong>g</strong>t**h</em>≤100000，字符串仅由’0’~‘9’构成</p>
<p>要求：时间复杂度 �(�)<em>O</em>(<em>n</em>)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;1&quot;,&quot;99&quot;</span><br><span class="line">返回值：&quot;100&quot;</span><br></pre></td></tr></table></figure>

<h3 id="思路：模拟法"><a href="#思路：模拟法" class="headerlink" title="思路：模拟法"></a>思路：模拟法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * 计算两个数之和</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s string字符串 表示第一个整数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t string字符串 表示第二个整数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">solve</span> <span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">//若是其中一个为空，返回另一个</span></span><br><span class="line">        <span class="keyword">if</span>(s.length() &lt;= <span class="number">0</span>) <span class="keyword">return</span> t;</span><br><span class="line">        <span class="keyword">if</span>(t.length() &lt;= <span class="number">0</span>) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//让s为较长的，t为较短的</span></span><br><span class="line">        <span class="keyword">if</span>(s.length() &lt; t.length())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> s;</span><br><span class="line">            s = t;</span><br><span class="line">            t = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//进位标志</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="comment">//从后往前遍历较长的字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length()-<span class="number">1</span> ; i &gt;= <span class="number">0</span> ;i--)&#123;</span><br><span class="line">            <span class="comment">//转数字加上进位</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> s.charAt(i) - <span class="string">&#x27;0&#x27;</span> + carry;</span><br><span class="line">            <span class="comment">//转较短的字符串相应的从后往前的下标</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - s.length() + t.length();</span><br><span class="line">            <span class="comment">//如果较短字符串还有</span></span><br><span class="line">            <span class="keyword">if</span>( j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//转数组相加</span></span><br><span class="line">                temp += t.charAt(j) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//取进位</span></span><br><span class="line">            carry = temp/<span class="number">10</span>;</span><br><span class="line">            <span class="comment">//去十位</span></span><br><span class="line">            temp = temp %<span class="number">10</span>;</span><br><span class="line">            <span class="comment">//修改结果</span></span><br><span class="line">            res.append((<span class="type">char</span>)(temp+<span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry == <span class="number">1</span>)&#123;</span><br><span class="line">            res.append(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        res.reverse();</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：�(�)<em>O</em>(<em>n</em>)，其中�<em>n</em>为较长字符的长度，遍历字符串</li>
<li>空间复杂度：�(1)<em>O</em>(1)，常数级空间，没有使用额外辅助空间</li>
</ul>
<h1 id="十一、模拟"><a href="#十一、模拟" class="headerlink" title="十一、模拟"></a>十一、模拟</h1><h2 id="BM97-旋转数组"><a href="#BM97-旋转数组" class="headerlink" title="BM97 旋转数组"></a><strong>BM97</strong> <strong>旋转数组</strong></h2><blockquote>
<p>一个数组A中存有 n 个整数，在不允许使用另外数组的前提下，将每个整数循环向右移 M（ M &gt;&#x3D;0）个位置，即将A中的数据由（A0 A1 ……AN-1 ）变换为（AN-M …… AN-1 A0 A1 ……AN-M-1 ）（最后 M 个数循环移至最前面的 M 个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？</p>
<p>数据范围：0&lt;�≤1000&lt;<em>n</em>≤100，0≤�≤10000≤<em>m</em>≤1000</p>
<p>进阶：空间复杂度 �(1)<em>O</em>(1)，时间复杂度 �(�)<em>O</em>(<em>n</em>)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">6,2,[1,2,3,4,5,6]</span><br><span class="line">复制</span><br><span class="line">返回值：</span><br><span class="line">[5,6,1,2,3,4]</span><br></pre></td></tr></table></figure>

<h3 id="思路：模拟"><a href="#思路：模拟" class="headerlink" title="思路：模拟"></a>思路：模拟</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] solve (<span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span>[] a) &#123;</span><br><span class="line">        <span class="comment">//取余，因为每次长度为n的旋转数组相当于没有变化</span></span><br><span class="line">        m = m % n; </span><br><span class="line">        <span class="comment">//第一次逆转全部数组元素</span></span><br><span class="line">        reverse(a, <span class="number">0</span>, n - <span class="number">1</span>); </span><br><span class="line">        <span class="comment">//第二次只逆转开头m个</span></span><br><span class="line">        reverse(a, <span class="number">0</span>, m - <span class="number">1</span>); </span><br><span class="line">        <span class="comment">//第三次只逆转结尾m个</span></span><br><span class="line">        reverse(a, m, n - <span class="number">1</span>); </span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//反转函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span>&#123; </span><br><span class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">            swap(nums, start++, end--);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> a, <span class="type">int</span> b)</span>&#123; </span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[a];</span><br><span class="line">        nums[a] = nums[b];</span><br><span class="line">        nums[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O*(<em>n</em>)，三次reverse函数的复杂度都最坏为O*(<em>n</em>)</li>
<li>空间复杂度：O*(1)，没有使用额外的辅助空间</li>
</ul>
<h2 id="BM98-螺旋矩阵"><a href="#BM98-螺旋矩阵" class="headerlink" title="BM98 螺旋矩阵"></a><strong>BM98</strong> <strong>螺旋矩阵</strong></h2><h3 id="思路：直接模拟-1"><a href="#思路：直接模拟-1" class="headerlink" title="思路：直接模拟"></a>思路：直接模拟</h3><p>处理好边界条件即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123;</span><br><span class="line">        List&lt;Integer&gt; order = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) &#123;</span><br><span class="line">            return order;</span><br><span class="line">        &#125;</span><br><span class="line">        int rows = matrix.length, columns = matrix[0].length;</span><br><span class="line">        int left = 0, right = columns - 1, top = 0, bottom = rows - 1;</span><br><span class="line">        while (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;</span><br><span class="line">            for (int column = left; column &lt;= right; column++) &#123;</span><br><span class="line">                order.add(matrix[top][column]);</span><br><span class="line">            &#125;</span><br><span class="line">            for (int row = top + 1; row &lt;= bottom; row++) &#123;</span><br><span class="line">                order.add(matrix[row][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            if (left &lt; right &amp;&amp; top &lt; bottom) &#123;</span><br><span class="line">                for (int column = right - 1; column &gt; left; column--) &#123;</span><br><span class="line">                    order.add(matrix[bottom][column]);</span><br><span class="line">                &#125;</span><br><span class="line">                for (int row = bottom; row &gt; top; row--) &#123;</span><br><span class="line">                    order.add(matrix[row][left]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">            top++;</span><br><span class="line">            bottom--;</span><br><span class="line">        &#125;</span><br><span class="line">        return order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM99-顺时针旋转矩阵"><a href="#BM99-顺时针旋转矩阵" class="headerlink" title="BM99 顺时针旋转矩阵"></a><strong>BM99</strong> <strong>顺时针旋转矩阵</strong></h2><h3 id="思路：矩阵转置-矩阵反转"><a href="#思路：矩阵转置-矩阵反转" class="headerlink" title="思路：矩阵转置+矩阵反转"></a>思路：矩阵转置+矩阵反转</h3><p><img src="https://picgooo.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2023-05-04%2020.44.46.png" alt="截屏2023-05-04 20.44.46"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] rotateMatrix(<span class="type">int</span>[][] mat, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> mat.length;</span><br><span class="line">        <span class="comment">//矩阵转置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; ++j)&#123;</span><br><span class="line">                <span class="comment">//交换上三角与下三角对应的元素</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> mat[i][j];</span><br><span class="line">                mat[i][j] = mat[j][i];</span><br><span class="line">                mat[j][i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每行翻转</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; length/<span class="number">2</span>; j++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> mat[i][j];</span><br><span class="line">                mat[i][j] = mat[i][length - j - <span class="number">1</span>];</span><br><span class="line">                mat[i][length - j - <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：<em>O</em>(<em>n</em>2)，转置需要遍历矩阵，逐行翻转也是O*(<em>n</em>2)</li>
<li>空间复杂度：O*(1)，常数级变量，没有使用额外辅助空间</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
              <a href="/tags/%E5%88%B7%E9%A2%98/" rel="tag"><i class="fa fa-tag"></i> 刷题</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/02/14/33-%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E5%87%BB/" rel="prev" title="剑指offer专项突击">
                  <i class="fa fa-chevron-left"></i> 剑指offer专项突击
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/03/13/35-%E5%85%AB%E8%82%A1%E8%AE%B0%E5%BD%95%E2%80%94%E2%80%94Java%E5%9F%BA%E7%A1%80/" rel="next" title="八股记录——Java基础部分">
                  八股记录——Java基础部分 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2021 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yann Cheung</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>Word count total: </span>
    <span title="Word count total">383k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>Reading time total &asymp;</span>
    <span title="Reading time total">5:48</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.3/jquery.min.js" integrity="sha256-pvPw+upLPUjgMXY0G+8O0xUf+/Im1MZjXxxgOcBQBXU=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>



  <script src="/js/third-party/fancybox.js"></script>


  





</body>
</html>
