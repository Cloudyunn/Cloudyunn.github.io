<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.14.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="一、链表BM1 反转链表 描述给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。  数据范围： 0≤n≤10000≤n≤1000 要求：空间复杂度 O(1)，时间复杂度 O(n)。  思路：迭代12345678910111213public class Solution &amp;#123;    public ListNode R">
<meta property="og:type" content="article">
<meta property="og:title" content="牛客必刷100题">
<meta property="og:url" content="http://example.com/2023/02/24/34-%E7%89%9B%E5%AE%A2%E5%BF%85%E5%88%B7100/index.html">
<meta property="og:site_name" content="Cloudyun">
<meta property="og:description" content="一、链表BM1 反转链表 描述给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。  数据范围： 0≤n≤10000≤n≤1000 要求：空间复杂度 O(1)，时间复杂度 O(n)。  思路：迭代12345678910111213public class Solution &amp;#123;    public ListNode R">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://picgooo.oss-cn-hangzhou.aliyuncs.com/img/D024AA6BA7A670402678A9ACAD54EB10.gif">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/files/20210621/908787715_1624289962297/36.gif">
<meta property="og:image" content="https://picgooo.oss-cn-hangzhou.aliyuncs.com/img/9EB9CD58B9EA5E04C890326B5C1F471F.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/1614274007-rtFHbG-Picture2.png">
<meta property="og:image" content="https://picgooo.oss-cn-hangzhou.aliyuncs.com/img/E1F1270919D292C9F48F51975FD07CE2.png">
<meta property="og:image" content="https://picgooo.oss-cn-hangzhou.aliyuncs.com/img/A22A794C036C06431E632F9D5E2E298F.png">
<meta property="og:image" content="https://picgooo.oss-cn-hangzhou.aliyuncs.com/img/63C9C80875EEB9DD09F51096A6752306.gif">
<meta property="og:image" content="https://picgooo.oss-cn-hangzhou.aliyuncs.com/img/4760A3E42ACB7E73D162BE2CD8C2E2C9.gif">
<meta property="article:published_time" content="2023-02-24T06:35:28.000Z">
<meta property="article:modified_time" content="2023-03-13T12:59:43.338Z">
<meta property="article:author" content="Yann Cheung">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="刷题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://picgooo.oss-cn-hangzhou.aliyuncs.com/img/D024AA6BA7A670402678A9ACAD54EB10.gif">


<link rel="canonical" href="http://example.com/2023/02/24/34-%E7%89%9B%E5%AE%A2%E5%BF%85%E5%88%B7100/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2023/02/24/34-%E7%89%9B%E5%AE%A2%E5%BF%85%E5%88%B7100/","path":"2023/02/24/34-牛客必刷100/","title":"牛客必刷100题"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>牛客必刷100题 | Cloudyun</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Cloudyun</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Yann Cheungの博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">18</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">5</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">34</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E9%93%BE%E8%A1%A8"><span class="nav-number">1.</span> <span class="nav-text">一、链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#BM1-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">1.1.</span> <span class="nav-text">BM1 反转链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%8F%E8%BF%B0"><span class="nav-number">1.2.</span> <span class="nav-text">描述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E8%BF%AD%E4%BB%A3"><span class="nav-number">1.2.1.</span> <span class="nav-text">思路：迭代</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM2-%E9%93%BE%E8%A1%A8%E5%86%85%E6%8C%87%E5%AE%9A%E5%8C%BA%E9%97%B4%E5%8F%8D%E8%BD%AC"><span class="nav-number">1.3.</span> <span class="nav-text">BM2 链表内指定区间反转</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E4%B8%80%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="nav-number">1.3.1.</span> <span class="nav-text">思路：一次遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM3-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%E6%AF%8Fk%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC"><span class="nav-number">1.4.</span> <span class="nav-text">BM3 链表中的节点每k个一组翻转</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E9%80%92%E5%BD%92"><span class="nav-number">1.4.1.</span> <span class="nav-text">思路：递归</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM4-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8"><span class="nav-number">1.5.</span> <span class="nav-text">BM4 合并两个排序的链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E9%80%92%E5%BD%92-1"><span class="nav-number">1.5.1.</span> <span class="nav-text">思路：递归</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM6-%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E4%B8%AD%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF"><span class="nav-number">1.6.</span> <span class="nav-text">BM6 判断链表中是否有环</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88"><span class="nav-number">1.6.1.</span> <span class="nav-text">思路：快慢指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM7-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9"><span class="nav-number">1.7.</span> <span class="nav-text">BM7 链表中环的入口结点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88-1"><span class="nav-number">1.7.1.</span> <span class="nav-text">思路：快慢指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM8-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E6%9C%80%E5%90%8Ek%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="nav-number">1.8.</span> <span class="nav-text">BM8 链表中倒数最后k个结点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88-2"><span class="nav-number">1.8.1.</span> <span class="nav-text">思路：快慢指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM9-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="nav-number">1.9.</span> <span class="nav-text">BM9 删除链表的倒数第n个节点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88-3"><span class="nav-number">1.9.1.</span> <span class="nav-text">思路：快慢指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM10-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9"><span class="nav-number">1.10.</span> <span class="nav-text">BM10 两个链表的第一个公共结点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-number">1.10.1.</span> <span class="nav-text">思路：双指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM11-%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%8A%A0-%E4%BA%8C"><span class="nav-number">1.11.</span> <span class="nav-text">BM11 链表相加(二)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E7%9B%B4%E6%8E%A5%E6%A8%A1%E6%8B%9F"><span class="nav-number">1.11.1.</span> <span class="nav-text">思路：直接模拟</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM12-%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8E%92%E5%BA%8F"><span class="nav-number">1.12.</span> <span class="nav-text">BM12 单链表的排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F"><span class="nav-number">1.12.1.</span> <span class="nav-text">思路：转化为数组排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM13-%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E4%B8%BA%E5%9B%9E%E6%96%87%E7%BB%93%E6%9E%84"><span class="nav-number">1.13.</span> <span class="nav-text">BM13 判断一个链表是否为回文结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E9%80%90%E4%B8%80%E5%88%A4%E6%96%AD"><span class="nav-number">1.13.1.</span> <span class="nav-text">思路：反转链表逐一判断</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM14-%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A5%87%E5%81%B6%E9%87%8D%E6%8E%92"><span class="nav-number">1.14.</span> <span class="nav-text">BM14 链表的奇偶重排</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%8F%E8%BF%B0-1"><span class="nav-number">1.15.</span> <span class="nav-text">描述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%8F%8C%E6%8C%87%E9%92%88-1"><span class="nav-number">1.15.1.</span> <span class="nav-text">思路：双指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM15-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E5%85%83%E7%B4%A0-I"><span class="nav-number">1.16.</span> <span class="nav-text">BM15 删除有序链表中重复的元素-I</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E9%81%8D%E5%8E%86"><span class="nav-number">1.16.1.</span> <span class="nav-text">思路：遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM16-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E5%85%83%E7%B4%A0-II"><span class="nav-number">1.17.</span> <span class="nav-text">BM16 删除有序链表中重复的元素-II</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E9%81%8D%E5%8E%86-1"><span class="nav-number">1.17.1.</span> <span class="nav-text">思路：遍历</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-number">2.</span> <span class="nav-text">二、二分查找</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#BM17-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-I"><span class="nav-number">2.1.</span> <span class="nav-text">BM17 二分查找-I</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM18-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="nav-number">2.2.</span> <span class="nav-text">BM18 二维数组中的查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-number">2.2.1.</span> <span class="nav-text">思路：二分查找</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM19-%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC"><span class="nav-number">2.3.</span> <span class="nav-text">BM19 寻找峰值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-1"><span class="nav-number">2.3.1.</span> <span class="nav-text">思路：二分查找</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM20-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9"><span class="nav-number">2.4.</span> <span class="nav-text">BM20 数组中的逆序对</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">2.4.1.</span> <span class="nav-text">思路：归并排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM21-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97"><span class="nav-number">2.5.</span> <span class="nav-text">BM21 旋转数组的最小数字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-2"><span class="nav-number">2.5.1.</span> <span class="nav-text">思路：二分查找</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM22-%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7"><span class="nav-number">2.6.</span> <span class="nav-text">BM22 比较版本号</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%8F%8C%E6%8C%87%E9%92%88-2"><span class="nav-number">2.6.1.</span> <span class="nav-text">思路：双指针</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">3.</span> <span class="nav-text">三、二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#BM23-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">3.1.</span> <span class="nav-text">BM23 二叉树的前序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E9%80%92%E5%BD%92-2"><span class="nav-number">3.1.1.</span> <span class="nav-text">思路：递归</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM24-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">3.2.</span> <span class="nav-text">BM24 二叉树的中序遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM25-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">3.3.</span> <span class="nav-text">BM25 二叉树的后序遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM26-%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">3.4.</span> <span class="nav-text">BM26 求二叉树的层序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9ABFS%EF%BC%88%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%89"><span class="nav-number">3.4.1.</span> <span class="nav-text">思路：BFS（广度优先搜索）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM27-%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">3.5.</span> <span class="nav-text">BM27 按之字形顺序打印二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9ABFS"><span class="nav-number">3.6.</span> <span class="nav-text">思路：BFS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM28-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="nav-number">3.7.</span> <span class="nav-text">BM28 二叉树的最大深度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E9%80%92%E5%BD%92-3"><span class="nav-number">3.7.1.</span> <span class="nav-text">思路：递归</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM29-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84-%E4%B8%80"><span class="nav-number">3.8.</span> <span class="nav-text">BM29 二叉树中和为某一值的路径(一)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E9%80%92%E5%BD%92-4"><span class="nav-number">3.8.1.</span> <span class="nav-text">思路：递归</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM30-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="nav-number">3.9.</span> <span class="nav-text">BM30 二叉搜索树与双向链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%88%A9%E7%94%A8%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%89%B9%E5%BE%81%E8%BF%9B%E8%A1%8C%E9%80%92%E5%BD%92"><span class="nav-number">3.9.1.</span> <span class="nav-text">思路：利用二叉搜索树的特征进行递归</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM31-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">3.10.</span> <span class="nav-text">BM31 对称的二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E9%80%92%E5%BD%92-5"><span class="nav-number">3.10.1.</span> <span class="nav-text">思路：递归</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM32-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">3.11.</span> <span class="nav-text">BM32 合并二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E9%80%92%E5%BD%92-6"><span class="nav-number">3.11.1.</span> <span class="nav-text">思路：递归</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM33-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F"><span class="nav-number">3.12.</span> <span class="nav-text">BM33 二叉树的镜像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM34-%E5%88%A4%E6%96%AD%E6%98%AF%E4%B8%8D%E6%98%AF%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">3.13.</span> <span class="nav-text">BM34 判断是不是二叉搜索树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM35-%E5%88%A4%E6%96%AD%E6%98%AF%E4%B8%8D%E6%98%AF%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">3.14.</span> <span class="nav-text">BM35 判断是不是完全二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86BFS"><span class="nav-number">3.14.1.</span> <span class="nav-text">思路：层序遍历BFS</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM36-%E5%88%A4%E6%96%AD%E6%98%AF%E4%B8%8D%E6%98%AF%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">3.15.</span> <span class="nav-text">BM36 判断是不是平衡二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E4%BB%8E%E5%BA%95%E8%87%B3%E9%A1%B6"><span class="nav-number">3.15.1.</span> <span class="nav-text">思路：从底至顶</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM37-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">3.16.</span> <span class="nav-text">BM37 二叉搜索树的最近公共祖先</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E9%81%8D%E5%8E%86-2"><span class="nav-number">3.16.1.</span> <span class="nav-text">思路：遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM38-%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%BE%E5%88%B0%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">3.17.</span> <span class="nav-text">BM38 在二叉树中找到两个节点的最近公共祖先</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%9B%9E%E6%BA%AF-DFS"><span class="nav-number">3.17.1.</span> <span class="nav-text">思路：回溯+DFS</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM40-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">3.18.</span> <span class="nav-text">BM40 重建二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM41-%E8%BE%93%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE"><span class="nav-number">3.19.</span> <span class="nav-text">BM41 输出二叉树的右视图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM42-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="nav-number">3.20.</span> <span class="nav-text">BM42 用两个栈实现队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E6%A0%88"><span class="nav-number">3.20.1.</span> <span class="nav-text">思路：栈</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM43-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88"><span class="nav-number">3.21.</span> <span class="nav-text">BM43 包含min函数的栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A"><span class="nav-number">3.21.1.</span> <span class="nav-text">思路：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM44-%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97"><span class="nav-number">3.22.</span> <span class="nav-text">BM44 有效括号序列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E6%A8%A1%E6%8B%9F%E6%A0%88"><span class="nav-number">3.22.1.</span> <span class="nav-text">思路：模拟栈</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM45-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="nav-number">3.23.</span> <span class="nav-text">BM45 滑动窗口的最大值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97"><span class="nav-number">3.23.1.</span> <span class="nav-text">思路：单调队列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM46-%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0"><span class="nav-number">3.24.</span> <span class="nav-text">BM46 最小的K个数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF1%EF%BC%9Asort%E5%BF%AB%E6%8E%92"><span class="nav-number">3.24.1.</span> <span class="nav-text">思路1：sort快排</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF2%EF%BC%9A%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="nav-number">3.25.</span> <span class="nav-text">思路2：堆排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM47-%E5%AF%BB%E6%89%BE%E7%AC%ACK%E5%A4%A7"><span class="nav-number">3.26.</span> <span class="nav-text">BM47 寻找第K大</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF1%EF%BC%9A%E9%9A%8F%E6%9C%BA%E9%80%89%E6%8B%A9"><span class="nav-number">3.26.1.</span> <span class="nav-text">思路1：随机选择</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF2%EF%BC%9A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95"><span class="nav-number">3.27.</span> <span class="nav-text">思路2：内置方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM48-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="nav-number">3.28.</span> <span class="nav-text">BM48 数据流中的中位数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97"><span class="nav-number">3.28.1.</span> <span class="nav-text">思路：优先级队列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM49-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="nav-number">3.29.</span> <span class="nav-text">BM49 表达式求值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM50-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">3.30.</span> <span class="nav-text">BM50 两数之和</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%93%88%E5%B8%8C"><span class="nav-number">3.30.1.</span> <span class="nav-text">思路：哈希</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM51-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number">3.31.</span> <span class="nav-text">BM51 数组中出现次数超过一半的数字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%93%88%E5%B8%8C-1"><span class="nav-number">3.31.1.</span> <span class="nav-text">思路：哈希</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM52-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97"><span class="nav-number">3.32.</span> <span class="nav-text">BM52 数组中只出现一次的两个数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM53-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B4%E6%95%B0"><span class="nav-number">3.33.</span> <span class="nav-text">BM53 缺失的第一个正整数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM-54-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">3.34.</span> <span class="nav-text">BM 54 三数之和</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E6%8E%92%E5%BA%8F-%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-number">3.34.1.</span> <span class="nav-text">思路：排序+双指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM55-%E6%B2%A1%E6%9C%89%E9%87%8D%E5%A4%8D%E9%A1%B9%E6%95%B0%E5%AD%97%E7%9A%84%E5%85%A8%E6%8E%92%E5%88%97"><span class="nav-number">3.35.</span> <span class="nav-text">BM55 没有重复项数字的全排列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%9B%9E%E6%BA%AF"><span class="nav-number">3.35.1.</span> <span class="nav-text">思路：回溯</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM56-%E6%9C%89%E9%87%8D%E5%A4%8D%E9%A1%B9%E6%95%B0%E5%AD%97%E7%9A%84%E5%85%A8%E6%8E%92%E5%88%97"><span class="nav-number">3.36.</span> <span class="nav-text">BM56 有重复项数字的全排列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%9B%9E%E6%BA%AF-1"><span class="nav-number">3.36.1.</span> <span class="nav-text">思路：回溯</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM57-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F"><span class="nav-number">3.37.</span> <span class="nav-text">BM57 岛屿数量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9Adfs"><span class="nav-number">3.37.1.</span> <span class="nav-text">思路：dfs</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM58-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97"><span class="nav-number">3.38.</span> <span class="nav-text">BM58 字符串的排列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%9B%9E%E6%BA%AF-2"><span class="nav-number">3.38.1.</span> <span class="nav-text">思路：回溯</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM60-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90"><span class="nav-number">3.39.</span> <span class="nav-text">BM60 括号生成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM61-%E7%9F%A9%E9%98%B5%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84"><span class="nav-number">3.40.</span> <span class="nav-text">BM61 矩阵最长递增路径</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E8%AE%B0%E5%BF%86%E6%90%9C%E7%B4%A2"><span class="nav-number">3.40.1.</span> <span class="nav-text">思路：记忆搜索</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yann Cheung"
      src="/images/avatar.JPG">
  <p class="site-author-name" itemprop="name">Yann Cheung</p>
  <div class="site-description" itemprop="description">忆我少年游，一梦到华胥</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Cloudyunn" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Cloudyunn" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="Back to top">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/24/34-%E7%89%9B%E5%AE%A2%E5%BF%85%E5%88%B7100/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.JPG">
      <meta itemprop="name" content="Yann Cheung">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cloudyun">
      <meta itemprop="description" content="忆我少年游，一梦到华胥">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="牛客必刷100题 | Cloudyun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          牛客必刷100题
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-02-24 14:35:28" itemprop="dateCreated datePublished" datetime="2023-02-24T14:35:28+08:00">2023-02-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-03-13 20:59:43" itemprop="dateModified" datetime="2023-03-13T20:59:43+08:00">2023-03-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>58k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>52 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="一、链表"><a href="#一、链表" class="headerlink" title="一、链表"></a>一、链表</h1><h2 id="BM1-反转链表"><a href="#BM1-反转链表" class="headerlink" title="BM1 反转链表"></a><strong>BM1</strong> <strong>反转链表</strong></h2><blockquote>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。 </p>
<p>数据范围： 0≤n≤10000≤<em>n</em>≤1000</p>
<p>要求：空间复杂度 O(1)，时间复杂度 O(n)。</p>
</blockquote>
<h3 id="思路：迭代"><a href="#思路：迭代" class="headerlink" title="思路：迭代"></a>思路：迭代</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">ReverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> curr.next;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="BM2-链表内指定区间反转"><a href="#BM2-链表内指定区间反转" class="headerlink" title="BM2 链表内指定区间反转"></a><strong>BM2</strong> <strong>链表内指定区间反转</strong></h2><blockquote>
<p>将一个节点数为 size 链表 m 位置到 n 位置之间的区间反转，要求时间复杂度 O(n)<em>O</em>(<em>n</em>)，空间复杂度 O(1)<em>O</em>(1)。<br>例如：<br>给出的链表为 1→2→3→4→5→NULL1→2→3→4→5→<em>N<strong>U</strong>L**L</em>, m&#x3D;2,n&#x3D;4<em>m</em>&#x3D;2,<em>n</em>&#x3D;4,<br>返回 1→4→3→2→5→NULL1→4→3→2→5→<em>N<strong>U</strong>L**L</em>.</p>
</blockquote>
<h3 id="思路：一次遍历"><a href="#思路：一次遍历" class="headerlink" title="思路：一次遍历"></a>思路：一次遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span> <span class="params">(ListNode head, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        dummyNode.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummyNode;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; m-<span class="number">1</span> ; i++)&#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> pre.next;</span><br><span class="line">        ListNode cur_next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n-m;i++)&#123;</span><br><span class="line">            cur_next = cur.next;</span><br><span class="line">            cur.next = cur_next.next;</span><br><span class="line">            cur_next.next = pre.next;</span><br><span class="line">            pre.next = cur_next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM3-链表中的节点每k个一组翻转"><a href="#BM3-链表中的节点每k个一组翻转" class="headerlink" title="BM3 链表中的节点每k个一组翻转"></a><strong>BM3</strong> <strong>链表中的节点每k个一组翻转</strong></h2><blockquote>
<p>将给出的链表中的节点每 k 个一组翻转，返回翻转后的链表<br>如果链表中的节点数不是 k 的倍数，将最后剩下的节点保持原样<br>你不能更改节点中的值，只能更改节点本身。 </p>
<p>数据范围： 0≤n≤2000 0≤<em>n</em>≤2000 ， 1≤k≤20001≤<em>k</em>≤2000 ，链表中每个元素都满足 0≤val≤10000≤<em>v<strong>a</strong>l</em>≤1000<br>要求空间复杂度 O(1)<em>O</em>(1)，时间复杂度 O(n)<em>O</em>(<em>n</em>)</p>
<p>例如： </p>
<p>给定的链表是 1→2→3→4→5</p>
<p>对于 k&#x3D;2, 你应该返回 2→1→4→3→5</p>
<p>对于 k&#x3D;3 , 你应该返回 3→2→1→4→5</p>
</blockquote>
<h3 id="思路：递归"><a href="#思路：递归" class="headerlink" title="思路：递归"></a>思路：递归</h3><p><img src="https://picgooo.oss-cn-hangzhou.aliyuncs.com/img/D024AA6BA7A670402678A9ACAD54EB10.gif"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span> <span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; k ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tail == <span class="literal">null</span>)    <span class="keyword">return</span> head;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(cur != tail)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next  = pre;</span><br><span class="line">            pre =cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        head.next = reverseKGroup(tail,k);</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM4-合并两个排序的链表"><a href="#BM4-合并两个排序的链表" class="headerlink" title="BM4 合并两个排序的链表"></a><strong>BM4</strong> <strong>合并两个排序的链表</strong></h2><blockquote>
<p>输入两个递增的链表，单个链表的长度为n，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>
<p>数据范围： 0≤n≤10000≤<em>n</em>≤1000，−1000≤节点值≤1000−1000≤节点值≤1000<br>要求：空间复杂度 O(1，时间复杂度 O(n)</p>
</blockquote>
<h3 id="思路：递归-1"><a href="#思路：递归-1" class="headerlink" title="思路：递归"></a>思路：递归</h3><p>这个题递归最容易理解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> &#123;</span><br><span class="line">        <span class="comment">// list1 list2为空的情况</span></span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="literal">null</span> || list2 == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list1 != <span class="literal">null</span> ? list1 : list2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 两个链表元素依次对比</span></span><br><span class="line">        <span class="keyword">if</span>(list1.val &lt;= list2.val)&#123;</span><br><span class="line">            <span class="comment">// 递归计算 list1.next, list2</span></span><br><span class="line">            list1.next = Merge(list1.next, list2);</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 递归计算 list1, list2.next</span></span><br><span class="line">            list2.next = Merge(list1, list2.next);</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM6-判断链表中是否有环"><a href="#BM6-判断链表中是否有环" class="headerlink" title="BM6 判断链表中是否有环"></a><strong>BM6</strong> <strong>判断链表中是否有环</strong></h2><blockquote>
<p>判断给定的链表中是否有环。如果有环则返回true，否则返回false。</p>
<p>数据范围：链表长度 0≤n≤10000，链表中任意节点的值满足 ∣val∣&lt;&#x3D;100000</p>
</blockquote>
<h3 id="思路：快慢指针"><a href="#思路：快慢指针" class="headerlink" title="思路：快慢指针"></a>思路：快慢指针</h3><p>如果有回环，快慢指针肯定会相遇</p>
<p>时间复杂度：O（N）</p>
<p>空间复杂度：O（1）</p>
<p>还有一种思路：使用HashSet来存节点，看是否用重复的就行，但这种方法的空间复杂度是O（N）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//先判断链表为空的情况</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//快慢双指针</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head; </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//如果没环快指针会先到链表尾</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>)&#123; </span><br><span class="line">            <span class="comment">//快指针移动两步</span></span><br><span class="line">            fast = fast.next.next; </span><br><span class="line">            <span class="comment">//慢指针移动一步</span></span><br><span class="line">            slow = slow.next; </span><br><span class="line">            <span class="comment">//相遇则有环</span></span><br><span class="line">            <span class="keyword">if</span>(fast == slow) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//到末尾则没有环</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM7-链表中环的入口结点"><a href="#BM7-链表中环的入口结点" class="headerlink" title="BM7 链表中环的入口结点"></a><strong>BM7</strong> <strong>链表中环的入口结点</strong></h2><blockquote>
<p>给一个长度为n链表，若其中包含环，请找出该链表的环的入口结点，否则，返回null。 </p>
<p>数据范围： n≤10000，1&lt;&#x3D;结点值&lt;&#x3D;10000</p>
<p>要求：空间复杂度 O(1)，时间复杂度 O(n)</p>
</blockquote>
<h3 id="思路：快慢指针-1"><a href="#思路：快慢指针-1" class="headerlink" title="思路：快慢指针"></a>思路：快慢指针</h3><p>经典题目，主要在于数学推导部分。</p>
<p>可以直接背一下～</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head,fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span>(fast.next != <span class="literal">null</span>)&#123;</span><br><span class="line">                fast = fast.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow )&#123;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">ptr</span> <span class="operator">=</span> head;</span><br><span class="line">                <span class="keyword">while</span>(ptr != slow)&#123;</span><br><span class="line">                    ptr = ptr.next;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM8-链表中倒数最后k个结点"><a href="#BM8-链表中倒数最后k个结点" class="headerlink" title="BM8 链表中倒数最后k个结点"></a><strong>BM8</strong> <strong>链表中倒数最后k个结点</strong></h2><blockquote>
<p>输入一个长度为 n 的链表，设链表中的元素的值为 ai ，返回该链表中倒数第k个节点。 </p>
<p>如果该链表长度小于k，请返回一个长度为 0 的链表。 </p>
<p>要求：空间复杂度 O(n)，时间复杂度 O(n)</p>
<p>进阶：空间复杂度 O(1)，时间复杂度 O(n)</p>
</blockquote>
<h3 id="思路：快慢指针-2"><a href="#思路：快慢指针-2" class="headerlink" title="思路：快慢指针"></a>思路：快慢指针</h3><p>要得到倒数第k个，就可以声明两个指针</p>
<p>第一个指针先走k步，然后两个指针再一起走，等到第一个指针为null的时候，第二个指针即为倒数第k个节点</p>
<p>时间复杂度：O（N）</p>
<p>空间复杂度：O（1）</p>
<p>第二种空间复杂度为O（N）的思路就是使用栈就行～</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">FindKthToTail</span> <span class="params">(ListNode pHead, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> pHead;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> pHead;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; k ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span>)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM9-删除链表的倒数第n个节点"><a href="#BM9-删除链表的倒数第n个节点" class="headerlink" title="BM9 删除链表的倒数第n个节点"></a><strong>BM9</strong> <strong>删除链表的倒数第n个节点</strong></h2><blockquote>
<p>给定一个链表，删除链表的倒数第 n 个节点并返回链表的头指针</p>
<p>例如， </p>
<p>给出的链表为: 1→2→3→4→5, n&#x3D;2<br>删除了链表的倒数第 n个节点之后,链表变为1→2→3→5</p>
<p>数据范围： 链表长度 0≤n≤1000，链表中任意节点的值满足 0≤val≤100</p>
<p>要求：空间复杂度 O(1)，时间复杂度 O(n)</p>
<p>备注： </p>
<p>题目保证 n 一定是有效的</p>
</blockquote>
<h3 id="思路：快慢指针-3"><a href="#思路：快慢指针-3" class="headerlink" title="思路：快慢指针"></a>思路：快慢指针</h3><p>要求空间复杂度为O（1）。因此和上题一样的思路，但是和上题找到倒数第k个节点不同的是，这里需要删除，所以应该找到倒数k+1个节点，然后将它的next指向到倒数第k-1个节点。</p>
<p>所以很简单的思路就是把slow指向head的前面一个哑节点，也俗称dummyHead，这样的话不会造成越界～</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span> <span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span>dummyHead;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            fast = fast.next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span>)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow.next = slow.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM10-两个链表的第一个公共结点"><a href="#BM10-两个链表的第一个公共结点" class="headerlink" title="BM10 两个链表的第一个公共结点"></a><strong>BM10</strong> <strong>两个链表的第一个公共结点</strong></h2><blockquote>
<p>输入两个无环的单向链表，找出它们的第一个公共结点，如果没有公共节点则返回空。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的） </p>
<p>数据范围： n≤100<br>要求：空间复杂度 O(1)，时间复杂度 O(n)</p>
</blockquote>
<h3 id="思路：双指针"><a href="#思路：双指针" class="headerlink" title="思路：双指针"></a>思路：双指针</h3><p>很经典的一个题，很好理解。注意这里为什么判断条件是l1和l2是否相等，因为两个指针要么找到公共节点的时候相等，要么就是同时为null。</p>
<p><img src="https://uploadfiles.nowcoder.com/files/20210621/908787715_1624289962297/36.gif"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">l1</span> <span class="operator">=</span> pHead1, l2 = pHead2;</span><br><span class="line">        <span class="keyword">while</span>(l1 != l2)&#123;</span><br><span class="line">            l1 = (l1==<span class="literal">null</span>)?pHead2:l1.next;</span><br><span class="line">            l2 = (l2==<span class="literal">null</span>)?pHead1:l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM11-链表相加-二"><a href="#BM11-链表相加-二" class="headerlink" title="BM11 链表相加(二)"></a><strong>BM11</strong> <strong>链表相加(二)</strong></h2><blockquote>
<p>假设链表中每一个节点的值都在 0 - 9 之间，那么链表整体就可以代表一个整数。 </p>
<p>给定两个这种链表，请生成代表两个整数相加值的结果链表。 </p>
<p>数据范围：0≤n,m≤1000000，链表任意值 0≤val≤9<br>要求：空间复杂度 O(n))，时间复杂度 O(n)</p>
<p>例如：链表 1 为 9-&gt;3-&gt;7，链表 2 为 6-&gt;3，最后生成新的结果链表为 1-&gt;0-&gt;0-&gt;0。</p>
</blockquote>
<h3 id="思路：直接模拟"><a href="#思路：直接模拟" class="headerlink" title="思路：直接模拟"></a>思路：直接模拟</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">addInList</span> <span class="params">(ListNode head1, ListNode head2)</span> &#123;</span><br><span class="line">        <span class="comment">// 进行判空处理</span></span><br><span class="line">        <span class="keyword">if</span>(head1 == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head2;</span><br><span class="line">        <span class="keyword">if</span>(head2 == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 反转h1链表</span></span><br><span class="line">        head1 = reverse(head1);</span><br><span class="line">        <span class="comment">// 反转h2链表</span></span><br><span class="line">        head2 = reverse(head2);</span><br><span class="line">        <span class="comment">// 创建新的链表头节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">nHead</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">// 记录进位的数值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head1 != <span class="literal">null</span> || head2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// val用来累加此时的数值（加数+加数+上一位的进位=当前总的数值）</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> tmp;</span><br><span class="line">            <span class="comment">// 当节点不为空的时候，则需要加上当前节点的值</span></span><br><span class="line">            <span class="keyword">if</span> (head1 != <span class="literal">null</span>) &#123;</span><br><span class="line">                val += head1.val;</span><br><span class="line">                head1 = head1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当节点不为空的时候，则需要加上当前节点的值</span></span><br><span class="line">            <span class="keyword">if</span> (head2 != <span class="literal">null</span>) &#123;</span><br><span class="line">                val += head2.val;</span><br><span class="line">                head2 = head2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 求出进位</span></span><br><span class="line">            tmp = val/<span class="number">10</span>;</span><br><span class="line">            <span class="comment">// 进位后剩下的数值即为当前节点的数值</span></span><br><span class="line">            nHead.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(val%<span class="number">10</span>);</span><br><span class="line">            <span class="comment">// 下一个节点</span></span><br><span class="line">            nHead = nHead.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后当两条链表都加完的时候，进位不为0的时候，则需要再加上这个进位</span></span><br><span class="line">        <span class="keyword">if</span>(tmp &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            nHead.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重新反转回来返回</span></span><br><span class="line">        <span class="keyword">return</span> reverse(head.next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反转链表</span></span><br><span class="line">    ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = node;</span><br><span class="line">            node = cur;</span><br><span class="line">            cur = tail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O（N）</li>
<li>空间复杂度：O（1）</li>
</ul>
<h2 id="BM12-单链表的排序"><a href="#BM12-单链表的排序" class="headerlink" title="BM12 单链表的排序"></a><strong>BM12</strong> <strong>单链表的排序</strong></h2><blockquote>
<p>给定一个节点数为n的无序单链表，对其按升序排序。</p>
<p>数据范围：0&lt;n≤100000，保证节点权值在[−109,109][−109,109]之内。</p>
<p>要求：空间复杂度 O(n)，时间复杂度 O(nlogn)</p>
</blockquote>
<h3 id="思路：转化为数组排序"><a href="#思路：转化为数组排序" class="headerlink" title="思路：转化为数组排序"></a>思路：转化为数组排序</h3><p>链表不能按照下表进行访问，因此可以借用数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortInList</span> <span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; nums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>(); </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//遍历链表，将节点值加入数组</span></span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">null</span>)&#123; </span><br><span class="line">            nums.add(p.val);</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = head;</span><br><span class="line">        <span class="comment">//对数组元素排序</span></span><br><span class="line">        Collections.sort(nums); </span><br><span class="line">        <span class="comment">//遍历数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.size(); i++)&#123; </span><br><span class="line">            <span class="comment">//将数组元素依次加入链表</span></span><br><span class="line">            p.val = nums.get(i); </span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(nlog2n)，sort函数一般为优化后的快速排序，复杂度为O(nlog2n)</li>
<li>空间复杂度：O(n)，存储链表元素值的辅助数组长度n</li>
</ul>
<h2 id="BM13-判断一个链表是否为回文结构"><a href="#BM13-判断一个链表是否为回文结构" class="headerlink" title="BM13 判断一个链表是否为回文结构"></a><strong>BM13</strong> <strong>判断一个链表是否为回文结构</strong></h2><blockquote>
<p>给定一个链表，请判断该链表是否为回文结构。</p>
<p>回文是指该字符串正序逆序完全一致。 </p>
<p>数据范围： 链表节点数 0≤n≤1050≤<em>n</em>≤105，链表中每个节点的值满足 ∣val∣≤107∣<em>v<strong>a</strong>l</em>∣≤107</p>
</blockquote>
<h3 id="思路：反转链表逐一判断"><a href="#思路：反转链表逐一判断" class="headerlink" title="思路：反转链表逐一判断"></a>思路：反转链表逐一判断</h3><p>思路很清晰，找到中点，反转后逐一判断，需要注意的是奇数情况要考虑一下～</p>
<ul>
<li>时间复杂度：O（N），遍历链表</li>
<li>空间复杂度：O（1）</li>
</ul>
<p>还有一种更好理解的方法：将链表转化为list来做（只存数据大小），不过这种想法的空间复杂度为O（N）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* public class ListNode &#123;</span></span><br><span class="line"><span class="comment">*   int val;</span></span><br><span class="line"><span class="comment">*   ListNode next = null;</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> head ListNode类 the head</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPail</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">  ListNode q= head, p= head;</span><br><span class="line">  <span class="comment">//通过快慢指针找到中点</span></span><br><span class="line">  <span class="keyword">while</span> (q != <span class="literal">null</span> &amp;&amp; q.next != <span class="literal">null</span>) &#123;</span><br><span class="line">      q = q.next.next;</span><br><span class="line">      p = p.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果q不为空，说明链表的长度是奇数个</span></span><br><span class="line">  <span class="keyword">if</span> (q != <span class="literal">null</span>) &#123;</span><br><span class="line">      p = p.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//反转后半部分链表</span></span><br><span class="line">  p = reverse(p);</span><br><span class="line"></span><br><span class="line">  q = head;</span><br><span class="line">  <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//然后比较，判断节点值是否相等</span></span><br><span class="line">      <span class="keyword">if</span> (q.val != p.val)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      q = q.next;</span><br><span class="line">      p = p.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//反转链表</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">  <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> head.next;</span><br><span class="line">      head.next = prev;</span><br><span class="line">      prev = head;</span><br><span class="line">      head = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM14-链表的奇偶重排"><a href="#BM14-链表的奇偶重排" class="headerlink" title="BM14 链表的奇偶重排"></a><strong>BM14</strong> <strong>链表的奇偶重排</strong></h2><blockquote>
<h2 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h2><p>给定一个单链表，请设定一个函数，将链表的奇数位节点和偶数位节点分别放在一起，重排后输出。 </p>
<p>注意是节点的编号而非节点的数值。 </p>
<p>数据范围：节点数量满足 0≤n≤105，节点中的值都满足 0≤val≤1000</p>
<p>要求：空间复杂度 O(n)，时间复杂度 O(n)</p>
</blockquote>
<h3 id="思路：双指针-1"><a href="#思路：双指针-1" class="headerlink" title="思路：双指针"></a>思路：双指针</h3><p>定义一个双指针，一个指向奇数节点，一个指向偶数节点，遍历操作就好了～</p>
<ul>
<li>时间复杂度：O（N）</li>
<li>空间复杂度：O（1）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">oddEvenList</span> <span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//如果链表为空，不用重排</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) </span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">//even开头指向第二个节点，可能为空</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">even</span> <span class="operator">=</span> head.next; </span><br><span class="line">        <span class="comment">//odd开头指向第一个节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">odd</span> <span class="operator">=</span> head; </span><br><span class="line">        <span class="comment">//指向even开头</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">evenhead</span> <span class="operator">=</span> even; </span><br><span class="line">        <span class="keyword">while</span>(even != <span class="literal">null</span> &amp;&amp; even.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//odd连接even的后一个，即奇数位</span></span><br><span class="line">            odd.next = even.next; </span><br><span class="line">            <span class="comment">//odd进入后一个奇数位</span></span><br><span class="line">            odd = odd.next; </span><br><span class="line">            <span class="comment">//even连接后一个奇数的后一位，即偶数位</span></span><br><span class="line">            even.next = odd.next; </span><br><span class="line">            <span class="comment">//even进入后一个偶数位</span></span><br><span class="line">            even = even.next; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//even整体接在odd后面</span></span><br><span class="line">        odd.next = evenhead; </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM15-删除有序链表中重复的元素-I"><a href="#BM15-删除有序链表中重复的元素-I" class="headerlink" title="BM15 删除有序链表中重复的元素-I"></a><strong>BM15</strong> <strong>删除有序链表中重复的元素-I</strong></h2><blockquote>
<p>删除给出链表中的重复元素（链表中元素从小到大有序），使链表中的所有元素都只出现一次<br>例如：<br>给出的链表为1→1→2,返回1→2.<br>给出的链表为1→1→2→3→3,返回1→2→3 </p>
<p>数据范围：链表长度满足 0≤n≤100，链表中任意节点的值满足 ∣val∣≤100</p>
</blockquote>
<h3 id="思路：遍历"><a href="#思路：遍历" class="headerlink" title="思路：遍历"></a>思路：遍历</h3><p>很容易想到的一个思路，遇到相同的数据，保留第一个遇到的即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span> <span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//空链表</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//遍历指针</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head; </span><br><span class="line">        <span class="comment">//指针当前和下一位不为空</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span> &amp;&amp; cur.next != <span class="literal">null</span>)&#123; </span><br><span class="line">            <span class="comment">//如果当前与下一位相等则忽略下一位</span></span><br><span class="line">            <span class="keyword">if</span>(cur.val == cur.next.val) </span><br><span class="line">                cur.next = cur.next.next;</span><br><span class="line">            <span class="comment">//否则指针正常遍历</span></span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O（N）</li>
<li>空间复杂度：O（1）</li>
</ul>
<h2 id="BM16-删除有序链表中重复的元素-II"><a href="#BM16-删除有序链表中重复的元素-II" class="headerlink" title="BM16 删除有序链表中重复的元素-II"></a><strong>BM16</strong> <strong>删除有序链表中重复的元素-II</strong></h2><blockquote>
<p>给出一个升序排序的链表，删除链表中的<strong>所有</strong>重复出现的元素，只保留原链表中只出现一次的元素。<br>例如：<br>给出的链表为1→2→3→3→4→4→5, 返回1→2→5.<br>给出的链表为1→1→1→2→3, 返回2→3. </p>
<p>数据范围：链表长度 0≤n≤100000≤<em>n</em>≤10000，链表中的值满足 ∣val∣≤1000∣<em>v<strong>a</strong>l</em>∣≤1000</p>
<p>要求：空间复杂度 O(n)，时间复杂度 O(n)</p>
<p>进阶：空间复杂度 O(1)，时间复杂度 O(n)</p>
</blockquote>
<h3 id="思路：遍历-1"><a href="#思路：遍历-1" class="headerlink" title="思路：遍历"></a>思路：遍历</h3><p>注意，这个题和前面一题的不同之处在于：删除<span style='color:red'>所有的</span>相同元素</p>
<p>大部分逻辑和前面一个题一样～</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span> <span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//空链表</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//在链表前加一个表头</span></span><br><span class="line">        res.next = head; </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> res;</span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="literal">null</span> &amp;&amp; cur.next.next != <span class="literal">null</span>)&#123; </span><br><span class="line">            <span class="comment">//遇到相邻两个节点值相同</span></span><br><span class="line">            <span class="keyword">if</span>(cur.next.val == cur.next.next.val)&#123; </span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next.val;</span><br><span class="line">                <span class="comment">//将所有相同的都跳过</span></span><br><span class="line">                <span class="keyword">while</span> (cur.next != <span class="literal">null</span> &amp;&amp; cur.next.val == temp) </span><br><span class="line">                    cur.next = cur.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回时去掉表头</span></span><br><span class="line">        <span class="keyword">return</span> res.next; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O（N）</li>
<li>空间复杂度：O（1）</li>
</ul>
<h1 id="二、二分查找"><a href="#二、二分查找" class="headerlink" title="二、二分查找"></a>二、二分查找</h1><h2 id="BM17-二分查找-I"><a href="#BM17-二分查找-I" class="headerlink" title="BM17 二分查找-I"></a><strong>BM17</strong> <strong>二分查找-I</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span> <span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span> , right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM18-二维数组中的查找"><a href="#BM18-二维数组中的查找" class="headerlink" title="BM18 二维数组中的查找"></a><strong>BM18</strong> <strong>二维数组中的查找</strong></h2><blockquote>
<p>在一个二维数组array中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 </p>
<p>[ </p>
<p>[1,2,8,9],<br>[2,4,9,12],<br>[4,7,10,13],<br>[6,8,11,15]</p>
<p>] </p>
<p>给定 target &#x3D; 7，返回 true。 </p>
<p>给定 target &#x3D; 3，返回 false。 </p>
<p>数据范围：矩阵的长宽满足 0≤n,m≤500 ， 矩阵中的值满足 0≤val≤109<br>进阶：空间复杂度 O(1) ，时间复杂度 O(n+m)</p>
</blockquote>
<h3 id="思路：二分查找"><a href="#思路：二分查找" class="headerlink" title="思路：二分查找"></a>思路：二分查找</h3><p>首先看四个角，左上与右下必定为最小值与最大值，而左下与右上就有规律了：<strong>左下元素大于它上方的元素，小于它右方的元素，右上元素与之相反</strong>。既然左下角元素有这么一种规律，相当于将要查找的部分分成了一个大区间和小区间，每次与左下角元素比较，我们就知道目标值应该在哪部分中，于是可以利用分治思维来做。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">Find</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span> [][] array)</span> &#123;</span><br><span class="line">        <span class="comment">//优先判断特殊</span></span><br><span class="line">        <span class="keyword">if</span>(array.length == <span class="number">0</span>)  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> array.length;</span><br><span class="line">        <span class="keyword">if</span>(array[<span class="number">0</span>].length == <span class="number">0</span>)  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> array[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">//从最左下角的元素开始往左或往上</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>, j = <span class="number">0</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; m; )&#123; </span><br><span class="line">            <span class="comment">//元素较大，往上走</span></span><br><span class="line">            <span class="keyword">if</span>(array[i][j] &gt; target)   </span><br><span class="line">                i--;</span><br><span class="line">            <span class="comment">//元素较小，往右走</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(array[i][j] &lt; target) </span><br><span class="line">                j++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(m+n)，遍历矩阵的时候，最多经过矩阵的一行一列</li>
<li>空间复杂度：O(1)，常数级变量，无额外辅助空间</li>
</ul>
<h2 id="BM19-寻找峰值"><a href="#BM19-寻找峰值" class="headerlink" title="BM19 寻找峰值"></a><strong>BM19</strong> <strong>寻找峰值</strong></h2><blockquote>
<p>给定一个长度为n的数组nums，请你找到峰值并返回其索引。数组可能包含多个峰值，在这种情况下，返回任何一个所在位置即可。 </p>
<p>1.峰值元素是指其值严格大于左右相邻值的元素。严格大于即不能有等于</p>
<p>2.假设 nums[-1] &#x3D; nums[n] &#x3D; −∞−∞</p>
<p>3.对于所有有效的 i 都有 nums[i] !&#x3D; nums[i + 1] </p>
<p>4.你可以使用O(logN)的时间复杂度实现此问题吗？</p>
</blockquote>
<p><img src="https://picgooo.oss-cn-hangzhou.aliyuncs.com/img/9EB9CD58B9EA5E04C890326B5C1F471F.png"></p>
<h3 id="思路：二分查找-1"><a href="#思路：二分查找-1" class="headerlink" title="思路：二分查找"></a>思路：二分查找</h3><ul>
<li>nums[mid] &lt; nums[mid + 1]说明在“上坡”，则可以使left &#x3D; mid + 1（因为mid肯定不是峰值），向“峰”处压缩</li>
<li>nums[mid] &gt; nums[mid + 1]说明在“下坡”，则应该使right &#x3D; mid（mid可能是峰值），往“峰”处压缩</li>
</ul>
<p>虽然开始left和right之间可能有多个峰值，但是随着left和right不断逼近，最后两者之间一定会压缩到一个峰值上，因为两者都是向“峰”不断靠近的，但是不会超过<code>最终</code>的“峰”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findPeakElement</span> <span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//二分法</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123; </span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//右边是往上，一定有坡峰</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[mid + <span class="number">1</span>])</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//左边是往上，一定能找到波峰</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//其中一个波峰</span></span><br><span class="line">        <span class="keyword">return</span> right; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM20-数组中的逆序对"><a href="#BM20-数组中的逆序对" class="headerlink" title="BM20 数组中的逆序对"></a><strong>BM20</strong> <strong>数组中的逆序对</strong></h2><blockquote>
<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P mod 1000000007</p>
<p>要求：空间复杂度 O(n)，时间复杂度 O(nlogn)</p>
</blockquote>
<h3 id="思路：归并排序"><a href="#思路：归并排序" class="headerlink" title="思路：归并排序"></a>思路：归并排序</h3><p>归并排序」与「逆序对」是息息相关的。归并排序体现了 “分而治之” 的算法思想，具体为：</p>
<ul>
<li>分： 不断将数组从中点位置划分开（即二分法），将整个数组的排序问题转化为子数组的排序问题；</li>
<li>治： 划分到子数组长度为 1 时，开始向上合并，不断将 较短排序数组 合并为 较长排序数组，直至合并至原数组时完成排序；</li>
</ul>
<p><img src="https://pic.leetcode-cn.com/1614274007-rtFHbG-Picture2.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">InversePairs</span><span class="params">(<span class="type">int</span> [] array)</span> &#123;</span><br><span class="line">        <span class="comment">// 长度小于2则无逆序对</span></span><br><span class="line">        <span class="keyword">if</span>(array.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 进入归并</span></span><br><span class="line">        mergeSort(array,<span class="number">0</span>,array.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] array,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="comment">// 找分割点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="comment">// 左子数组</span></span><br><span class="line">            mergeSort(array,left,mid);</span><br><span class="line">            <span class="comment">// 右子数组</span></span><br><span class="line">            mergeSort(array,mid+<span class="number">1</span>,right);</span><br><span class="line">            <span class="comment">// 并</span></span><br><span class="line">            merge(array,left,mid,right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] array,<span class="type">int</span> left,<span class="type">int</span> mid,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="comment">// 创建临时数组，长度为此时两个子数组加起来的长度</span></span><br><span class="line">        <span class="type">int</span>[] arr =  <span class="keyword">new</span> <span class="title class_">int</span>[right-left+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 临时数组的下标起点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 保存在原数组的起点下标值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="comment">// 左子数组的起始指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="comment">// 右子数组的起始指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= mid &amp;&amp; r &lt;= right )&#123;</span><br><span class="line">            <span class="comment">// 当左子数组的当前元素小的时候，跳过，无逆序对</span></span><br><span class="line">            <span class="keyword">if</span>(array[l] &lt;= array[r])&#123;</span><br><span class="line">                <span class="comment">// 放入临时数组</span></span><br><span class="line">                arr[c] = array[l];</span><br><span class="line">                <span class="comment">// 临时数组下标+1</span></span><br><span class="line">                c++;</span><br><span class="line">                <span class="comment">// 左子数组指针右移</span></span><br><span class="line">                l++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">// 否则，此时存在逆序对</span></span><br><span class="line">                <span class="comment">// 放入临时数组</span></span><br><span class="line">                arr[c] = array[r];</span><br><span class="line">                <span class="comment">// 逆序对的个数为    左子数组的终点- 当前左子数组的当前指针</span></span><br><span class="line">                count += mid+<span class="number">1</span>-l;</span><br><span class="line">                count %= <span class="number">1000000007</span>;</span><br><span class="line">                <span class="comment">// 临时数组+1</span></span><br><span class="line">                c++;</span><br><span class="line">                <span class="comment">// 右子数组的指针右移</span></span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左子数组还有元素时，全部放入临时数组</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt;= mid)</span><br><span class="line">            arr[c++] = array[l++];</span><br><span class="line">        <span class="comment">// 右子数组还有元素时，全部放入临时数组</span></span><br><span class="line">        <span class="keyword">while</span>(r &lt;= right)</span><br><span class="line">            arr[c++] = array[r++];</span><br><span class="line">        <span class="comment">// 将临时数组中的元素放入到原数组的指定位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:arr)&#123;</span><br><span class="line">            array[s++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(NlogN)。归并排序的时间复杂度</li>
<li>空间复杂度：O(N)。临时数组的空间。</li>
</ul>
<h2 id="BM21-旋转数组的最小数字"><a href="#BM21-旋转数组的最小数字" class="headerlink" title="BM21 旋转数组的最小数字"></a><strong>BM21</strong> <strong>旋转数组的最小数字</strong></h2><blockquote>
<p>有一个长度为 n 的非降序数组，比如[1,2,3,4,5]，将它进行旋转，即把一个数组最开始的若干个元素搬到数组的末尾，变成一个旋转数组，比如变成了[3,4,5,1,2]，或者[4,5,1,2,3]这样的。请问，给定这样一个旋转数组，求数组中的最小值。</p>
<p>数据范围：1≤n≤10000，数组中任意元素的值: 0≤val≤10000</p>
<p>要求：空间复杂度：O(1) ，时间复杂度：O(logn)</p>
</blockquote>
<h3 id="思路：二分查找-2"><a href="#思路：二分查找-2" class="headerlink" title="思路：二分查找"></a>思路：二分查找</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minNumberInRotateArray</span><span class="params">(<span class="type">int</span> [] array)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//最小的数字在mid右边</span></span><br><span class="line">            <span class="keyword">if</span>(array[mid] &gt; array[right]) </span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//无法判断，一个一个试</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(array[mid] == array[right]) </span><br><span class="line">                right--;</span><br><span class="line">            <span class="comment">//最小数字要么是mid要么在mid左边</span></span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM22-比较版本号"><a href="#BM22-比较版本号" class="headerlink" title="BM22 比较版本号"></a><strong>BM22</strong> <strong>比较版本号</strong></h2><blockquote>
<p>牛客项目发布项目版本时会有版本号，比如1.02.11，2.14.4等等 </p>
<p>现在给你2个版本号version1和version2，请你比较他们的大小</p>
<p>版本号是由修订号组成，修订号与修订号之间由一个”.”连接。1个修订号可能有多位数字组成，修订号可能包含前导0，且是合法的。例如，1.02.11，0.1，0.2都是合法的版本号</p>
<p>每个版本号至少包含1个修订号。 </p>
<p>修订号从左到右编号，下标从0开始，最左边的修订号下标为0，下一个修订号下标为1，以此类推。 </p>
<p>比较规则： </p>
<p>一. 比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较忽略任何前导零后的整数值。比如”0.1”和”0.01”的版本号是相等的 </p>
<p>二. 如果版本号没有指定某个下标处的修订号，则该修订号视为0。例如，”1.1”的版本号小于”1.1.1”。因为”1.1”的版本号相当于”1.1.0”，第3位修订号的下标为0，小于1 </p>
<p>三. version1 &gt; version2 返回1，如果 version1 &lt; version2 返回-1，不然返回0.</p>
</blockquote>
<h3 id="思路：双指针-2"><a href="#思路：双指针-2" class="headerlink" title="思路：双指针"></a>思路：双指针</h3><ul>
<li>step 1：利用两个指针表示字符串的下标，分别遍历两个字符串。</li>
<li>step 2：每次截取点之前的数字字符组成数字，即在遇到一个点之前，直接取数字，加在前面数字乘10的后面。（因为int会溢出，这里采用long记录数字）</li>
<li>step 3：然后比较两个数字大小，根据大小关系返回1或者-1，如果全部比较完都无法比较出大小关系，则返回0.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span> <span class="params">(String version1, String version2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> version1.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> version2.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//直到某个字符串结束</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; n1 || j &lt; n2)&#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//从下一个点前截取数字</span></span><br><span class="line">            <span class="keyword">while</span>(i &lt; n1 &amp;&amp; version1.charAt(i) != <span class="string">&#x27;.&#x27;</span>)&#123; </span><br><span class="line">                num1 = num1 * <span class="number">10</span> + (version1.charAt(i) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//跳过点</span></span><br><span class="line">            i++; </span><br><span class="line">            <span class="type">long</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//从下一个点前截取数字</span></span><br><span class="line">            <span class="keyword">while</span>(j &lt; n2 &amp;&amp; version2.charAt(j) != <span class="string">&#x27;.&#x27;</span>)&#123; </span><br><span class="line">                num2 = num2 * <span class="number">10</span> + (version2.charAt(j) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//跳过点</span></span><br><span class="line">            j++; </span><br><span class="line">            <span class="comment">//比较数字大小</span></span><br><span class="line">            <span class="keyword">if</span>(num1 &gt; num2) </span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(num1 &lt; num2)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//版本号相同</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(max(n,m))，其中m和n分别为两个字符串的长度，遍历两个字符串，复杂度选取较高值</li>
<li>空间复杂度：O(1)，常数级变量，无额外辅助空间</li>
</ul>
<h1 id="三、二叉树"><a href="#三、二叉树" class="headerlink" title="三、二叉树"></a>三、二叉树</h1><h2 id="BM23-二叉树的前序遍历"><a href="#BM23-二叉树的前序遍历" class="headerlink" title="BM23 二叉树的前序遍历"></a><strong>BM23</strong> <strong>二叉树的前序遍历</strong></h2><blockquote>
<p>给你二叉树的根节点 root ，返回它节点值的 前序 遍历。</p>
<p>数据范围：二叉树的节点数量满足 1≤n≤100 1≤<em>n</em>≤100 ，二叉树节点的值满足 1≤val≤100 1≤<em>v<strong>a</strong>l</em>≤100 ，树的各节点的值各不相同</p>
</blockquote>
<h3 id="思路：递归-2"><a href="#思路：递归-2" class="headerlink" title="思路：递归"></a>思路：递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        preorder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        preorder(root.left, res);</span><br><span class="line">        preorder(root.right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM24-二叉树的中序遍历"><a href="#BM24-二叉树的中序遍历" class="headerlink" title="BM24 二叉树的中序遍历"></a><strong>BM24</strong> <strong>二叉树的中序遍历</strong></h2><h2 id="BM25-二叉树的后序遍历"><a href="#BM25-二叉树的后序遍历" class="headerlink" title="BM25 二叉树的后序遍历"></a><strong>BM25</strong> <strong>二叉树的后序遍历</strong></h2><p>这几个题就不记录了，套板子就行～</p>
<h2 id="BM26-求二叉树的层序遍历"><a href="#BM26-求二叉树的层序遍历" class="headerlink" title="BM26 求二叉树的层序遍历"></a><strong>BM26</strong> <strong>求二叉树的层序遍历</strong></h2><h3 id="思路：BFS（广度优先搜索）"><a href="#思路：BFS（广度优先搜索）" class="headerlink" title="思路：BFS（广度优先搜索）"></a>思路：BFS（广度优先搜索）</h3><blockquote>
<p>DFS（深度优先搜索）和 BFS（广度优先搜索）就像孪生兄弟，提到一个总是想起另一个。然而在实际使用中，我们用 DFS 的时候远远多于 BFS。那么，是不是 BFS 就没有什么用呢？</p>
<p>如果我们使用 DFS&#x2F;BFS 只是为了遍历一棵树、一张图上的所有结点的话，那么 DFS 和 BFS 的能力没什么差别，我们当然更倾向于更方便写、空间复杂度更低的 DFS 遍历。不过，某些使用场景是 DFS 做不到的，只能使用 BFS 遍历。这就是本文要介绍的两个场景：「层序遍历」、「最短路径」</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">currentLevelSize</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= currentLevelSize; ++i) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                level.add(node.val);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ret.add(level);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：每个点进队出队各一次，故渐进时间复杂度为 O(n)。</li>
<li>空间复杂度：队列中元素的个数不超过 n 个，故渐进空间复杂度为 O(n)。</li>
</ul>
<p>可以适当记一下这个模版～理解起来就比较好记了，<span style='color:orange'>核心是利用队列的思想。</span></p>
<h2 id="BM27-按之字形顺序打印二叉树"><a href="#BM27-按之字形顺序打印二叉树" class="headerlink" title="BM27 按之字形顺序打印二叉树"></a><strong>BM27</strong> <strong>按之字形顺序打印二叉树</strong></h2><blockquote>
<p>给定一个二叉树，返回该二叉树的之字形层序遍历，（第一层从左向右，下一层从右向左，一直这样交替） </p>
<p>数据范围：0≤n≤1500,树上每个节点的val满足 ∣val∣&lt;&#x3D;1500<br>要求：空间复杂度：O(n)，时间复杂度：O(n)</p>
</blockquote>
<h2 id="思路：BFS"><a href="#思路：BFS" class="headerlink" title="思路：BFS"></a>思路：BFS</h2><p>和前面层序遍历一样，只不过需要加一个flag来判断是否当前层该逆序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">head</span> <span class="operator">=</span> pRoot;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt; &gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">//如果是空，则直接返回空list</span></span><br><span class="line">            <span class="keyword">return</span> res; </span><br><span class="line">        <span class="comment">//队列存储，进行层次遍历</span></span><br><span class="line">        Queue&lt;TreeNode&gt; temp = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;(); </span><br><span class="line">        temp.offer(head);</span><br><span class="line">        TreeNode p;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!temp.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//记录二叉树的某一行</span></span><br><span class="line">            ArrayList&lt;Integer&gt; row = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();  </span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> temp.size();</span><br><span class="line">            <span class="comment">//奇数行反转，偶数行不反转</span></span><br><span class="line">            flag = !flag; </span><br><span class="line">            <span class="comment">//因先进入的是根节点，故每层节点多少，队列大小就是多少</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                p = temp.poll();</span><br><span class="line">                row.add(p.val);</span><br><span class="line">                <span class="comment">//若是左右孩子存在，则存入左右孩子作为下一个层次</span></span><br><span class="line">                <span class="keyword">if</span>(p.left != <span class="literal">null</span>)</span><br><span class="line">                    temp.offer(p.left);</span><br><span class="line">                <span class="keyword">if</span>(p.right != <span class="literal">null</span>)</span><br><span class="line">                    temp.offer(p.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//奇数行反转，偶数行不反转</span></span><br><span class="line">            <span class="keyword">if</span>(flag)  </span><br><span class="line">                Collections.reverse(row);</span><br><span class="line">            res.add(row);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，每个节点访问一次，因为reverse的时间复杂度为O(n)，按每层元素reverse也相当于O(n)</li>
<li>空间复杂度：O(n)，队列的空间最长为O(n)</li>
</ul>
<h2 id="BM28-二叉树的最大深度"><a href="#BM28-二叉树的最大深度" class="headerlink" title="BM28 二叉树的最大深度"></a><strong>BM28</strong> <strong>二叉树的最大深度</strong></h2><h3 id="思路：递归-3"><a href="#思路：递归-3" class="headerlink" title="思路：递归"></a>思路：递归</h3><p>思路很简单，直接递归就好～</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span> <span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//空节点没有深度</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//返回子树深度+1</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="BM29-二叉树中和为某一值的路径-一"><a href="#BM29-二叉树中和为某一值的路径-一" class="headerlink" title="BM29 二叉树中和为某一值的路径(一)"></a><strong>BM29</strong> <strong>二叉树中和为某一值的路径(一)</strong></h2><blockquote>
<p>给定一个二叉树root和一个值 sum ，判断是否有从根节点到叶子节点的节点值之和等于 sum 的路径。</p>
<p>1.该题路径定义为从树的根结点开始往下一直到叶子结点所经过的结点</p>
<p>2.叶子节点是指没有子节点的节点</p>
<p>3.路径只能从父节点到子节点，不能从子节点到父节点</p>
<p>4.总节点数目为n</p>
</blockquote>
<h3 id="思路：递归-4"><a href="#思路：递归-4" class="headerlink" title="思路：递归"></a>思路：递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span> <span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="comment">//空节点找不到路径</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//叶子节点，且路径和为sum</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span> &amp;&amp; sum - root.val == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//递归进入子节点</span></span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM30-二叉搜索树与双向链表"><a href="#BM30-二叉搜索树与双向链表" class="headerlink" title="BM30 二叉搜索树与双向链表"></a><strong>BM30</strong> <strong>二叉搜索树与双向链表</strong></h2><blockquote>
<p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。如下图所示</p>
</blockquote>
<p><img src="https://picgooo.oss-cn-hangzhou.aliyuncs.com/img/E1F1270919D292C9F48F51975FD07CE2.png"></p>
<h3 id="思路：利用二叉搜索树的特征进行递归"><a href="#思路：利用二叉搜索树的特征进行递归" class="headerlink" title="思路：利用二叉搜索树的特征进行递归"></a>思路：利用二叉搜索树的特征进行递归</h3><p>核心：二叉搜索树最左端的元素一定最小，最右端的元素一定最大，符合“左中右”的特性，因此二叉搜索树的中序遍历就是一个递增序列，我们只要对它中序遍历就可以组装称为递增双向链表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//返回的第一个指针，即为最小值，先定为null</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">TreeNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">    <span class="comment">//中序遍历当前值的上一位，初值为最小值，先定为null</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;   </span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">Convert</span><span class="params">(TreeNode pRootOfTree)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">//中序递归，叶子为空则返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;     </span><br><span class="line">        <span class="comment">//首先递归到最左最小值  </span></span><br><span class="line">        Convert(pRootOfTree.left); </span><br><span class="line">        <span class="comment">//找到最小值，初始化head与pre</span></span><br><span class="line">        <span class="keyword">if</span>(pre == <span class="literal">null</span>)&#123;       </span><br><span class="line">            head = pRootOfTree;</span><br><span class="line">            pre = pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前节点与上一节点建立连接，将pre设置为当前值</span></span><br><span class="line">        <span class="keyword">else</span>&#123;       </span><br><span class="line">            pre.right = pRootOfTree;</span><br><span class="line">            pRootOfTree.left = pre;</span><br><span class="line">            pre = pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        Convert(pRootOfTree.right);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，其中n<em>n</em>为二叉树节点数，中序遍历所有节点</li>
<li>空间复杂度：O(n)，递归栈所需要的最大空间</li>
</ul>
<h2 id="BM31-对称的二叉树"><a href="#BM31-对称的二叉树" class="headerlink" title="BM31 对称的二叉树"></a><strong>BM31</strong> <strong>对称的二叉树</strong></h2><blockquote>
<p>给定一棵二叉树，判断其是否是自身的镜像（即：是否对称）<br>例如：                 下面这棵二叉树是对称的</p>
</blockquote>
<p><img src="https://picgooo.oss-cn-hangzhou.aliyuncs.com/img/A22A794C036C06431E632F9D5E2E298F.png"></p>
<h3 id="思路：递归-5"><a href="#思路：递归-5" class="headerlink" title="思路：递归"></a>思路：递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isSymmetrical</span><span class="params">(TreeNode pRoot)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> compare(pRoot.left,pRoot.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(TreeNode left, TreeNode right)</span>&#123;</span><br><span class="line">      <span class="comment">//可以两个都为空</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>)   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       <span class="comment">//只有一个为空或者节点值不同，必定不对称</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span> || right == <span class="literal">null</span> || left.val != right.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="comment">//每层对应的节点进入递归比较</span></span><br><span class="line">        <span class="keyword">return</span> compare(left.left,right.right)&amp;&amp;compare(left.right,right.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，其中n<em>n</em>为二叉树的节点数，相当于遍历整个二叉树两次</li>
<li>空间复杂度：O(n)，最坏情况二叉树退化为链表，递归栈深度为n<em>n</em></li>
</ul>
<h2 id="BM32-合并二叉树"><a href="#BM32-合并二叉树" class="headerlink" title="BM32 合并二叉树"></a><strong>BM32</strong> <strong>合并二叉树</strong></h2><blockquote>
<p>已知两颗二叉树，将它们合并成一颗二叉树。合并规则是：都存在的结点，就将结点值加起来，否则空的位置就由另一个树的结点来代替。例如：</p>
</blockquote>
<h3 id="思路：递归-6"><a href="#思路：递归-6" class="headerlink" title="思路：递归"></a>思路：递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span> <span class="params">(TreeNode t1, TreeNode t2)</span> &#123;</span><br><span class="line">        <span class="comment">//若只有一个节点返回另一个，两个都为null自然返回null</span></span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">null</span>) </span><br><span class="line">            <span class="keyword">return</span> t2;</span><br><span class="line">        <span class="keyword">if</span> (t2 == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> t1;</span><br><span class="line">        <span class="comment">//根左右的方式递归</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(t1.val + t2.val);</span><br><span class="line">        head.left = mergeTrees(t1.left, t2.left);</span><br><span class="line">        head.right = mergeTrees(t1.right, t2.right);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="BM33-二叉树的镜像"><a href="#BM33-二叉树的镜像" class="headerlink" title="BM33 二叉树的镜像"></a><strong>BM33</strong> <strong>二叉树的镜像</strong></h2><blockquote>
<p>操作给定的二叉树，将其变换为源二叉树的镜像。 </p>
<p>数据范围：二叉树的节点数 0≤n≤1000， 二叉树每个节点的值 0≤val≤1000</p>
<p>要求： 空间复杂度 O(n)。本题也有原地操作，即空间复杂度 O(1)的解法，时间复杂度 O(n)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">Mirror</span> <span class="params">(TreeNode pRoot)</span> &#123;</span><br><span class="line">        <span class="comment">//空树返回</span></span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//先递归子树</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> Mirror(pRoot.left);  </span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> Mirror(pRoot.right);</span><br><span class="line">        <span class="comment">//交换</span></span><br><span class="line">        pRoot.left = right; </span><br><span class="line">        pRoot.right = left;</span><br><span class="line">        <span class="keyword">return</span> pRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM34-判断是不是二叉搜索树"><a href="#BM34-判断是不是二叉搜索树" class="headerlink" title="BM34 判断是不是二叉搜索树"></a><strong>BM34</strong> <strong>判断是不是二叉搜索树</strong></h2><blockquote>
<p>给定一个二叉树根节点，请你判断这棵树是不是二叉搜索树。 </p>
<p>二叉搜索树满足每个节点的左子树上的所有节点均小于当前节点且右子树上的所有节点均大于当前节点。 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span> <span class="params">(TreeNode root)</span> &#123; </span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//先进入左子树</span></span><br><span class="line">        <span class="keyword">if</span>(!isValidBST(root.left)) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; pre)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//更新最值</span></span><br><span class="line">        pre = root.val;</span><br><span class="line">        <span class="comment">//再进入右子树</span></span><br><span class="line">        <span class="keyword">return</span> isValidBST(root.right); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM35-判断是不是完全二叉树"><a href="#BM35-判断是不是完全二叉树" class="headerlink" title="BM35 判断是不是完全二叉树"></a><strong>BM35</strong> <strong>判断是不是完全二叉树</strong></h2><blockquote>
<p>给定一个二叉树，确定他是否是一个完全二叉树。 </p>
<p>完全二叉树的定义：若二叉树的深度为 h，除第 h 层外，其它各层的结点数都达到最大个数，第 h 层所有的叶子结点都连续集中在最左边，这就是完全二叉树。（第 h 层可能包含 [1~2h] 个节点）</p>
</blockquote>
<h3 id="思路：层序遍历BFS"><a href="#思路：层序遍历BFS" class="headerlink" title="思路：层序遍历BFS"></a>思路：层序遍历BFS</h3><p>对完全二叉树最重要的定义就是叶子节点只能出现在最下层和次下层，所以我们想到可以使用队列辅助进行层次遍历——从上到下遍历所有层，每层从左到右，只有次下层和最下层才有叶子节点，其他层出现叶子节点就意味着不是完全二叉树。</p>
<ul>
<li>step 1：先判断空树一定是完全二叉树。</li>
<li>step 2：初始化一个队列辅助层次遍历，将根节点加入。</li>
<li>step 3：逐渐从队列中弹出元素访问节点，如果遇到某个节点为空，进行标记，代表到了完全二叉树的最下层，若是后续还有访问，则说明提前出现了叶子节点，不符合完全二叉树的性质。</li>
<li>step 4：否则，继续加入左右子节点进入队列排队，等待访问。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCompleteTree</span> <span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//空树一定是完全二叉树</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//辅助队列</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(); </span><br><span class="line">        queue.offer(root);</span><br><span class="line">        TreeNode cur;</span><br><span class="line">        <span class="comment">//定义一个首次出现的标记位</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">notComplete</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            cur = queue.poll();</span><br><span class="line">            <span class="comment">//标记第一次遇到空节点</span></span><br><span class="line">            <span class="keyword">if</span>(cur == <span class="literal">null</span>)&#123; </span><br><span class="line">                notComplete = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//后续访问已经遇到空节点了，说明经过了叶子</span></span><br><span class="line">            <span class="keyword">if</span>(notComplete) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            queue.offer(cur.left);</span><br><span class="line">            queue.offer(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，其中n<em>n</em>为二叉树节点数，层次遍历最坏情况下遍历每一个节点</li>
<li>空间复杂度：O(n)，最坏情况下，层次队列的最大空间为O(n)</li>
</ul>
<h2 id="BM36-判断是不是平衡二叉树"><a href="#BM36-判断是不是平衡二叉树" class="headerlink" title="BM36 判断是不是平衡二叉树"></a><strong>BM36</strong> <strong>判断是不是平衡二叉树</strong></h2><blockquote>
<p>输入一棵节点数为 n 二叉树，判断该二叉树是否是平衡二叉树。 </p>
<p>在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树 </p>
<p><strong>平衡二叉树</strong>（Balanced Binary Tree），具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p>
</blockquote>
<h3 id="思路：从底至顶"><a href="#思路：从底至顶" class="headerlink" title="思路：从底至顶"></a>思路：从底至顶</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> recur(root) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">recur</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> recur(root.left);</span><br><span class="line">        <span class="keyword">if</span>(left == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> recur(root.right);</span><br><span class="line">        <span class="keyword">if</span>(right == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(left - right) &lt; <span class="number">2</span> ? Math.max(left, right) + <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM37-二叉搜索树的最近公共祖先"><a href="#BM37-二叉搜索树的最近公共祖先" class="headerlink" title="BM37 二叉搜索树的最近公共祖先"></a><strong>BM37</strong> <strong>二叉搜索树的最近公共祖先</strong></h2><blockquote>
<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>1.对于该题的最近的公共祖先定义:对于有根树T的两个节点p、q，最近公共祖先LCA(T,p,q)表示一个节点x，满足x是p和q的祖先且x的深度尽可能大。在这里，一个节点也可以是它自己的祖先.</p>
<p>2.二叉搜索树是若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值</p>
<p>3.所有节点的值都是唯一的。</p>
<p>4.p、q 为不同节点且均存在于给定的二叉搜索树中。</p>
</blockquote>
<h3 id="思路：遍历-2"><a href="#思路：遍历-2" class="headerlink" title="思路：遍历"></a>思路：遍历</h3><ul>
<li>step 1：根据二叉搜索树的性质，从根节点开始查找目标节点，当前节点比目标小则进入右子树，当前节点比目标大则进入左子树，直到找到目标节点。这个过程成用数组记录遇到的元素。</li>
<li>step 2：分别在搜索二叉树中找到p和q两个点，并记录各自的路径为数组。</li>
<li>step 3：同时遍历两个数组，比较元素值，最后一个相等的元素就是最近的公共祖先。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//求得根节点到目标节点的路径</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title function_">getPath</span><span class="params">(TreeNode root, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="comment">//节点值都不同，可以直接用值比较</span></span><br><span class="line">        <span class="keyword">while</span>(node.val != target)&#123; </span><br><span class="line">            path.add(node.val);</span><br><span class="line">            <span class="comment">//小的在左子树</span></span><br><span class="line">            <span class="keyword">if</span>(target &lt; node.val) </span><br><span class="line">                node = node.left;</span><br><span class="line">            <span class="comment">//大的在右子树</span></span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        path.add(node.val);</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lowestCommonAncestor</span> <span class="params">(TreeNode root, <span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">        <span class="comment">//求根节点到两个节点的路径</span></span><br><span class="line">        ArrayList&lt;Integer&gt; path_p = getPath(root, p); </span><br><span class="line">        ArrayList&lt;Integer&gt; path_q = getPath(root, q);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//比较两个路径，找到第一个不同的点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; path_p.size() &amp;&amp; i &lt; path_q.size(); i++)&#123; </span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> path_p.get(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> path_q.get(i);</span><br><span class="line">            <span class="comment">//最后一个相同的节点就是最近公共祖先</span></span><br><span class="line">            <span class="keyword">if</span>(x == y) </span><br><span class="line">                res = path_p.get(i);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，设二叉树共有n<em>n</em>个节点，因此最坏情况二叉搜索树变成链表，搜索到目标节点需要O(n)<em>O</em>(<em>n</em>)，比较路径前半段的相同也需要O(n)</li>
<li>空间复杂度：O(n)，记录路径的数组最长为n</li>
</ul>
<h2 id="BM38-在二叉树中找到两个节点的最近公共祖先"><a href="#BM38-在二叉树中找到两个节点的最近公共祖先" class="headerlink" title="BM38 在二叉树中找到两个节点的最近公共祖先"></a><span style='color:orange'><strong>BM38</strong> <strong>在二叉树中找到两个节点的最近公共祖先</strong></span></h2><blockquote>
<p>给定一棵二叉树(保证非空)以及这棵树上的两个节点对应的val值 o1 和 o2，请找到 o1 和 o2 的最近公共祖先节点。 </p>
<p>数据范围：树上节点数满足 1≤n≤105 , 节点值val满足区间 [0,n)</p>
<p>要求：时间复杂度 O(n)</p>
</blockquote>
<h3 id="思路：回溯-DFS"><a href="#思路：回溯-DFS" class="headerlink" title="思路：回溯+DFS"></a>思路：回溯+DFS</h3><ul>
<li>step 1：利用dfs求得根节点到两个目标节点的路径：每次选择二叉树的一棵子树往下找，同时路径数组增加这个遍历的节点值。</li>
<li>step 2：一旦遍历到了叶子节点也没有，则回溯到父节点，寻找其他路径，回溯时要去掉数组中刚刚加入的元素。</li>
<li>step 3：然后遍历两条路径数组，依次比较元素值。</li>
<li>step 4：找到两条路径第一个不相同的节点即是最近公共祖先。</li>
</ul>
<p><img src="https://picgooo.oss-cn-hangzhou.aliyuncs.com/img/63C9C80875EEB9DD09F51096A6752306.gif"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//记录是否找到到o的路径</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>; </span><br><span class="line">    <span class="comment">//求得根节点到目标节点的路径</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; path, <span class="type">int</span> o)</span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(flag || root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        path.add(root.val);</span><br><span class="line">        <span class="comment">//节点值都不同，可以直接用值比较</span></span><br><span class="line">        <span class="keyword">if</span>(root.val == o)&#123; </span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//dfs遍历查找</span></span><br><span class="line">        dfs(root.left, path, o); </span><br><span class="line">        dfs(root.right, path, o);</span><br><span class="line">        <span class="comment">//找到</span></span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//回溯</span></span><br><span class="line">        path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lowestCommonAncestor</span> <span class="params">(TreeNode root, <span class="type">int</span> o1, <span class="type">int</span> o2)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; path1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(); </span><br><span class="line">        ArrayList&lt;Integer&gt; path2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(); </span><br><span class="line">        <span class="comment">//求根节点到两个节点的路径</span></span><br><span class="line">        dfs(root, path1, o1); </span><br><span class="line">        <span class="comment">//重置flag，查找下一个</span></span><br><span class="line">        flag = <span class="literal">false</span>; </span><br><span class="line">        dfs(root, path2, o2);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">        <span class="comment">//比较两个路径，找到第一个不同的点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; path1.size() &amp;&amp; i &lt; path2.size(); i++)&#123; </span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> path1.get(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> path2.get(i);</span><br><span class="line">            <span class="keyword">if</span>(x == y) </span><br><span class="line">                <span class="comment">//最后一个相同的节点就是最近公共祖先</span></span><br><span class="line">                res = x; </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，其中n<em>n</em>为二叉树节点数，递归遍历二叉树每一个节点求路径，后续又遍历路径</li>
<li>空间复杂度：O(n)，最坏情况二叉树化为链表，深度为n<em>n</em>，递归栈深度和路径数组为n</li>
</ul>
<p>这个回溯值得看一下</p>
<h2 id="BM40-重建二叉树"><a href="#BM40-重建二叉树" class="headerlink" title="BM40 重建二叉树"></a><strong>BM40</strong> <strong>重建二叉树</strong></h2><blockquote>
<p>给定节点数为 n 的二叉树的前序遍历和中序遍历结果，请重建出该二叉树并返回它的头结点。</p>
<p>例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建出如下图所示。</p>
</blockquote>
<ul>
<li>step 1：先根据前序遍历第一个点建立根节点。</li>
<li>step 2：然后遍历中序遍历找到根节点在数组中的位置。</li>
<li>step 3：再按照子树的节点数将两个遍历的序列分割成子数组，将子数组送入函数建立子树。</li>
<li>step 4：直到子树的序列长度为0，结束递归。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">reConstructBinaryTree</span><span class="params">(<span class="type">int</span> [] pre,<span class="type">int</span> [] vin)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> pre.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> vin.length;</span><br><span class="line">        <span class="comment">//每个遍历都不能为0</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || m == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//构建根节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(pre[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vin.length; i++)&#123;</span><br><span class="line">            <span class="comment">//找到中序遍历中的前序第一个元素</span></span><br><span class="line">            <span class="keyword">if</span>(pre[<span class="number">0</span>] == vin[i])&#123; </span><br><span class="line">                <span class="comment">//构建左子树</span></span><br><span class="line">                root.left = reConstructBinaryTree(Arrays.copyOfRange(pre, <span class="number">1</span>, i + <span class="number">1</span>), Arrays.copyOfRange(vin, <span class="number">0</span>, i)); </span><br><span class="line">                <span class="comment">//构建右子树</span></span><br><span class="line">                root.right = reConstructBinaryTree(Arrays.copyOfRange(pre, i + <span class="number">1</span>, pre.length), Arrays.copyOfRange(vin, i + <span class="number">1</span>, vin.length));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，其中n为数组长度，即二叉树的节点数，构建每个节点进一次递归，递归中所有的循环加起来一共n次</li>
<li>空间复杂度：O(n)，递归栈最大深度不超过n，辅助数组长度也不超过n，重建的二叉树空间属于必要空间，不属于辅助空间</li>
</ul>
<h2 id="BM41-输出二叉树的右视图"><a href="#BM41-输出二叉树的右视图" class="headerlink" title="BM41 输出二叉树的右视图"></a><strong>BM41</strong> <strong>输出二叉树的右视图</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="BM42-用两个栈实现队列"><a href="#BM42-用两个栈实现队列" class="headerlink" title="BM42 用两个栈实现队列"></a><strong>BM42</strong> <strong>用两个栈实现队列</strong></h2><blockquote>
<p>用两个栈来实现一个队列，使用n个元素来完成 n 次在队列尾部插入整数(push)和n次在队列头部删除整数(pop)的功能。 队列中的元素为int类型。保证操作合法，即保证pop操作时队列内已有元素。</p>
</blockquote>
<h3 id="思路：栈"><a href="#思路：栈" class="headerlink" title="思路：栈"></a>思路：栈</h3><p>直接模拟就好</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">  <span class="comment">//这里最好还是用Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;();来声明栈</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> node)</span> &#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//将第一个栈中内容弹出放入第二个栈中</span></span><br><span class="line">        <span class="keyword">while</span>(!stack1.isEmpty()) </span><br><span class="line">            stack2.push(stack1.pop()); </span><br><span class="line">        <span class="comment">//第二个栈栈顶就是最先进来的元素，即队首</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> stack2.pop(); </span><br><span class="line">        <span class="comment">//再将第二个栈的元素放回第一个栈</span></span><br><span class="line">        <span class="keyword">while</span>(!stack2.isEmpty()) </span><br><span class="line">            stack1.push(stack2.pop());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM43-包含min函数的栈"><a href="#BM43-包含min函数的栈" class="headerlink" title="BM43 包含min函数的栈"></a><strong>BM43</strong> <strong>包含min函数的栈</strong></h2><blockquote>
<p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的 min 函数，输入操作时保证 pop、top 和 min 函数操作时，栈中一定有元素。</p>
</blockquote>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//用于栈的push 与 pop</span></span><br><span class="line">    Stack&lt;Integer&gt; s1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;(); </span><br><span class="line">    <span class="comment">//用于存储最小min</span></span><br><span class="line">    Stack&lt;Integer&gt; s2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;(); </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//这里最好还是用Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;();来声明栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> node)</span> &#123;</span><br><span class="line">        s1.push(node);  </span><br><span class="line">        <span class="comment">//空或者新元素较小，则入栈</span></span><br><span class="line">        <span class="keyword">if</span>(s2.isEmpty() || s2.peek() &gt; node)  </span><br><span class="line">            s2.push(node);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//重复加入栈顶</span></span><br><span class="line">            s2.push(s2.peek());  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        s1.pop();</span><br><span class="line">        s2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s1.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM44-有效括号序列"><a href="#BM44-有效括号序列" class="headerlink" title="BM44 有效括号序列"></a><strong>BM44</strong> <strong>有效括号序列</strong></h2><blockquote>
<p>给出一个仅包含字符’(‘,’)’,’{‘,’}’,’[‘和’]’,的字符串，判断给出的字符串是否是合法的括号序列<br>括号必须以正确的顺序关闭，”()”和”()[]{}”都是合法的括号序列，但”(]”和”([)]”不合法。</p>
<p>数据范围：字符串长度 0≤n≤10000</p>
<p>要求：空间复杂度 O(n)，时间复杂度 O(n)</p>
</blockquote>
<h3 id="思路：模拟栈"><a href="#思路：模拟栈" class="headerlink" title="思路：模拟栈"></a>思路：模拟栈</h3><ul>
<li>step 1：创建辅助栈，遍历字符串。</li>
<li>step 2：每次遇到小括号的左括号、中括号的左括号、大括号的左括号，就将其对应的呦括号加入栈中，期待在后续遇到。</li>
<li>step 3：如果没有遇到左括号但是栈为空，说明直接遇到了右括号，不合法。</li>
<li>step 4：其他情况下，如果遇到右括号，刚好会与栈顶元素相同，弹出栈顶元素继续遍历。</li>
<li>step 5：理论上，只要括号是匹配的，栈中元素最后是为空的，因此检查栈是否为空即可最后判断是否合法。</li>
</ul>
<p><img src="https://picgooo.oss-cn-hangzhou.aliyuncs.com/img/4760A3E42ACB7E73D162BE2CD8C2E2C9.gif"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span> <span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">//辅助栈</span></span><br><span class="line">        Stack&lt;Character&gt; st = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Character&gt;();</span><br><span class="line">        <span class="comment">//遍历字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//遇到左小括号</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                <span class="comment">//期待遇到右小括号</span></span><br><span class="line">                st.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            <span class="comment">//遇到左中括号</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                <span class="comment">//期待遇到右中括号</span></span><br><span class="line">                st.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            <span class="comment">//遇到左打括号</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                <span class="comment">//期待遇到右打括号</span></span><br><span class="line">                st.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            <span class="comment">//必须有左括号的情况下才能遇到右括号</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (st.isEmpty() || st.pop() != s.charAt(i))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//栈中是否还有元素</span></span><br><span class="line">        <span class="keyword">return</span> st.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM45-滑动窗口的最大值"><a href="#BM45-滑动窗口的最大值" class="headerlink" title="BM45 滑动窗口的最大值"></a><strong>BM45</strong> <strong>滑动窗口的最大值</strong></h2><blockquote>
<p>给定一个数组 <code>nums</code> 和滑动窗口的大小 <code>k</code>，请找出所有滑动窗口里的最大值。</p>
<p>输入: nums &#x3D; [1,3,-1,-3,5,3,6,7], 和 k &#x3D; 3<br>输出: [3,3,5,5,6,7]<br>解释: </p>
<p>  滑动窗口的位置                最大值</p>
<hr>
<p> [1  3  -1] -3  5  3  6  7       3<br>         1 [3  -1  -3] 5  3  6  7       3<br>         1  3 [-1  -3  5] 3  6  7       5<br>         1  3  -1 [-3  5  3] 6  7       5<br>         1  3  -1  -3 [5  3  6] 7       6<br>         1  3  -1  -3  5 [3  6  7]      7</p>
</blockquote>
<h3 id="思路：单调队列"><a href="#思路：单调队列" class="headerlink" title="思路：单调队列"></a>思路：单调队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title function_">maxInWindows</span><span class="params">(<span class="type">int</span> [] num, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (num.length == <span class="number">0</span> || k == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>, i = <span class="number">1</span> - k ; j &lt; num.length; i++, j++) &#123;</span><br><span class="line">          <span class="comment">// 删除 deque 中对应的 nums[i-1]</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; deque.peekFirst() == num[i - <span class="number">1</span>])</span><br><span class="line">                deque.removeFirst();</span><br><span class="line">          <span class="comment">// 保持 deque 递减</span></span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; num[j])</span><br><span class="line">                deque.removeLast();</span><br><span class="line">            deque.addLast(num[j]);</span><br><span class="line">            <span class="comment">// 记录窗口最大值</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">0</span>)</span><br><span class="line">                res.add(deque.peekFirst());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM46-最小的K个数"><a href="#BM46-最小的K个数" class="headerlink" title="BM46 最小的K个数"></a><strong>BM46</strong> <strong>最小的K个数</strong></h2><blockquote>
<p>给定一个长度为 n 的可能有重复值的数组，找出其中不去重的最小的 k 个数。例如数组元素是4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4(任意顺序皆可)。</p>
<p>数据范围：0≤k,n≤10000，数组中每个数的大小0≤val≤1000</p>
<p>要求：空间复杂度 O(n) ，时间复杂度 O(nlogk)</p>
</blockquote>
<h3 id="思路1：sort快排"><a href="#思路1：sort快排" class="headerlink" title="思路1：sort快排"></a>思路1：sort快排</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title function_">GetLeastNumbers_Solution</span><span class="params">(<span class="type">int</span> [] input, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//排除特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span> || input.length == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        Arrays.sort(input); </span><br><span class="line">        <span class="comment">//因为k&lt;=input.length,取前k小</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++)&#123; </span><br><span class="line">            res.add(input[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(nlog2n)，sort函数属于优化后的快速排序，复杂度为O(nlog2n)<em>O</em>(<em>n<strong>l</strong>o**g</em>2<em>n</em>)</li>
<li>空间复杂度：O(1)，无额外辅助空间使用</li>
</ul>
<h2 id="思路2：堆排序"><a href="#思路2：堆排序" class="headerlink" title="思路2：堆排序"></a>思路2：堆排序</h2><p>优先队列即PriorityQueue，是一种内置的机遇堆排序的容器，分为大顶堆与小顶堆，大顶堆的堆顶为最大元素，其余更小的元素在堆下方，小顶堆与其刚好相反。且因为容器内部的次序基于堆排序，因此每次插入元素时间复杂度都是O(log2n)，而每次取出堆顶元素都是直接取出。</p>
<ul>
<li>step 1：利用input数组中前k个元素，构建一个大小为k的大顶堆，堆顶为这k个元素的最大值。</li>
<li>step 2：对于后续的元素，依次比较其与堆顶的大小，若是比堆顶小，则堆顶弹出，再将新数加入堆中，直至数组结束，保证堆中的k个最小。</li>
<li>step 3：最后将堆顶依次弹出即是最小的k个数。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title function_">GetLeastNumbers_Solution</span><span class="params">(<span class="type">int</span> [] input, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//排除特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span> || input.length == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">//大根堆 </span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((o1, o2)-&gt;o2.compareTo(o1));</span><br><span class="line">        <span class="comment">//构建一个k个大小的堆  </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">            q.offer(input[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k; i &lt; input.length; i++)&#123;</span><br><span class="line">            <span class="comment">//较小元素入堆</span></span><br><span class="line">            <span class="keyword">if</span>(q.peek() &gt; input[i])&#123;  </span><br><span class="line">                q.poll();</span><br><span class="line">                q.offer(input[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//堆中元素取出入数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) </span><br><span class="line">            res.add(q.poll());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(nlog2k)，构建和维护大小为k<em>k</em>的堆，需要log2k<em>l<strong>o</strong>g</em>2<em>k</em>，加上遍历整个数组</li>
<li>空间复杂度：O(k)，堆空间为k个元素</li>
</ul>
<h2 id="BM47-寻找第K大"><a href="#BM47-寻找第K大" class="headerlink" title="BM47 寻找第K大"></a><strong>BM47</strong> <strong>寻找第K大</strong></h2><blockquote>
<p>有一个整数数组，请你根据快速排序的思路，找出数组中第 k 大的数。 </p>
<p>给定一个整数数组 a ,同时给定它的大小n和要找的 k ，请返回第 k 大的数(包括重复的元素，不用去重)，保证答案存在。 </p>
<p>要求：时间复杂度 O(nlogn)，空间复杂度 O(1)</p>
<p>数据范围：0≤n≤1000， 1≤K≤n，数组中每个元素满足 0≤val≤10000000</p>
</blockquote>
<h3 id="思路1：随机选择"><a href="#思路1：随机选择" class="headerlink" title="思路1：随机选择"></a>思路1：随机选择</h3><p>速排序的思想–随机选择法，时间复杂度 O(n) 需要理解两个思想，快排的分治，二分查找的剪枝 分治法，每个分支“都要”递归，例如：快速排序，O(n*lg(n)) 减治法，“只要”递归一个分支，例如：二分查找O(lg(n))，随机选择O(n) TopK的另一个解法：随机选择 + partition。</p>
<p>其实要找第k大，前面的排序再取值已经知道了第K大的数，下标是len - k。那么partition能直接定位到len - k 的位置就找到了结果。如何找呢，就用到了二分查找的思想，不断接近len-k的位置，最终返回结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKth</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> n, <span class="type">int</span> K)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> quickSort(a, <span class="number">0</span>, a.length - <span class="number">1</span>, K);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition(arr, left, right);</span><br><span class="line">        <span class="comment">// 改进后，很特殊的是，p是全局下标，只要p对上topK坐标就可以返回</span></span><br><span class="line">        <span class="keyword">if</span> (p == arr.length - k) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr[p];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (p &lt; arr.length - k) &#123;</span><br><span class="line">            <span class="comment">// 如果基准在左边，这在右边找</span></span><br><span class="line">            <span class="keyword">return</span> quickSort(arr, p + <span class="number">1</span>, right,k);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> quickSort(arr, left, p - <span class="number">1</span>,k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">// 可优化成随机，或中位数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> arr[left];</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt;= key) right--;</span><br><span class="line">            arr[left] = arr[right];</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= key) left++;</span><br><span class="line">            arr[right] = arr[left];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[left] = key;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="思路2：内置方法"><a href="#思路2：内置方法" class="headerlink" title="思路2：内置方法"></a>思路2：内置方法</h2><p>全局排序，时间复杂度取决于排序算法，一般是 O(n*lgn)。 相信大多数朋友看到这题的思路就是排序，返回第k大的值，甚至还有小机灵鬼直接调用内置方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKth</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> n, <span class="type">int</span> K)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        Arrays.sort(a);</span><br><span class="line">        <span class="keyword">return</span> a[n-K];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM48-数据流中的中位数"><a href="#BM48-数据流中的中位数" class="headerlink" title="BM48 数据流中的中位数"></a><strong>BM48</strong> <strong>数据流中的中位数</strong></h2><blockquote>
<p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p>
</blockquote>
<h3 id="思路：优先级队列"><a href="#思路：优先级队列" class="headerlink" title="思路：优先级队列"></a>思路：优先级队列</h3><p>困难题目，详解参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/solution/mian-shi-ti-41-shu-ju-liu-zhong-de-zhong-wei-shu-y/">k神</a>。讲的很到位</p>
<p>有一点需要注意：</p>
<ul>
<li>A（小顶堆，存储较大的一半）</li>
<li>B（大顶堆，存储较小的一半）</li>
</ul>
<p><span style='color:orange'>假设插入数字 num 遇到情况 m&#x3D;n的时候，也即数据为偶数的时候 。由于 num 可能属于 “较小的一半” （即属于 B ），因此不能将 nums 直接插入至 A（小顶堆，存储较大的一半） 。而应先将 num 插入至 B ，再将 B 堆顶元素插入至 A 。这样就可以始终保持 A 保存较大一半、 B 保存较小一半。</span></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt; A,B;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Solution</span><span class="params">()</span>&#123;</span><br><span class="line">        A = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">        B = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Comparator.reverseOrder());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Insert</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(A.size() != B.size())&#123;</span><br><span class="line">            A.add(num);</span><br><span class="line">            B.add(A.poll());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            B.add(num);</span><br><span class="line">            A.add(B.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Double <span class="title function_">GetMedian</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (Double)(A.size() != B.size() ? A.peek() : (A.peek() + B.peek()) / <span class="number">2.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM49-表达式求值"><a href="#BM49-表达式求值" class="headerlink" title="BM49 表达式求值"></a><strong>BM49</strong> <strong>表达式求值</strong></h2><blockquote>
<p>请写一个整数计算器，支持加减乘三种运算和括号。 </p>
<p>数据范围：0≤∣s∣≤100，保证计算结果始终在整型范围内</p>
<p>要求：空间复杂度： O(n)，时间复杂度 O(n)</p>
</blockquote>
<h2 id="BM50-两数之和"><a href="#BM50-两数之和" class="headerlink" title="BM50 两数之和"></a><strong>BM50</strong> <strong>两数之和</strong></h2><blockquote>
<p>给出一个整型数组 numbers 和一个目标值 target，请在数组中找出两个加起来等于目标值的数的下标，返回的下标按升序排列。 </p>
<p>（注：<strong>返回</strong>的数组下标从1开始算起，保证target一定可以由数组里面2个数字相加得到） </p>
</blockquote>
<h3 id="思路：哈希"><a href="#思路：哈希" class="headerlink" title="思路：哈希"></a>思路：哈希</h3><p>很简单～不记录了</p>
<p>主要是要记得：map.containsKey（）、return new int[]{}这两个语法</p>
<h2 id="BM51-数组中出现次数超过一半的数字"><a href="#BM51-数组中出现次数超过一半的数字" class="headerlink" title="BM51 数组中出现次数超过一半的数字"></a><strong>BM51</strong> <strong>数组中出现次数超过一半的数字</strong></h2><blockquote>
<p>给一个长度为 n 的数组，数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。 </p>
<p>例如输入一个长度为9的数组[1,2,3,2,2,2,5,4,2]。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。 </p>
<p>数据范围：n≤5000，数组中元素的值 0≤val≤10000</p>
<p>要求：空间复杂度：O(1)，时间复杂度 O(n)</p>
</blockquote>
<h3 id="思路：哈希-1"><a href="#思路：哈希-1" class="headerlink" title="思路：哈希"></a>思路：哈希</h3><p>一样很简答的一题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">MoreThanHalfNum_Solution</span><span class="params">(<span class="type">int</span> [] array)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> array.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; len ; i++)&#123;</span><br><span class="line">            map.put(array[i],map.getOrDefault(array[i],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(map.get(array[i]) &gt; len/<span class="number">2</span>)&#123;</span><br><span class="line">                res = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM52-数组中只出现一次的两个数字"><a href="#BM52-数组中只出现一次的两个数字" class="headerlink" title="BM52 数组中只出现一次的两个数字"></a><strong>BM52</strong> <strong>数组中只出现一次的两个数字</strong></h2><blockquote>
<p>一个整型数组里除了两个数字只出现一次，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] FindNumsAppearOnce (<span class="type">int</span>[] array) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; array.length ;i++)&#123;</span><br><span class="line">            map.put(array[i],map.getOrDefault(array[i],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; array.length ; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(array[i]) == <span class="number">1</span>)&#123;</span><br><span class="line">                res.add(array[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.get(<span class="number">0</span>) &lt; res.get(<span class="number">1</span>)?<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;res.get(<span class="number">0</span>),res.get(<span class="number">1</span>)&#125;:<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;res.get(<span class="number">1</span>),res.get(<span class="number">0</span>)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM53-缺失的第一个正整数"><a href="#BM53-缺失的第一个正整数" class="headerlink" title="BM53 缺失的第一个正整数"></a><strong>BM53</strong> <strong>缺失的第一个正整数</strong></h2><blockquote>
<p>给定一个无重复元素的整数数组nums，请你找出其中没有出现的最小的正整数</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minNumberDisappeared</span> <span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; mp = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;(); </span><br><span class="line">        <span class="comment">//哈希表记录数组中出现的每个数字</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">            mp.put(nums[i], <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//从1开始找到哈希表中第一个没有出现的正整数</span></span><br><span class="line">        <span class="keyword">while</span>(mp.containsKey(res)) </span><br><span class="line">            res++;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM-54-三数之和"><a href="#BM-54-三数之和" class="headerlink" title="BM 54 三数之和"></a>BM 54 三数之和</h2><h3 id="思路：排序-双指针"><a href="#思路：排序-双指针" class="headerlink" title="思路：排序+双指针"></a>思路：排序+双指针</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; nums.length - <span class="number">2</span>; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[k] &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k + <span class="number">1</span>, j = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[k] + nums[i] + nums[j];</span><br><span class="line">                <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] == nums[++i]);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] == nums[--j]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(Arrays.asList(nums[k], nums[i], nums[j])));</span><br><span class="line">                    <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] == nums[++i]);</span><br><span class="line">                    <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] == nums[--j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM55-没有重复项数字的全排列"><a href="#BM55-没有重复项数字的全排列" class="headerlink" title="BM55 没有重复项数字的全排列"></a><span style='color:red'><strong>BM55</strong> <strong>没有重复项数字的全排列</strong></span></h2><blockquote>
<p>给出一组数字，返回该组数字的所有排列 </p>
<p>例如： </p>
<p>[1,2,3]的所有排列如下<br>[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2], [3,2,1].<br>（以数字在数组中的位置靠前为优先级，按字典序排列输出。） </p>
<p>数据范围：数字个数 0&lt;n≤6</p>
<p>要求：空间复杂度 O(n!) ，时间复杂度 O(n!）</p>
</blockquote>
<h3 id="思路：回溯"><a href="#思路：回溯" class="headerlink" title="思路：回溯"></a>思路：回溯</h3><p>这个理解有点难，可以适当记一下～</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] num)</span> &#123;</span><br><span class="line">      res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">      <span class="comment">// 存一种排列</span></span><br><span class="line">        LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">      <span class="comment">// 递归进行</span></span><br><span class="line">        backTrack(num,list);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(<span class="type">int</span>[] num , LinkedList&lt;Integer&gt; list)</span>&#123;</span><br><span class="line">      <span class="comment">// 当list中的长度等于数组的长度，则证明此时已经找到一种排列了</span></span><br><span class="line">        <span class="keyword">if</span>(list.size() == num.length)&#123;</span><br><span class="line">          <span class="comment">// add进返回结果集中</span></span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(list));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 遍历num数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; num.length ; i++)&#123;</span><br><span class="line">          <span class="comment">// 若当前位置中的数已经添加过了则跳过</span></span><br><span class="line">            <span class="keyword">if</span>(list.contains(num[i]))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">          <span class="comment">// 选择该数</span></span><br><span class="line">            list.add(num[i]);</span><br><span class="line">          <span class="comment">// 继续寻找</span></span><br><span class="line">            backTrack(num,list);</span><br><span class="line">          <span class="comment">// 撤销最后一个</span></span><br><span class="line">            list.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更快的写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; output = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            output.add(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        backtrack(n, output, res, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> n, List&lt;Integer&gt; output, List&lt;List&lt;Integer&gt;&gt; res, <span class="type">int</span> first)</span> &#123;</span><br><span class="line">        <span class="comment">// 所有数都填完了</span></span><br><span class="line">        <span class="keyword">if</span> (first == n) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(output));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> first; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 动态维护数组</span></span><br><span class="line">            Collections.swap(output, first, i);</span><br><span class="line">            <span class="comment">// 继续递归填下一个数</span></span><br><span class="line">            backtrack(n, output, res, first + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 撤销操作</span></span><br><span class="line">            Collections.swap(output, first, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<p>其实这种写法和第一种写法本质上一样～</p>
<p><span style='color:orange'>最好背下面这个！</span></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list ;</span><br><span class="line">    <span class="type">boolean</span>[] visit;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">       list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       visit = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">       List&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       permute(nums,<span class="number">0</span>,tmp);</span><br><span class="line">       <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> dp,List&lt;Integer&gt; tmp)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp == nums.length)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(tmp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visit[i])&#123;</span><br><span class="line">                tmp.add(nums[i]);</span><br><span class="line">                visit[i] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                permute(nums,dp+<span class="number">1</span>,tmp);</span><br><span class="line"></span><br><span class="line">                tmp.remove(tmp.size()-<span class="number">1</span>);</span><br><span class="line">                visit[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM56-有重复项数字的全排列"><a href="#BM56-有重复项数字的全排列" class="headerlink" title="BM56 有重复项数字的全排列"></a><strong>BM56</strong> <strong>有重复项数字的全排列</strong></h2><blockquote>
<p>给出一组可能包含重复项的数字，返回该组数字的所有排列。结果以字典序升序排列。</p>
</blockquote>
<h3 id="思路：回溯-1"><a href="#思路：回溯-1" class="headerlink" title="思路：回溯"></a>思路：回溯</h3><p>和上个题目一样，区别是要加一个判断条件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">    <span class="type">boolean</span>[] visit;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        visit = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backTrack(nums, <span class="number">0</span> , temp);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(<span class="type">int</span>[] nums , <span class="type">int</span> dp , ArrayList&lt;Integer&gt; temp )</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp.size() == nums.length)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(temp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; nums.length ; i++)&#123;</span><br><span class="line">          <span class="comment">//关键在于这里：如果当前数已经被访问过了，或者当前数和前面一个数一样而且前面一个数没有访问过</span></span><br><span class="line">          <span class="comment">//就直接跳过本次循环，</span></span><br><span class="line">            <span class="keyword">if</span>(visit[i] || (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !visit[i - <span class="number">1</span>]))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp.add(nums[i]);</span><br><span class="line">            visit[i] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            backTrack(nums,dp+<span class="number">1</span> ,temp);</span><br><span class="line"></span><br><span class="line">            temp.remove(temp.size()-<span class="number">1</span>);</span><br><span class="line">            visit[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM57-岛屿数量"><a href="#BM57-岛屿数量" class="headerlink" title="BM57 岛屿数量"></a><strong>BM57</strong> <strong>岛屿数量</strong></h2><blockquote>
<p>给一个01矩阵，1代表是陆地，0代表海洋， 如果两个1相邻，那么这两个1属于同一个岛。我们只考虑上下左右为相邻。</p>
<p>岛屿: 相邻陆地可以组成一个岛屿（相邻:上下左右） 判断岛屿个数。</p>
</blockquote>
<h3 id="思路：dfs"><a href="#思路：dfs" class="headerlink" title="思路：dfs"></a>思路：dfs</h3><p>比较简单的想法就是：找到一个1，就把离这个1最近的1全部变为0～</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; grid.length ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; grid[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    dfs(grid,i,j);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] grid,<span class="type">int</span> i , <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= grid.length || j &gt;= grid[<span class="number">0</span>].length || grid[i][j] == <span class="string">&#x27;0&#x27;</span> )   <span class="keyword">return</span>;</span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        dfs(grid,i-<span class="number">1</span>,j);</span><br><span class="line">        dfs(grid,i+<span class="number">1</span>,j);</span><br><span class="line">        dfs(grid,i,j-<span class="number">1</span>);</span><br><span class="line">        dfs(grid,i,j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM58-字符串的排列"><a href="#BM58-字符串的排列" class="headerlink" title="BM58 字符串的排列"></a><strong>BM58</strong> <strong>字符串的排列</strong></h2><blockquote>
<p>输入一个长度为 n 字符串，打印出该字符串中字符的所有排列，你可以以任意顺序返回这个字符串数组。</p>
<p>例如输入字符串ABC,则输出由字符A,B,C所能排列出来的所有字符串ABC,ACB,BAC,BCA,CBA和CAB。</p>
</blockquote>
<h3 id="思路：回溯-2"><a href="#思路：回溯-2" class="headerlink" title="思路：回溯"></a>思路：回溯</h3><p>和前面的回溯一样，可以套模版</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    ArrayList&lt;String&gt; res;</span><br><span class="line">    <span class="type">boolean</span>[] visit;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title function_">Permutation</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        visit = <span class="keyword">new</span> <span class="title class_">boolean</span>[str.length()];</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] chars = str.toCharArray();</span><br><span class="line">        Arrays.sort(chars);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str_new</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        backTrack(str_new , <span class="number">0</span> ,temp );</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(String str , <span class="type">int</span> dp , StringBuilder temp)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp == str.length())&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">String</span>(temp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; str.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visit[i] || (i&gt;<span class="number">0</span> &amp;&amp; str.charAt(i) == str.charAt(i-<span class="number">1</span>) &amp;&amp; !visit[i-<span class="number">1</span>]))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp.append(str.charAt(i));</span><br><span class="line">            visit[i] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            backTrack(str,dp+<span class="number">1</span>,temp);</span><br><span class="line">            temp.deleteCharAt(temp.length()-<span class="number">1</span>);</span><br><span class="line">            visit[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM60-括号生成"><a href="#BM60-括号生成" class="headerlink" title="BM60 括号生成"></a><strong>BM60</strong> <strong>括号生成</strong></h2><blockquote>
<p>给出n对括号，请编写一个函数来生成所有的由n对括号组成的合法组合。</p>
<p>例如，给出n&#x3D;3，解集为：</p>
<p>“((()))”, “(()())”, “(())()”, “()()()”, “()(())”</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串ArrayList</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title function_">generateParenthesis</span> <span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        ArrayList&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="string">&quot;&quot;</span> , n , n ,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(String str , <span class="type">int</span> left ,<span class="type">int</span> right , ArrayList&lt;String&gt; res)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>)&#123;</span><br><span class="line">            res.add(str);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            dfs(str+<span class="string">&quot;(&quot;</span> , left-<span class="number">1</span> , right , res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            dfs(str+<span class="string">&quot;)&quot;</span> , left , right-<span class="number">1</span> ,res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="BM61-矩阵最长递增路径"><a href="#BM61-矩阵最长递增路径" class="headerlink" title="BM61 矩阵最长递增路径"></a><strong>BM61</strong> <strong>矩阵最长递增路径</strong></h2><blockquote>
<p>给定一个 n 行 m 列矩阵 matrix ，矩阵内所有数均为非负整数。 你需要在矩阵中找到一条最长路径，使这条路径上的元素是递增的。并输出这条最长路径的长度。 </p>
<p>这个路径必须满足以下条件：</p>
<p>\1. 对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外。</p>
<p>\2. 你不能走重复的单元格。即每个格子最多只能走一次。</p>
</blockquote>
<h3 id="思路：记忆搜索"><a href="#思路：记忆搜索" class="headerlink" title="思路：记忆搜索"></a>思路：记忆搜索</h3><p>结合了dfs的想法～</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上下左右四个方向</span></span><br><span class="line">    <span class="type">int</span>[][] dirs = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestIncreasingPath</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="comment">// 从每一个点出发，往下深搜，看它最远能到哪</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记忆化</span></span><br><span class="line">        <span class="type">int</span>[][] memo = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 每个点都要作为起始点遍历一下</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="comment">// 已经遍历过的就不用遍历了</span></span><br><span class="line">                <span class="keyword">if</span> (memo[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    ans = Math.max(ans, dfs(matrix, m, n, i, j, memo));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 这里为什么不用再比较一次 ans 和 memo[i][j]呢？</span></span><br><span class="line">                <span class="comment">// 因为遍历前面节点的时候已经把后面的节点遍历了</span></span><br><span class="line">                <span class="comment">// 说明后面的节点肯定比前面的节点的最长路径短</span></span><br><span class="line">                <span class="comment">// 所以，不用多判断一次了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span>[][] memo)</span> &#123;</span><br><span class="line">        <span class="comment">// 已经遍历过，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (memo[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i][j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 否则，看四个方向是否有满足条件的节点去扩散</span></span><br><span class="line">        <span class="comment">// 每个节点的初始路径为1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] dir : dirs) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextI</span> <span class="operator">=</span> i + dir[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextJ</span> <span class="operator">=</span> j + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (nextI &gt;= <span class="number">0</span> &amp;&amp; nextJ &gt;= <span class="number">0</span> &amp;&amp; nextI &lt; m &amp;&amp; nextJ &lt;n &amp;&amp; matrix[nextI][nextJ] &gt; matrix[i][j]) &#123;</span><br><span class="line">                ans = Math.max(ans, dfs(matrix, m, n, nextI, nextJ, memo) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录到缓存中</span></span><br><span class="line">        memo[i][j] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
              <a href="/tags/%E5%88%B7%E9%A2%98/" rel="tag"><i class="fa fa-tag"></i> 刷题</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/02/14/33-%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E5%87%BB/" rel="prev" title="剑指offer专项突击">
                  <i class="fa fa-chevron-left"></i> 剑指offer专项突击
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/03/13/35-%E5%85%AB%E8%82%A1%E8%AE%B0%E5%BD%95%E2%80%94%E2%80%94Java%E5%9F%BA%E7%A1%80/" rel="next" title="八股记录——Java基础部分">
                  八股记录——Java基础部分 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2021 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yann Cheung</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>Word count total: </span>
    <span title="Word count total">344k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>Reading time total &asymp;</span>
    <span title="Reading time total">5:13</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.3/jquery.min.js" integrity="sha256-pvPw+upLPUjgMXY0G+8O0xUf+/Im1MZjXxxgOcBQBXU=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>



  <script src="/js/third-party/fancybox.js"></script>


  





</body>
</html>
